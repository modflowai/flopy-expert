filename,package_code,embedding_text,semantic_purpose
mfdataarray.py,,"mf6 Provides an interface for the user to access and update MODFLOW array data.
MFArray objects are not designed to be directly constructed by the end
user. When a FloPy for MODFLOW 6 package object is constructed, the
appropriate MFArray objects are automatically built.

Parameters
----------
sim_data : MFSimulationData
    data contained in the simulation
structure : MFDataStructure
    describes the structure of the data
data : list or ndarray
    actual data
enable : bool
    enable/disable the  This module provides the core data structures for handling spatially distributed, array-based input data within FloPy for MODFLOW 6 models. It is not a MODFLOW package or solver itself, but rather an essential internal component that underpins how nearly all MODFLOW 6 packages manage gridded data.

The module's primary purpose is to act as a sophisticated container that translates user-provided data (like Python floats, lists, or NumPy arrays) into the highly structured format required by MODFLOW 6 input files. It handles the complexity of different data types, such as:

*   **Static vs. Transient Data:** The `MFArray` class is used for static (time-invariant) properties like initial heads (IC package) or hydraulic conductivity (NPF package). The `MFTransientArray` class is for time-varying data like recharge (RCH package) or evapotranspiration (EVT package), which can change with each stress period.
*   **Data Dimensionality:** It correctly processes and validates data whether it's a single constant value (e.g., uniform recharge), a 1D array, a 2D array (per layer), or a 3D array (for the full grid).
*   **MODFLOW 6 Syntax:** The classes automatically handle the generation of required MODFLOW 6 keywords like `CONSTANT`, `INTERNAL`, and `OPEN/CLOSE` (for external files), abstracting this file-formatting complexity away from the user.

In essence, `mfdataarray.py` serves as the bridge between high-level, user-friendly data assignment in Python and the low-level, syntactically rigid text files that MODFLOW 6 consumes. **Scenario 1: Defining Aquifer Properties** **Scenario 2: Applying Spatially Variable but Temporally Constant Recharge** **Scenario 3: Simulating Seasonal Pumping from an Agricultural Wellfield** **MFData (Base Concept):** `MFArray` and `MFTransientArray` are specific implementations of a more general data handling framework in FloPy for MF6. Other data structures exist for different types of input, most notably `MFList` (and `MFTransientList`), which handles list-based ""record array"" data used by packages like the Well (WEL), Drain (DRN), and River (RIV) packages. **MODFLOW 6 Packages:** This module is intrinsically linked to almost every MODFLOW 6 package that requires gridded data input. This includes the Node Property Flow (`NPF`), Initial Conditions (`IC`), Storage (`STO`), Recharge (`RCH`), Evapotranspiration (`EVT`), and advanced packages like Unsaturated Zone Flow (`UZF`). Understanding this module is key to understanding how data is managed in all these packages. **MODFLOW 6 Input File Structure:** The design of `MFArray` and `MFTransientArray` directly mirrors the input requirements of MODFLOW 6. The objects are built to generate blocks of text that start with keywords (e.g., `K`, `RECHARGE`), followed by control words (`CONSTANT`, `INTERNAL`), and then the data itself, often within `BEGIN PERIOD`/`END PERIOD` blocks for transient data.","This module provides the core data structures for handling spatially distributed, array-based input data within FloPy for MODFLOW 6 models. It is not a MODFLOW package or solver itself, but rather an essential internal component that underpins how nearly all MODFLOW 6 packages manage gridded data.

The module's primary purpose is to act as a sophisticated container that translates user-provided data (like Python floats, lists, or NumPy arrays) into the highly structured format required by MODFLOW 6 input files. It handles the complexity of different data types, such as:

*   **Static vs. Transient Data:** The `MFArray` class is used for static (time-invariant) properties like initial heads (IC package) or hydraulic conductivity (NPF package). The `MFTransientArray` class is for time-varying data like recharge (RCH package) or evapotranspiration (EVT package), which can change with each stress period.
*   **Data Dimensionality:** It correctly processes and validates data whether it's a single constant value (e.g., uniform recharge), a 1D array, a 2D array (per layer), or a 3D array (for the full grid).
*   **MODFLOW 6 Syntax:** The classes automatically handle the generation of required MODFLOW 6 keywords like `CONSTANT`, `INTERNAL`, and `OPEN/CLOSE` (for external files), abstracting this file-formatting complexity away from the user.

In essence, `mfdataarray.py` serves as the bridge between high-level, user-friendly data assignment in Python and the low-level, syntactically rigid text files that MODFLOW 6 consumes."
mfdatalist.py,,"mf6 Provides an interface for the user to access and update MODFLOW
list data.  MFList objects are not designed to be directly constructed by
the end user. When a flopy for MODFLOW 6 package object is constructed, the
appropriate MFList objects are automatically built.

Parameters
----------
sim_data : MFSimulationData
    data contained in the simulation
structure : MFDataStructure
    describes the structure of the data
data : list or ndarray or None
    actual data
enable : bool
    enable/disabl This module is a foundational component within the FloPy framework for MODFLOW 6 and does not correspond to a single, user-facing MODFLOW package. Its primary purpose is to define the **data structures and methods for handling list-based input data**. In MODFLOW, input data is generally categorized as either array-based (e.g., a value for every cell in a grid layer) or list-based (e.g., a list of specific cells where a boundary condition applies). This module provides the engine for the latter.

The key classes in this module are:

*   `MFList`: The base class for handling a single, static list of data. This is for data that does not change throughout the simulation.
*   `MFTransientList`: This is the most commonly used class. It inherits from `MFList` and adds the functionality to handle **transient** list-based data. This allows users to specify different boundary condition data for different stress periods. The data is managed internally as a dictionary where keys are zero-based stress period numbers and values are the list of records for that period.
*   `MFMultipleList`: A more specialized class for handling MODFLOW 6 packages that can contain multiple, independent lists of data within a single package file. The prime example is the Mover (MVR) package, which defines multiple sets of connections for moving water between packages.

In summary, `mfdatalist.py` is an internal abstraction layer. It provides the standardized structure that user-facing packages like the Well (WEL), River (RIV), Drain (DRN), and General-Head Boundary (GHB) packages use to read, store, validate, and write their data to MODFLOW 6 input files. A hydrologist will almost never import or instantiate these classes directly, but will interact with them implicitly whenever they define a list-based boundary condition.","This module is a foundational component within the FloPy framework for MODFLOW 6 and does not correspond to a single, user-facing MODFLOW package. Its primary purpose is to define the **data structures and methods for handling list-based input data**. In MODFLOW, input data is generally categorized as either array-based (e.g., a value for every cell in a grid layer) or list-based (e.g., a list of specific cells where a boundary condition applies). This module provides the engine for the latter.

The key classes in this module are:

*   `MFList`: The base class for handling a single, static list of data. This is for data that does not change throughout the simulation.
*   `MFTransientList`: This is the most commonly used class. It inherits from `MFList` and adds the functionality to handle **transient** list-based data. This allows users to specify different boundary condition data for different stress periods. The data is managed internally as a dictionary where keys are zero-based stress period numbers and values are the list of records for that period.
*   `MFMultipleList`: A more specialized class for handling MODFLOW 6 packages that can contain multiple, independent lists of data within a single package file. The prime example is the Mover (MVR) package, which defines multiple sets of connections for moving water between packages.

In summary, `mfdatalist.py` is an internal abstraction layer. It provides the standardized structure that user-facing packages like the Well (WEL), River (RIV), Drain (DRN), and General-Head Boundary (GHB) packages use to read, store, validate, and write their data to MODFLOW 6 input files. A hydrologist will almost never import or instantiate these classes directly, but will interact with them implicitly whenever they define a list-based boundary condition."
mfdatascalar.py,,"mf6 Provides an interface for the user to access and update MODFLOW
scalar data. MFScalar objects are not designed to be directly constructed
by the end user. When a flopy for MODFLOW 6 package object is constructed,
the appropriate MFScalar objects are automatically built.

Parameters
----------
sim_data : MFSimulationData
    data contained in the simulation
structure : MFDataStructure
    describes the structure of the data
data : list or ndarray
    actual data
enable : bool
    enable/disable t The `mfdatascalar.py` module is a fundamental, internal component of FloPy's data handling framework for MODFLOW 6. It is **not** a user-facing package module like the Discretization (DIS) or Node Property Flow (NPF) packages. Its specific purpose is to represent, manage, and write **scalar** (single-value) data variables within a MODFLOW 6 simulation.

This module provides two key classes:
*   **`MFScalar`**: Handles a single, static value that does not change over time. This is used for global settings, flags, or parameters that are constant throughout a simulation. Examples include solver tolerance values (`HCLOSE`), a file path, or a boolean switch (`PRINT_FLOWS`).
*   **`MFScalarTransient`**: Handles a single scalar value that can vary by stress period. This is used for model-wide inputs that are constant in space but transient in time. An example would be a total specified withdrawal rate from a lake that changes monthly.

In essence, this module acts as a specialized data container. When a user sets a property on a FloPy package object (e.g., `ims.rclose = 0.1`), FloPy internally uses an `MFScalar` or `MFScalarTransient` object to store that value, validate it, and write it to the correct block in the corresponding MODFLOW 6 input file. It is a critical building block that allows FloPy to dynamically handle the many optional keywords and simple parameters found in MODFLOW 6 packages. **Scenario 1: Adjusting Solver Settings** **Scenario 2: Enabling or Disabling Package Options** **Scenario 3: Specifying a Time-Varying Lake Parameter** **`MFDataArray`**: This is the most direct and important related concept. While `MFScalar` handles single values, `MFDataArray` is FloPy's internal class for handling 2D or 3D grid-based data, such as hydraulic conductivity, recharge rates, or initial heads. Both are core components of FloPy's MF6 data model. **`MFDataList`**: This class handles list-based or tabular data, where each row represents a feature or a record. It is used for packages like the Well (WEL), River (RIV), or Drain (DRN) packages, where the user provides a list of wells or boundary conditions for each stress period. **FloPy's MF6 Structured Data Framework**: `MFScalar` is a product of FloPy’s modern design for MODFLOW 6. Instead of hard-coding every possible input variable, FloPy reads the MODFLOW 6 definition files (`.dfn`). Based on the definitions, it dynamically creates `MFScalar`, `MFDataArray`, or `MFDataList` objects to manage the data. This makes FloPy robust and easily adaptable to new features and versions of MODFLOW 6 without requiring major code changes.","The `mfdatascalar.py` module is a fundamental, internal component of FloPy's data handling framework for MODFLOW 6. It is **not** a user-facing package module like the Discretization (DIS) or Node Property Flow (NPF) packages. Its specific purpose is to represent, manage, and write **scalar** (single-value) data variables within a MODFLOW 6 simulation.

This module provides two key classes:
*   **`MFScalar`**: Handles a single, static value that does not change over time. This is used for global settings, flags, or parameters that are constant throughout a simulation. Examples include solver tolerance values (`HCLOSE`), a file path, or a boolean switch (`PRINT_FLOWS`).
*   **`MFScalarTransient`**: Handles a single scalar value that can vary by stress period. This is used for model-wide inputs that are constant in space but transient in time. An example would be a total specified withdrawal rate from a lake that changes monthly.

In essence, this module acts as a specialized data container. When a user sets a property on a FloPy package object (e.g., `ims.rclose = 0.1`), FloPy internally uses an `MFScalar` or `MFScalarTransient` object to store that value, validate it, and write it to the correct block in the corresponding MODFLOW 6 input file. It is a critical building block that allows FloPy to dynamically handle the many optional keywords and simple parameters found in MODFLOW 6 packages."
mfbase.py,BASE,"BASE mf6 Exception occurs when parsing a transient block header The `mfbase.py` module is the foundational framework for the entire MODFLOW 6 (`mf6`) family of packages within FloPy. It is **not** a user-facing modeling package that simulates a specific physical process. Instead, it provides the core building blocks, base classes, and custom exception types that all other `mf6` package classes (like `DIS`, `NPF`, `WEL`, etc.) inherit from.

Its primary purposes are to:

1.  **Enforce a Consistent API:** It defines a common structure and set of methods that every `mf6` package object must have. This ensures that creating a Discretization package (`ModflowGwfdis`) feels programmatically similar to creating a Well package (`ModflowGwfwel`). This consistency simplifies development for both FloPy maintainers and users.
2.  **Provide Core Functionality:** The base classes in this module handle fundamental operations like loading data from existing MODFLOW 6 files, writing package files to disk, managing data paths, and linking to the parent model and simulation. This prevents code duplication across the 40+ other `mf6` package files.
3.  **Define Specific Error Types:** It establishes a set of custom exceptions (`MFDataException`, `MFInvalidTransientBlockHeaderException`, etc.). These are more informative than generic Python errors. When a user provides malformed data, receiving a `MFDataException` is much clearer than a generic `ValueError`, immediately pointing the user to a problem with their input data arrays or lists.

In short, `mfbase.py` is the architectural blueprint for the `flopy.mf6` sub-package. It is to other `mf6` packages what a building's foundation and steel frame are to the individual rooms and offices. It provides the essential structure but is not a functional space on its own. **Scenario 1: Creating a New MODFLOW 6 Model** **Scenario 2: Debugging a Model with Incorrect Data** **Scenario 3: Loading and Modifying an Existing MODFLOW 6 Model** **Package Inheritance:** This is the core software engineering principle at play. Every specific `mf6` package class (e.g., `flopy.mf6.ModflowGwfnpf`, `flopy.mf6.ModflowGwfsto`, `flopy.mf6.ModflowGwfrch`) is a ""child"" that inherits its core structure and behavior from a ""parent"" base class in `mfbase.py`. This is fundamental to FloPy's object-oriented design. **Data Encapsulation (`MFData` Objects):** The base classes work in concert with FloPy's `MFData` objects (`MFArrayData`, `MFListData`, `MFGridData`). The base package classes provide the container and context, while the `MFData` objects handle the specifics of storing, validating, and writing different kinds of MODFLOW data (a 2D array for hydraulic conductivity, a list for well data, etc.). The exceptions in `mfbase.py` are often raised by these `MFData` objects when they encounter bad data. **Simulation/Model/Package Hierarchy:** FloPy organizes MODFLOW 6 models into a strict hierarchy: the `MFSimulation` object is the root, containing one or more Model objects (e.g., `ModflowGwf`), which in turn contain multiple Package objects (e.g., `ModflowGwfdis`). The `mfbase.py` module defines what it means to *be* a ""Package"" within this hierarchy, ensuring it can be correctly added to a Model and found by the Simulation.","The `mfbase.py` module is the foundational framework for the entire MODFLOW 6 (`mf6`) family of packages within FloPy. It is **not** a user-facing modeling package that simulates a specific physical process. Instead, it provides the core building blocks, base classes, and custom exception types that all other `mf6` package classes (like `DIS`, `NPF`, `WEL`, etc.) inherit from.

Its primary purposes are to:

1.  **Enforce a Consistent API:** It defines a common structure and set of methods that every `mf6` package object must have. This ensures that creating a Discretization package (`ModflowGwfdis`) feels programmatically similar to creating a Well package (`ModflowGwfwel`). This consistency simplifies development for both FloPy maintainers and users.
2.  **Provide Core Functionality:** The base classes in this module handle fundamental operations like loading data from existing MODFLOW 6 files, writing package files to disk, managing data paths, and linking to the parent model and simulation. This prevents code duplication across the 40+ other `mf6` package files.
3.  **Define Specific Error Types:** It establishes a set of custom exceptions (`MFDataException`, `MFInvalidTransientBlockHeaderException`, etc.). These are more informative than generic Python errors. When a user provides malformed data, receiving a `MFDataException` is much clearer than a generic `ValueError`, immediately pointing the user to a problem with their input data arrays or lists.

In short, `mfbase.py` is the architectural blueprint for the `flopy.mf6` sub-package. It is to other `mf6` packages what a building's foundation and steel frame are to the individual rooms and offices. It provides the essential structure but is not a functional space on its own."
mfmodel.py,,"mf6 MODFLOW-6 model base class.  Represents a single model in a simulation.

Parameters
----------
simulation_data : MFSimulationData
    Simulation data object of the simulation this model will belong to
structure : MFModelStructure
    Structure of this type of model
modelname : str
    Name of the model
model_nam_file : str
    Relative path to the model name file from model working folder
version : str
    Version of modflow
exe_name : str
    Model executable name
model_ws : str
    Model worki The `flopy/mf6/mfmodel.py` module defines the `MFModel` class, which is a fundamental organizational component in the FloPy framework for MODFLOW 6. This module does **not** represent a specific physics package (like Unsaturated Zone Flow, UZF) or a numerical solver (like the Matrix Solver, SMS).

Instead, its primary purpose is to act as a **container for a single, self-contained MODFLOW 6 model**. A MODFLOW 6 simulation can be composed of one or more models that might be coupled together. The `MFModel` class is the Python object that represents one of these models.

Key responsibilities of the `MFModel` class include:
*   **Encapsulation:** It groups together all the related packages that define a specific type of model. For example, a Groundwater Flow (GWF) model object will hold the Discretization (DIS), Node Property Flow (NPF), Initial Conditions (IC), and various boundary condition packages (CHD, WEL, RCH, etc.).
*   **Identity:** It gives the model a unique name (`modelname`) and type (`model_type`, e.g., 'gwf', 'gwt') within the larger simulation, which is essential for model coupling and file organization.
*   **User-Friendly Interface:** Through Python's special `__getattr__` and `__setattr__` methods, it provides an intuitive ""dot notation"" syntax for users to add, access, and remove packages. For instance, typing `gwf.dis = flopy.mf6.ModflowGwfdis(...)` dynamically creates and attaches a DIS package to the GWF model object named `gwf`.
*   **Hierarchy:** It exists as a child of the top-level `MFSimulation` object and as a parent to individual `MFPackage` objects, enforcing the structured nature of a MODFLOW 6 simulation (`Simulation` -> `Model` -> `Package`).

In short, `MFModel` is the central hub for building one component of a larger simulation, like the groundwater flow part or the solute transport part. **Scenario 1: Building a Standard Regional Groundwater Flow Model** **Scenario 2: Simulating a Contaminant Plume** **Scenario 3: Modeling Seawater Intrusion with Variable Density** **`MFSimulation`:** The top-level container object in FloPy for a MODFLOW 6 simulation. It is the parent of one or more `MFModel` objects. You cannot have an `MFModel` without an `MFSimulation`. The simulation object also holds simulation-level components like the solver (`IMS` or `EMS`) and time discretization (`TDIS`). **`MFPackage`:** The base class for all individual MODFLOW 6 input packages (e.g., `ModflowGwfdis`, `ModflowGwfchd`, `ModflowGwtmst`). An `MFModel` object is essentially a container for a list of these `MFPackage` objects. The `MFModel` is the bridge between the overall simulation and the specific details defined in the packages. **Exchanges (`Exchanges`)**: These are special MODFLOW 6 packages that define the link and data transfer *between* two different models. For example, `ModflowGwfgwt` defines the flow-transport exchange, passing flow rates from the GWF model to the GWT model. Exchanges are defined at the simulation level but explicitly reference the `modelname` of the `MFModel` objects they connect, highlighting the importance of the model's identity.","The `flopy/mf6/mfmodel.py` module defines the `MFModel` class, which is a fundamental organizational component in the FloPy framework for MODFLOW 6. This module does **not** represent a specific physics package (like Unsaturated Zone Flow, UZF) or a numerical solver (like the Matrix Solver, SMS).

Instead, its primary purpose is to act as a **container for a single, self-contained MODFLOW 6 model**. A MODFLOW 6 simulation can be composed of one or more models that might be coupled together. The `MFModel` class is the Python object that represents one of these models.

Key responsibilities of the `MFModel` class include:
*   **Encapsulation:** It groups together all the related packages that define a specific type of model. For example, a Groundwater Flow (GWF) model object will hold the Discretization (DIS), Node Property Flow (NPF), Initial Conditions (IC), and various boundary condition packages (CHD, WEL, RCH, etc.).
*   **Identity:** It gives the model a unique name (`modelname`) and type (`model_type`, e.g., 'gwf', 'gwt') within the larger simulation, which is essential for model coupling and file organization.
*   **User-Friendly Interface:** Through Python's special `__getattr__` and `__setattr__` methods, it provides an intuitive ""dot notation"" syntax for users to add, access, and remove packages. For instance, typing `gwf.dis = flopy.mf6.ModflowGwfdis(...)` dynamically creates and attaches a DIS package to the GWF model object named `gwf`.
*   **Hierarchy:** It exists as a child of the top-level `MFSimulation` object and as a parent to individual `MFPackage` objects, enforcing the structured nature of a MODFLOW 6 simulation (`Simulation` -> `Model` -> `Package`).

In short, `MFModel` is the central hub for building one component of a larger simulation, like the groundwater flow part or the solute transport part."
mfpackage.py,,"mf6 Represents the header of a block in a MF6 input file.  This class is used
internally by FloPy and its direct use by a user of this library is not
recommend.

Parameters
----------
name : str
    Block name
variable_strings : list
    List of strings that appear after the block name
comment : MFComment
    Comment text in the block header

Attributes
----------
name : str
    Block name
variable_strings : list
    List of strings that appear after the block name
comment : MFComment
    Comment te This module is not a user-facing groundwater modeling package (like a well package or a solver). Instead, it serves as a **foundational, abstract base module** that defines the core structure and behavior for *all other MODFLOW 6 packages* within FloPy. It is an internal framework component that hydrologists use indirectly every time they create or interact with any MF6 package object.

The primary purposes of `mfpackage.py` are:

1.  **To Define the `MFPackage` Class:** This is the parent class from which specific packages like `ModflowGwfdis` (Discretization), `ModflowGwfwel` (Well), or `ModflowGwfnpf` (Node Property Flow) inherit. It provides common functionality for initialization, file I/O (loading and writing), and registration within a simulation.
2.  **To Model the MODFLOW 6 File Structure:** MODFLOW 6 input files are organized into keyword-driven ""blocks"" (e.g., `BEGIN OPTIONS`, `BEGIN GRIDDATA`). This module defines the `MFBlock` and `MFBlockHeader` classes to programmatically represent, parse, and write these blocks. This ensures that all FloPy-generated MF6 files are syntactically correct.
3.  **To Standardize Data Handling:** It provides the underlying mechanics for managing different types of package data, whether it's a single value in an `OPTIONS` block, a 2D or 3D array in a `GRIDDATA` block, or time-varying list-based data in a `PERIOD` block.
4.  **To Manage Package Hierarchy:** It defines the `MFChildPackages` class to handle collections of packages, which is essential for features like the Observation utility (`OBS`), which can have multiple child packages for different observation types.

In essence, `mfpackage.py` is the blueprint or scaffolding that ensures all MF6 components in FloPy work consistently and correctly. **Scenario 1: Building a New Groundwater Flow Model** **Scenario 2: Loading and Modifying an Existing Model** **Scenario 3: Defining Spatially-Variable Aquifer Properties** **Object-Oriented Inheritance:** The core design pattern at play. `mfpackage.py` provides the ""abstract"" `MFPackage` class, and specific, concrete packages like `ModflowGwfsto` (Storage) or `ModflowGwfrch` (Recharge) inherit from it. This allows for code reuse and a consistent interface across dozens of different packages. **MODFLOW 6 Block-Structured Input:** This module is a direct programmatic representation of the MF6 input format. Concepts like `OPTIONS`, `GRIDDATA`, `PERIOD`, and `LIST` vs. `ARRAY` input are encoded in the `MFBlock` class and its helpers. Understanding this module is key to understanding how FloPy translates Python objects into the text files that the MODFLOW 6 executable consumes. **Simulation/Model/Package Hierarchy:** An `MFPackage` object cannot exist in isolation. Its constructor (`__init__`) requires a parent `model` object (e.g., `ModflowGwf`). The model, in turn, belongs to a parent `MFSimulation` object. This strict hierarchy, enforced by the `MFPackage` base class, is fundamental to how FloPy organizes and validates a complete model.","This module is not a user-facing groundwater modeling package (like a well package or a solver). Instead, it serves as a **foundational, abstract base module** that defines the core structure and behavior for *all other MODFLOW 6 packages* within FloPy. It is an internal framework component that hydrologists use indirectly every time they create or interact with any MF6 package object.

The primary purposes of `mfpackage.py` are:

1.  **To Define the `MFPackage` Class:** This is the parent class from which specific packages like `ModflowGwfdis` (Discretization), `ModflowGwfwel` (Well), or `ModflowGwfnpf` (Node Property Flow) inherit. It provides common functionality for initialization, file I/O (loading and writing), and registration within a simulation.
2.  **To Model the MODFLOW 6 File Structure:** MODFLOW 6 input files are organized into keyword-driven ""blocks"" (e.g., `BEGIN OPTIONS`, `BEGIN GRIDDATA`). This module defines the `MFBlock` and `MFBlockHeader` classes to programmatically represent, parse, and write these blocks. This ensures that all FloPy-generated MF6 files are syntactically correct.
3.  **To Standardize Data Handling:** It provides the underlying mechanics for managing different types of package data, whether it's a single value in an `OPTIONS` block, a 2D or 3D array in a `GRIDDATA` block, or time-varying list-based data in a `PERIOD` block.
4.  **To Manage Package Hierarchy:** It defines the `MFChildPackages` class to handle collections of packages, which is essential for features like the Observation utility (`OBS`), which can have multiple child packages for different observation types.

In essence, `mfpackage.py` is the blueprint or scaffolding that ensures all MF6 components in FloPy work consistently and correctly."
mfsimbase.py,,"mf6 Class containing custom dictionary for MODFLOW simulations.  Dictionary
contains model data.  Dictionary keys are ""paths"" to the data that include
the model and package containing the data.

Behaves as an dict with some additional features described below.

Parameters
----------
path : MFFileMgmt
    Object containing path information for the simulation The `mfsimbase.py` module serves as the foundational framework for constructing and managing a **MODFLOW 6 simulation**. It is not a package that represents a physical process (like `RCH` for recharge) nor is it a numerical solver (like `IMS`). Instead, it provides the top-level container, `MFSimulationBase`, which organizes all the components of a MODFLOW 6 run.

In MODFLOW 6, the ""Simulation"" is the highest-level organizing concept. A single simulation can contain:
1.  One or more **models** (e.g., a Groundwater Flow model `GWF`, a Groundwater Transport model `GWT`).
2.  **Simulation-level packages** that govern the entire run, such as the timing information (`TDIS`) and the primary numerical solver (`IMS`).
3.  **Exchanges** that define the connections between different models (e.g., linking a `GWF` and `GWT` model).

The primary purpose of `mfsimbase.py` is to provide the core logic for:
*   **Assembling:** Creating a simulation object and registering models and packages to it.
*   **Writing:** Generating the complete set of MODFLOW 6 input files, including the main simulation name file (`mfsim.nam`).
*   **Executing:** Finding and running the MODFLOW 6 executable.
*   **Loading:** Parsing existing MODFLOW 6 simulations from their files to inspect the configuration or analyze results.

The user-facing class `flopy.mf6.MFSimulation` inherits directly from `MFSimulationBase`, meaning this module's logic underpins almost every MODFLOW 6 script written with FloPy. **Scenario 1: Building a Standard Groundwater Flow Model from Scratch** **Scenario 2: Loading an Existing Model to Analyze Results** **Scenario 3: Setting Up a Coupled Contaminant Transport Simulation** **`MFSimulation` Class:** This is the primary, user-facing class for a MODFLOW 6 simulation. It inherits all its core functionality from `MFSimulationBase`. Users almost always instantiate `flopy.mf6.MFSimulation`, not the base class directly. **`mfsim.nam` (Simulation Name File):** This is the master input file for any MODFLOW 6 simulation. The most critical task of the `MFSimulationBase.write_simulation()` method is to generate this file correctly. It contains pointers to the `TDIS` package, the `IMS` package, and all model name files (e.g., `my_gwf_model.nam`) that are part of the simulation. **MODFLOW 6 Models (`MFModel`):** A simulation holds one or more models. The `MFSimulationBase` class provides the methods (`register_model`, `get_model`, and dictionary-style access via `__getitem__`) to manage these model objects. The most common model is `GWF`, but others like `GWT` (Transport) are also managed at the simulation level.","The `mfsimbase.py` module serves as the foundational framework for constructing and managing a **MODFLOW 6 simulation**. It is not a package that represents a physical process (like `RCH` for recharge) nor is it a numerical solver (like `IMS`). Instead, it provides the top-level container, `MFSimulationBase`, which organizes all the components of a MODFLOW 6 run.

In MODFLOW 6, the ""Simulation"" is the highest-level organizing concept. A single simulation can contain:
1.  One or more **models** (e.g., a Groundwater Flow model `GWF`, a Groundwater Transport model `GWT`).
2.  **Simulation-level packages** that govern the entire run, such as the timing information (`TDIS`) and the primary numerical solver (`IMS`).
3.  **Exchanges** that define the connections between different models (e.g., linking a `GWF` and `GWT` model).

The primary purpose of `mfsimbase.py` is to provide the core logic for:
*   **Assembling:** Creating a simulation object and registering models and packages to it.
*   **Writing:** Generating the complete set of MODFLOW 6 input files, including the main simulation name file (`mfsim.nam`).
*   **Executing:** Finding and running the MODFLOW 6 executable.
*   **Loading:** Parsing existing MODFLOW 6 simulations from their files to inspect the configuration or analyze results.

The user-facing class `flopy.mf6.MFSimulation` inherits directly from `MFSimulationBase`, meaning this module's logic underpins almost every MODFLOW 6 script written with FloPy."
mfgnc.py,GNC,"GNC mf6 ModflowGnc defines a GNC package.

Parameters
----------
print_input : keyword
    keyword to indicate that the list of gnc information will be written to the
    listing file immediately after it is read.
print_flows : keyword
    keyword to indicate that the list of gnc flow rates will be printed to the
    listing file for every stress period time step in which 'budget print' is
    specified in output control.  if there is no output control option and
    'print_flows' is specified, then flo The `mfgnc.py` module implements the **Ghost-Node Correction (GNC)** package for MODFLOW 6. This is a numerical utility package, not a physical process package or a solver. Its primary purpose is to improve the accuracy of groundwater flow calculations between adjacent model cells that have a large contrast in hydraulic conductivity.

In a standard finite-difference model, the conductance between two cells is typically calculated using an arithmetic or harmonic mean of the cell properties. When the hydraulic conductivity (`K`) changes by several orders of magnitude between two cells (e.g., a sand layer next to a clay layer), the standard calculation can introduce significant errors in the computed flow rate across that interface.

The GNC package corrects this by introducing a ""ghost node"" at the interface between the two specified cells. It then uses a more physically-based conductance calculation (based on a harmonic mean that properly accounts for the series nature of the resistances) to determine the flow. This results in a more accurate simulation of head and flux at sharp hydrogeologic boundaries.

Crucially, the GNC package is not a solver like the Iterative Model Solution (`IMS`) or a boundary condition like the Well (`WEL`) package. Instead, it **modifies the flow equations** that are formulated by the Node Property Flow (`NPF`) package *before* they are passed to the solver. It is a targeted numerical refinement for specific parts of the model grid. **Scenario 1: Alluvial Valley Aquifer Modeling** **Scenario 2: Simulating Flow Across a Fault Zone** **Scenario 3: Modeling Layer Pinch-outs and Discontinuities** **Node Property Flow (NPF) Package (`flopy.mf6.ModflowGwfnpf`)** **Discretization Packages (DIS, DISV, DISU)** **Newton-Raphson Flow Formulation (`NEWTON` option in NPF)**","The `mfgnc.py` module implements the **Ghost-Node Correction (GNC)** package for MODFLOW 6. This is a numerical utility package, not a physical process package or a solver. Its primary purpose is to improve the accuracy of groundwater flow calculations between adjacent model cells that have a large contrast in hydraulic conductivity.

In a standard finite-difference model, the conductance between two cells is typically calculated using an arithmetic or harmonic mean of the cell properties. When the hydraulic conductivity (`K`) changes by several orders of magnitude between two cells (e.g., a sand layer next to a clay layer), the standard calculation can introduce significant errors in the computed flow rate across that interface.

The GNC package corrects this by introducing a ""ghost node"" at the interface between the two specified cells. It then uses a more physically-based conductance calculation (based on a harmonic mean that properly accounts for the series nature of the resistances) to determine the flow. This results in a more accurate simulation of head and flux at sharp hydrogeologic boundaries.

Crucially, the GNC package is not a solver like the Iterative Model Solution (`IMS`) or a boundary condition like the Well (`WEL`) package. Instead, it **modifies the flow equations** that are formulated by the Node Property Flow (`NPF`) package *before* they are passed to the solver. It is a targeted numerical refinement for specific parts of the model grid."
mfgwf.py,GWF,"GWF mf6 ModflowGwf defines a GWF model.

Parameters
----------
list : string
    is name of the listing file to create for this gwf model.  if not specified,
    then the name of the list file will be the basename of the gwf model name file
    and the '.lst' extension.  for example, if the gwf name file is called
    'my.model.nam' then the list file will be called 'my.model.lst'.
print_input : keyword
    keyword to indicate that the list of all model stress package information will
    be written to  The `flopy.mf6.modflow.mfgwf.py` module defines the `ModflowGwf` class, which serves as the central container for a **MODFLOW 6 Groundwater Flow (GWF) Model**. It is the primary object for constructing, loading, and managing all components related to a single groundwater flow simulation.

In the MODFLOW 6 framework, a simulation can contain one or more models (e.g., a GWF Model and a GWT Model for transport). The `ModflowGwf` class represents one of these core models. It does not perform calculations itself but acts as a high-level organizer that **holds and manages all the individual packages** that define the groundwater flow system.

Specifically, the `ModflowGwf` object orchestrates:

*   **Grid Discretization**: Holds the discretization package (DIS, DISV, or DISU) that defines the model grid's geometry.
*   **Aquifer Properties**: Contains the Node Property Flow (NPF) package, which defines hydraulic conductivity and cell connection properties.
*   **Storage**: Manages the Storage (STO) package for transient simulations, defining specific storage and specific yield.
*   **Initial Conditions**: Includes the Initial Conditions (IC) package, setting the starting head for the simulation.
*   **Boundary Conditions and Stresses**: Contains all boundary condition packages that add or remove water from the system, such as:
    *   Well (WEL)
    *   River (RIV)
    *   Drain (DRN)
    *   General-Head Boundary (GHB)
    *   Constant-Head (CHD)
    *   Recharge (RCH)
    *   Evapotranspiration (EVT)
*   **Advanced Processes**: Can hold packages for more complex processes like the Unsaturated Zone Flow (UZF), Streamflow Routing (SFR), or Lake (LAK) packages.
*   **Output Control**: Manages the Output Control (OC) package, which dictates what results (e.g., heads, budgets) are saved and when.

Crucially, `ModflowGwf` is **not a solver**. The solver (e.g., the Iterative Matrix Solver, `IMS`) is defined at the parent `MFSimulation` level and is used to solve the system of equations assembled by the GWF model and its constituent packages. The `ModflowGwf` object defines *what* needs to be solved. **Scenario 1: Building a New Regional Aquifer Model** **Scenario 2: Modifying an Existing Model for a Dewatering Analysis** **Scenario 3: Automating Model Calibration** **`flopy.mf6.MFSimulation`**: This is the parent object of `ModflowGwf`. A GWF model cannot exist in FloPy without being part of an `MFSimulation`. The simulation object manages simulation-wide information, including the time discretization (`TDIS` package), the solver (`IMS` package), and the list of all models (like one or more `ModflowGwf` models) that are run together. **MODFLOW 6 Packages (e.g., `mf6.ModflowGwfnpf`, `mf6.ModflowGwfwel`)**: These are the ""child"" objects contained within a `ModflowGwf` instance. You define the model's specific physical characteristics by creating instances of these package classes and passing the `ModflowGwf` object as their parent during instantiation. They are then accessible as attributes of the `gwf` object (e.g., `gwf.npf`, `gwf.wel`). **`flopy.mf6.modflow.ModflowGwt`**: This is a ""sibling"" model type for simulating groundwater transport. A common advanced scenario involves coupling a `ModflowGwf` model with a `ModflowGwt` model to simulate contaminant fate and transport. The `ModflowGwf` model calculates the flow field (head and cell-by-cell flows), which is then used by the `ModflowGwt` model to advect and disperse solutes. Both models would be part of the same `MFSimulation`.","The `flopy.mf6.modflow.mfgwf.py` module defines the `ModflowGwf` class, which serves as the central container for a **MODFLOW 6 Groundwater Flow (GWF) Model**. It is the primary object for constructing, loading, and managing all components related to a single groundwater flow simulation.

In the MODFLOW 6 framework, a simulation can contain one or more models (e.g., a GWF Model and a GWT Model for transport). The `ModflowGwf` class represents one of these core models. It does not perform calculations itself but acts as a high-level organizer that **holds and manages all the individual packages** that define the groundwater flow system.

Specifically, the `ModflowGwf` object orchestrates:

*   **Grid Discretization**: Holds the discretization package (DIS, DISV, or DISU) that defines the model grid's geometry.
*   **Aquifer Properties**: Contains the Node Property Flow (NPF) package, which defines hydraulic conductivity and cell connection properties.
*   **Storage**: Manages the Storage (STO) package for transient simulations, defining specific storage and specific yield.
*   **Initial Conditions**: Includes the Initial Conditions (IC) package, setting the starting head for the simulation.
*   **Boundary Conditions and Stresses**: Contains all boundary condition packages that add or remove water from the system, such as:
    *   Well (WEL)
    *   River (RIV)
    *   Drain (DRN)
    *   General-Head Boundary (GHB)
    *   Constant-Head (CHD)
    *   Recharge (RCH)
    *   Evapotranspiration (EVT)
*   **Advanced Processes**: Can hold packages for more complex processes like the Unsaturated Zone Flow (UZF), Streamflow Routing (SFR), or Lake (LAK) packages.
*   **Output Control**: Manages the Output Control (OC) package, which dictates what results (e.g., heads, budgets) are saved and when.

Crucially, `ModflowGwf` is **not a solver**. The solver (e.g., the Iterative Matrix Solver, `IMS`) is defined at the parent `MFSimulation` level and is used to solve the system of equations assembled by the GWF model and its constituent packages. The `ModflowGwf` object defines *what* needs to be solved."
mfgwfapi.py,API,"API mf6 ModflowGwfapi defines a API package.

Parameters
----------
boundnames : keyword
    keyword to indicate that boundary names may be provided with the list of api
    boundary cells.
print_input : keyword
    keyword to indicate that the list of api boundary information will be written
    to the listing file immediately after it is read.
print_flows : keyword
    keyword to indicate that the list of api boundary flow rates will be printed to
    the listing file for every stress period time step The `flopy.mf6.modflow.mfgwfapi` module and its primary class, `ModflowGwfapi`, serve a highly specialized but powerful purpose: they enable the use of the **MODFLOW 6 Application Programming Interface (API)**.

This module does **not** define a physical process (like groundwater flow) or a boundary condition (like wells). Instead, it acts as a configuration package that instructs a MODFLOW 6 Groundwater Flow (GWF) model to run in a ""server mode."" This allows an external program, typically a Python script using FloPy, to interact with the model *while it is running*.

Key functions of this module include:

*   **Enabling In-Memory Coupling:** It replaces the standard MODFLOW 6 executable (`mf6.exe`). The model runs as a shared library (`libmf6.dll` or `libmf6.so`) loaded directly into the Python process. This eliminates the need to write and read text files for each model run, dramatically speeding up complex workflows like uncertainty analysis or optimization.
*   **Controlling the Solution Process:** The parameters within the `ModflowGwfapi` class (`maxiter`, `hclose`, `rclose`, etc.) are solver settings. It essentially replaces the role of the Iterative Model Solution (`IMS`) package when a model is run through the API. It allows the user to configure how the model's matrix equations are solved during an API-controlled simulation.
*   **Facilitating Dynamic Control:** By using the API, a user can pause the simulation at any point (e.g., between time steps or even between iterations), query the model's state (e.g., get head values), modify model parameters (e.g., change pumping rates), and then command the simulation to continue. This enables dynamic, state-dependent modeling that is impossible with a standard model run.

In short, `mfgwfapi` is the gateway to treating a MODFLOW 6 model not as a static black box, but as a live, interactive numerical engine within a larger programming environment.","The `flopy.mf6.modflow.mfgwfapi` module and its primary class, `ModflowGwfapi`, serve a highly specialized but powerful purpose: they enable the use of the **MODFLOW 6 Application Programming Interface (API)**.

This module does **not** define a physical process (like groundwater flow) or a boundary condition (like wells). Instead, it acts as a configuration package that instructs a MODFLOW 6 Groundwater Flow (GWF) model to run in a ""server mode."" This allows an external program, typically a Python script using FloPy, to interact with the model *while it is running*.

Key functions of this module include:

*   **Enabling In-Memory Coupling:** It replaces the standard MODFLOW 6 executable (`mf6.exe`). The model runs as a shared library (`libmf6.dll` or `libmf6.so`) loaded directly into the Python process. This eliminates the need to write and read text files for each model run, dramatically speeding up complex workflows like uncertainty analysis or optimization.
*   **Controlling the Solution Process:** The parameters within the `ModflowGwfapi` class (`maxiter`, `hclose`, `rclose`, etc.) are solver settings. It essentially replaces the role of the Iterative Model Solution (`IMS`) package when a model is run through the API. It allows the user to configure how the model's matrix equations are solved during an API-controlled simulation.
*   **Facilitating Dynamic Control:** By using the API, a user can pause the simulation at any point (e.g., between time steps or even between iterations), query the model's state (e.g., get head values), modify model parameters (e.g., change pumping rates), and then command the simulation to continue. This enables dynamic, state-dependent modeling that is impossible with a standard model run.

In short, `mfgwfapi` is the gateway to treating a MODFLOW 6 model not as a static black box, but as a live, interactive numerical engine within a larger programming environment."
mfgwfbuy.py,BUY,"BUY mf6 ModflowGwfbuy defines a BUY package.

Parameters
----------
hhformulation_rhs : keyword
    use the variable-density hydraulic head formulation and add off-diagonal terms
    to the right-hand.  this option will prevent the buy package from adding
    asymmetric terms to the flow matrix.
denseref : double precision
    fluid reference density used in the equation of state.  this value is set to
    1000. if not specified as an option.
density_filerecord : (densityfile)
    * densityfile : string The `mfgwfbuy.py` module implements the **Buoyancy Package (BUY)** for a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate **variable-density groundwater flow**, a phenomenon where spatial variations in fluid density significantly influence the flow field.

This is not a standalone package but a critical component for coupling a GWF model with a Groundwater Transport (GWT) model. The GWT model simulates the movement of a solute (e.g., salt), and the BUY package uses the resulting concentration field to calculate fluid density at every point in the model. This calculated density is then used by the GWF model to modify the hydraulic heads and conductance terms in the flow equation, creating density-driven flow.

In essence, the BUY package is the ""engine"" that allows for the feedback loop where solute concentration affects groundwater flow. It is indispensable for modeling scenarios such as:

*   Saltwater intrusion
*   Brine migration
*   Geothermal systems (where temperature affects density)
*   Contaminant plumes with fluids denser or lighter than ambient groundwater

It is not a solver (like IMS or SMS) or a boundary condition package (like WEL or RCH). It is a physical process package that modifies the internal governing equations of groundwater flow. **Scenario 1: Coastal Aquifer Management** **Scenario 2: Assessing Contamination from a Brine Spill** **Scenario 3: Simulating Thermally-Driven Convection** **Scenario 4: Managed Aquifer Recharge (MAR) with Atypical Water** **Groundwater Transport (GWT) Model:** The BUY package is fundamentally linked to a GWT model (`flopy.mf6.ModflowGwt`). The BUY package resides within the GWF model but requires concentration data from a GWT model to function. Without a GWT model providing concentrations, the BUY package has no information to calculate density variations. **GWF-GWT Exchange (`GWFGWT`):** This is the formal mechanism in MODFLOW 6 for coupling the flow and transport models. The user must define a `flopy.mf6.ModflowGwfgwt` exchange to pass information (like fluid velocity from GWF to GWT, and concentration from GWT to GWF for the BUY package). The BUY package is essentially a consumer of information passed through this exchange. **SEAWAT:** Before MODFLOW 6, variable-density modeling was primarily done with the SEAWAT code, which was a separate program that coupled specific versions of MODFLOW and MT3DMS. The GWF-GWT-BUY structure in MODFLOW 6 is the modern, integrated successor to SEAWAT, providing a more flexible and robust framework for the same physical problem. **Equation of State:** The BUY package implements an equation of state that relates fluid density to solute concentration. Typically, this is a linear relationship: `ρ = ρ_ref + (dρ/dC) * (C - C_ref)`. The key parameters a user provides to the BUY package, such as `DENSEref` (reference density) and `DRHODC` (the slope of the density-concentration line), define this equation.","The `mfgwfbuy.py` module implements the **Buoyancy Package (BUY)** for a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate **variable-density groundwater flow**, a phenomenon where spatial variations in fluid density significantly influence the flow field.

This is not a standalone package but a critical component for coupling a GWF model with a Groundwater Transport (GWT) model. The GWT model simulates the movement of a solute (e.g., salt), and the BUY package uses the resulting concentration field to calculate fluid density at every point in the model. This calculated density is then used by the GWF model to modify the hydraulic heads and conductance terms in the flow equation, creating density-driven flow.

In essence, the BUY package is the ""engine"" that allows for the feedback loop where solute concentration affects groundwater flow. It is indispensable for modeling scenarios such as:

*   Saltwater intrusion
*   Brine migration
*   Geothermal systems (where temperature affects density)
*   Contaminant plumes with fluids denser or lighter than ambient groundwater

It is not a solver (like IMS or SMS) or a boundary condition package (like WEL or RCH). It is a physical process package that modifies the internal governing equations of groundwater flow."
mfgwfchd.py,CHD,"CHD mf6 ModflowGwfchd defines a CHD package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro The `flopy.mf6.modflow.mfgwfchd` module implements the **Constant-Head (CHD) Package** for a MODFLOW 6 Groundwater Flow (GWF) Model.

The primary purpose of this module is to simulate a **specified head boundary condition**. This type of boundary condition fixes the hydraulic head in one or more model cells to a user-defined value for a given time period (stress period). The model then calculates the volumetric flow rate (flux) required to maintain that specified head. This flux can be either into the aquifer (recharge) or out of the aquifer (discharge), making the CHD boundary an infinite source of or sink for water.

In essence, the CHD package is used to represent hydrogeologic features that have a very large volume of water and a stable water level that is not significantly affected by fluxes to or from the simulated aquifer system.

This module is a **boundary condition package**. It should not be confused with:
*   **Solver Packages** (e.g., `IMS`, `SMS`), which solve the system of linear equations.
*   **Flow Packages** (e.g., `NPF`, `STO`), which describe the physical properties of the aquifer and how water moves between cells.
*   **Flux-based Source/Sink Packages** (e.g., `WEL`, `RCH`), where the user specifies the flow rate, and the model calculates the resulting head. The CHD package does the opposite. **Scenario 1: Modeling a Coastal Aquifer** **Scenario 2: Simulating a Large River or Lake** **Scenario 3: Setting Boundary Conditions for a Local-Scale Model** **`flopy.mf6.modflow.mfgwfghb.ModflowGwfghb` (General-Head Boundary Package)** **`flopy.mf6.modflow.mfgwfdrn.ModflowGwfdrn` (Drain Package)** **`flopy.mf6.modflow.mfgwfwel.ModflowGwfWel` (Well Package)**","The `flopy.mf6.modflow.mfgwfchd` module implements the **Constant-Head (CHD) Package** for a MODFLOW 6 Groundwater Flow (GWF) Model.

The primary purpose of this module is to simulate a **specified head boundary condition**. This type of boundary condition fixes the hydraulic head in one or more model cells to a user-defined value for a given time period (stress period). The model then calculates the volumetric flow rate (flux) required to maintain that specified head. This flux can be either into the aquifer (recharge) or out of the aquifer (discharge), making the CHD boundary an infinite source of or sink for water.

In essence, the CHD package is used to represent hydrogeologic features that have a very large volume of water and a stable water level that is not significantly affected by fluxes to or from the simulated aquifer system.

This module is a **boundary condition package**. It should not be confused with:
*   **Solver Packages** (e.g., `IMS`, `SMS`), which solve the system of linear equations.
*   **Flow Packages** (e.g., `NPF`, `STO`), which describe the physical properties of the aquifer and how water moves between cells.
*   **Flux-based Source/Sink Packages** (e.g., `WEL`, `RCH`), where the user specifies the flow rate, and the model calculates the resulting head. The CHD package does the opposite."
mfgwfcsub.py,CSUB,"CSUB mf6 ModflowGwfcsub defines a CSUB package.

Parameters
----------
boundnames : keyword
    keyword to indicate that boundary names may be provided with the list of csub
    cells.
print_input : keyword
    keyword to indicate that the list of csub information will be written to the
    listing file immediately after it is read.
save_flows : keyword
    keyword to indicate that cell-by-cell flow terms will be written to the file
    specified with 'budget save file' in output control.
gammaw : double The `flopy.mf6.modflow.mfgwfcsub` module serves as the FloPy interface for the **Compaction and Subsidence (CSUB) Package** of a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the deformation of an aquifer system, specifically the compaction of fine-grained layers (clays and silts) and the resulting land subsidence at the surface.

This package does not solve for groundwater flow itself. Instead, it acts as a ""post-processing"" calculation within a MODFLOW 6 run. It uses the hydraulic head solution calculated by the GWF Model to determine the change in effective stress on the aquifer skeleton. Based on this stress change and user-defined geomechanical properties, it calculates compaction.

Key functionalities managed by this module include:

*   **Defining Compacting Layers:** Specifying which parts of the aquifer system are subject to compaction, typically the fine-grained interbeds (aquitards) that are conceptually located between the explicit model layers.
*   **Assigning Geomechanical Properties:** Inputting parameters such as:
    *   **Elastic and Inelastic Specific Storage (`sfe`, `sfv`):** These govern how much a layer compacts or expands when water levels change. Inelastic storage (compaction) is typically much larger than elastic storage (rebound) and is non-recoverable.
    *   **Preconsolidation Head:** This critical parameter represents the lowest historical groundwater level the system has experienced. Compaction is elastic for heads above this level and becomes inelastic (permanent) when heads drop below it.
*   **Calculating Compaction and Subsidence:** The package computes cell-by-cell compaction over time, which can be summed vertically to estimate total land subsidence.
*   **One-Way Coupling:** It's important to note that in the standard CSUB package, the compaction calculation is a one-way coupling. The head changes from the GWF model affect subsidence, but the changes in aquifer thickness due to compaction do not feed back to alter the groundwater flow solution in the same timestep. **Scenario 1: Quantifying Subsidence from Agricultural Pumping** **Scenario 2: Assessing Infrastructure Risk from Differential Subsidence** **Scenario 3: Evaluating the Geomechanical Effects of Aquifer Storage and Recovery (ASR)** **GWF Model (Groundwater Flow Model)**: The CSUB package is a component of and is entirely dependent on a GWF Model. It cannot function independently. The head results computed by the GWF Model's solver for each time step are the primary input driver for the CSUB calculations. **DIS Package (Discretization Package)**: The CSUB package defines properties for the ""interbeds,"" which are the aquitards conceptually located *between* the model layers defined in the DIS package. The vertical discretization (`NLAY`, `TOP`, `BOTM`) established in the DIS package provides the framework for defining where the compacting units are located. **STO Package (Storage Package)**: The STO package manages storage changes *within* the primary aquifer layers (e.g., specific yield in unconfined layers, elastic storage in confined layers). The CSUB package, in contrast, handles storage changes (compaction) in the intervening aquitards. The total water released from storage in the system is a combination of contributions from both the STO and CSUB packages. **Effective Stress Principle**: This is the core hydrogeological concept underlying the CSUB package. It states that the stress on the solid matrix of an aquifer (effective stress) is equal to the total overlying weight (geostatic stress) minus the fluid pressure (pore water pressure). When groundwater pumping reduces pore pressure, effective stress increases, causing the grains of the aquitards to rearrange and compact.","The `flopy.mf6.modflow.mfgwfcsub` module serves as the FloPy interface for the **Compaction and Subsidence (CSUB) Package** of a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the deformation of an aquifer system, specifically the compaction of fine-grained layers (clays and silts) and the resulting land subsidence at the surface.

This package does not solve for groundwater flow itself. Instead, it acts as a ""post-processing"" calculation within a MODFLOW 6 run. It uses the hydraulic head solution calculated by the GWF Model to determine the change in effective stress on the aquifer skeleton. Based on this stress change and user-defined geomechanical properties, it calculates compaction.

Key functionalities managed by this module include:

*   **Defining Compacting Layers:** Specifying which parts of the aquifer system are subject to compaction, typically the fine-grained interbeds (aquitards) that are conceptually located between the explicit model layers.
*   **Assigning Geomechanical Properties:** Inputting parameters such as:
    *   **Elastic and Inelastic Specific Storage (`sfe`, `sfv`):** These govern how much a layer compacts or expands when water levels change. Inelastic storage (compaction) is typically much larger than elastic storage (rebound) and is non-recoverable.
    *   **Preconsolidation Head:** This critical parameter represents the lowest historical groundwater level the system has experienced. Compaction is elastic for heads above this level and becomes inelastic (permanent) when heads drop below it.
*   **Calculating Compaction and Subsidence:** The package computes cell-by-cell compaction over time, which can be summed vertically to estimate total land subsidence.
*   **One-Way Coupling:** It's important to note that in the standard CSUB package, the compaction calculation is a one-way coupling. The head changes from the GWF model affect subsidence, but the changes in aquifer thickness due to compaction do not feed back to alter the groundwater flow solution in the same timestep."
mfgwfdis.py,DIS,"DIS mf6 ModflowGwfdis defines a DIS package.

Parameters
----------
length_units : string
    is the length units used for this model.  values can be 'feet', 'meters', or
    'centimeters'.  if not specified, the default is 'unknown'.
nogrb : keyword
    keyword to deactivate writing of the binary grid file.
grb_filerecord : (grb6_filename)
    * grb6_filename : string
            defines a binary grid output file. If this option is not provided, the output
            file will have the same name as th The `flopy.mf6.modflow.mfgwfdis` module serves as the Python interface for the **MODFLOW 6 Discretization (DIS) Package**. This package is a fundamental and non-optional component for any groundwater flow (GWF) model that uses a **regular, structured grid**.

Its primary purpose is to define the spatial framework—the grid—of the model. It specifies the model's dimensions, the size and shape of each cell, and the vertical layering. It essentially creates the three-dimensional ""checkerboard"" upon which all other model properties (like hydraulic conductivity) and boundary conditions (like wells or rivers) are defined.

Specifically, the DIS package handles:
*   **Grid Structure:** Defines the number of layers (`nlay`), rows (`nrow`), and columns (`ncol`).
*   **Cell Dimensions:** Specifies the width of each column (`delr`) and the height of each row (`delc`). These can be constant for a uniform grid or vary for a non-uniform grid.
*   **Layer Elevations:** Sets the elevation of the model top (`top`) and the bottom elevation of each model layer (`botm`). These are typically 2D arrays, allowing for complex, non-flat geological layers.
*   **Active Domain:** Defines which cells are active (`idomain > 0`), inactive (`idomain = 0`), or have a specified head (`idomain < 0`). Inactive cells are excluded from the simulation, which is useful for modeling irregular model boundaries on a rectangular grid.

This module is **not a solver** (like `ims` or `sms`), nor is it a boundary condition package. It is a core structural package that provides the foundational geometry for a structured-grid GWF model. **Scenario 1: Regional Aquifer Assessment** **Scenario 2: Site-Scale Contaminant Transport Modeling** **Scenario 3: Well Interference Study** **`ModflowGwfdisv` (Discretization by Vertices):** This is the direct alternative to `mfgwfdis` for unstructured grids in MODFLOW 6. While `mfgwfdis` defines a grid with rows and columns, `mfgwfdisv` defines a grid from vertices and cell polygons (e.g., Voronoi cells). `disv` is preferred for models with highly irregular boundaries, such as winding river channels or complex property lines, which are awkward to represent with a structured grid. **`ModflowGwfnpf` (Node Property Flow Package):** The DIS package defines the geometry, but the NPF package defines the hydraulic properties *of that geometry*. The NPF package is used to specify cell-by-cell values for hydraulic conductivity (K, K22, K33), storativity, and whether a layer is convertible (unconfined) or confined. The DIS and NPF packages are inseparable partners; one defines the ""containers"" (cells) and the other defines the properties ""of the containers"". **The `modelgrid` Object:** Once a FloPy model with a DIS package is created, FloPy populates a `modelgrid` object (e.g., `gwf.modelgrid`). This is not a MODFLOW package but a powerful FloPy utility that understands the grid's geometry. Users interact with `modelgrid` to perform essential tasks like: Plotting the grid (`modelgrid.plot()`). Finding the `(k, i, j)` cell index for a given `(x, y)` coordinate. Retrieving the coordinates of cell centers. Creating cross-sections.","The `flopy.mf6.modflow.mfgwfdis` module serves as the Python interface for the **MODFLOW 6 Discretization (DIS) Package**. This package is a fundamental and non-optional component for any groundwater flow (GWF) model that uses a **regular, structured grid**.

Its primary purpose is to define the spatial framework—the grid—of the model. It specifies the model's dimensions, the size and shape of each cell, and the vertical layering. It essentially creates the three-dimensional ""checkerboard"" upon which all other model properties (like hydraulic conductivity) and boundary conditions (like wells or rivers) are defined.

Specifically, the DIS package handles:
*   **Grid Structure:** Defines the number of layers (`nlay`), rows (`nrow`), and columns (`ncol`).
*   **Cell Dimensions:** Specifies the width of each column (`delr`) and the height of each row (`delc`). These can be constant for a uniform grid or vary for a non-uniform grid.
*   **Layer Elevations:** Sets the elevation of the model top (`top`) and the bottom elevation of each model layer (`botm`). These are typically 2D arrays, allowing for complex, non-flat geological layers.
*   **Active Domain:** Defines which cells are active (`idomain > 0`), inactive (`idomain = 0`), or have a specified head (`idomain < 0`). Inactive cells are excluded from the simulation, which is useful for modeling irregular model boundaries on a rectangular grid.

This module is **not a solver** (like `ims` or `sms`), nor is it a boundary condition package. It is a core structural package that provides the foundational geometry for a structured-grid GWF model."
mfgwfdisu.py,DISU,"DISU mf6 ModflowGwfdisu defines a DISU package.

Parameters
----------
length_units : string
    is the length units used for this model.  values can be 'feet', 'meters', or
    'centimeters'.  if not specified, the default is 'unknown'.
nogrb : keyword
    keyword to deactivate writing of the binary grid file.
grb_filerecord : (grb6_filename)
    * grb6_filename : string
            defines a binary grid output file. If this option is not provided, the output
            file will have the same name as  The `flopy.mf6.modflow.mfgwfdisu` module provides the Python interface for the **MODFLOW 6 Unstructured Discretization (DISU)** package. The primary purpose of this module is to define the spatial grid for a Groundwater Flow (GWF) model using a fully unstructured mesh.

Unlike traditional structured grids (defined by rows, columns, and layers), an unstructured grid is composed of arbitrarily shaped cells (polygons in 2D, polyhedra in 3D). This package is **not a solver or a boundary condition**. It is a fundamental **discretization package** that defines the geometry and connectivity of the model domain.

Specifically, the `ModflowGwfdisu` class is responsible for:
1.  **Defining the number of layers and nodes (cells)** in the model (`nlay`, `nnodes`).
2.  **Specifying the vertical geometry** of each cell by providing its top (`top`) and bottom (`botm`) elevation.
3.  **Defining the horizontal connectivity** between cells. This is the core of the unstructured approach. It requires specifying which cells are connected to each other (`iac`, `ja` arrays) and the geometric properties of those connections, such as the horizontal flow area (`hwva`) and the distance between cell centers (`cl12`).
4.  **Handling vertical connections** between layers, which are typically simpler and assumed to be directly above/below one another.

This package is the foundation upon which all other spatial data (hydraulic conductivity, storage, boundary conditions) for an unstructured GWF model is built. **Scenario 1: Modeling Complex Geologic Structures** **Scenario 2: Simulating Detailed River-Aquifer Interactions** **Scenario 3: Local-Scale Contaminant Transport Modeling** **`ModflowGwfdis` (Structured Discretization)** **External Mesh Generation Software** **`ModflowGwfnpf` (Node Property Flow Package)**","The `flopy.mf6.modflow.mfgwfdisu` module provides the Python interface for the **MODFLOW 6 Unstructured Discretization (DISU)** package. The primary purpose of this module is to define the spatial grid for a Groundwater Flow (GWF) model using a fully unstructured mesh.

Unlike traditional structured grids (defined by rows, columns, and layers), an unstructured grid is composed of arbitrarily shaped cells (polygons in 2D, polyhedra in 3D). This package is **not a solver or a boundary condition**. It is a fundamental **discretization package** that defines the geometry and connectivity of the model domain.

Specifically, the `ModflowGwfdisu` class is responsible for:
1.  **Defining the number of layers and nodes (cells)** in the model (`nlay`, `nnodes`).
2.  **Specifying the vertical geometry** of each cell by providing its top (`top`) and bottom (`botm`) elevation.
3.  **Defining the horizontal connectivity** between cells. This is the core of the unstructured approach. It requires specifying which cells are connected to each other (`iac`, `ja` arrays) and the geometric properties of those connections, such as the horizontal flow area (`hwva`) and the distance between cell centers (`cl12`).
4.  **Handling vertical connections** between layers, which are typically simpler and assumed to be directly above/below one another.

This package is the foundation upon which all other spatial data (hydraulic conductivity, storage, boundary conditions) for an unstructured GWF model is built."
mfgwfdisv.py,DISV,"DISV mf6 ModflowGwfdisv defines a DISV package.

Parameters
----------
length_units : string
    is the length units used for this model.  values can be 'feet', 'meters', or
    'centimeters'.  if not specified, the default is 'unknown'.
nogrb : keyword
    keyword to deactivate writing of the binary grid file.
grb_filerecord : (grb6_filename)
    * grb6_filename : string
            defines a binary grid output file. If this option is not provided, the output
            file will have the same name as  The `flopy.mf6.modflow.mfgwfdisv` module implements the **DISV (Discretization by Vertices)** package for a MODFLOW 6 Groundwater Flow (GWF) model. This is a fundamental package responsible for defining the spatial grid of the model.

Unlike the traditional `DIS` package which defines a structured grid of rows and columns, `DISV` defines a grid composed of irregular polygons (e.g., triangles, quadrilaterals) in the horizontal plane. This is known as an **unstructured grid**. The geometry of each 2D cell is defined by a list of vertices. This grid is then extruded vertically into one or more layers.

**Key functions of the DISV package:**

*   **Grid Geometry:** Defines the number of layers (`nlay`), the total number of cells in the 2D grid (`ncpl`), the number of vertices (`nvert`), and the XY coordinates of each vertex.
*   **Cell Connectivity:** Specifies which vertices make up each individual 2D cell (`cell2d`).
*   **Vertical Discretization:** Defines the elevation of the top of the model (`top`) and the bottom elevation of each model layer (`botm`) for every cell.

The `DISV` package is a **discretization package**, not a solver or a boundary condition. It is a **required** component for any MODFLOW 6 model that uses a vertex-based unstructured grid. It sets up the foundational geometry upon which all other packages (like Node Property Flow - `NPF`, Storage - `STO`, Well - `WEL`, etc.) are built and upon which the solver (e.g., Iterative Model Solver - `IMS`) operates. **Scenario 1: Modeling a Sinuous River System** **Scenario 2: Simulating a Coastal Aquifer with a Complex Shoreline** **Scenario 3: Contaminant Transport with Targeted Grid Refinement** **`DIS` Package (Structured Discretization):** This is the classic MODFLOW discretization package for creating regular, structured grids defined by rows, columns, layer elevations, and cell widths (`delr`, `delc`). `DISV` is the unstructured alternative for handling complex geometries. A model can have `DIS` or `DISV`, but not both. **Grid Generation Software (e.g., `Gridgen`, `Gmsh`):** Manually defining vertices and cell connectivity for a `DISV` grid is impractical for any real-world model. Users almost always rely on external mesh generation programs. The USGS provides a tool called `Gridgen` specifically for this purpose. Other open-source (like `Gmsh`) or commercial tools can also generate the required vertex and cell information, which is then passed to the `ModflowGwfdisv` constructor in FloPy. **`GNC` Package (Ghost-Node Correction):** When unstructured cells are not perfectly orthogonal, the standard finite-difference formulation used by MODFLOW can introduce numerical errors in calculating inter-cell flows. The Ghost-Node Correction (`GNC`) package is an optional package often used alongside `DISV` to improve accuracy. It computes a more accurate conductance term for flows between non-orthogonal cells, which is especially important where hydraulic conductivity contrasts are high or layers pinch out.","The `flopy.mf6.modflow.mfgwfdisv` module implements the **DISV (Discretization by Vertices)** package for a MODFLOW 6 Groundwater Flow (GWF) model. This is a fundamental package responsible for defining the spatial grid of the model.

Unlike the traditional `DIS` package which defines a structured grid of rows and columns, `DISV` defines a grid composed of irregular polygons (e.g., triangles, quadrilaterals) in the horizontal plane. This is known as an **unstructured grid**. The geometry of each 2D cell is defined by a list of vertices. This grid is then extruded vertically into one or more layers.

**Key functions of the DISV package:**

*   **Grid Geometry:** Defines the number of layers (`nlay`), the total number of cells in the 2D grid (`ncpl`), the number of vertices (`nvert`), and the XY coordinates of each vertex.
*   **Cell Connectivity:** Specifies which vertices make up each individual 2D cell (`cell2d`).
*   **Vertical Discretization:** Defines the elevation of the top of the model (`top`) and the bottom elevation of each model layer (`botm`) for every cell.

The `DISV` package is a **discretization package**, not a solver or a boundary condition. It is a **required** component for any MODFLOW 6 model that uses a vertex-based unstructured grid. It sets up the foundational geometry upon which all other packages (like Node Property Flow - `NPF`, Storage - `STO`, Well - `WEL`, etc.) are built and upon which the solver (e.g., Iterative Model Solver - `IMS`) operates."
mfgwfdrn.py,DRN,"DRN mf6 ModflowGwfdrn defines a DRN package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro The `flopy/mf6/modflow/mfgwfdrn.py` module implements the **MODFLOW 6 Drain (DRN) Package**. Its primary purpose is to simulate a head-dependent flux boundary condition where water can only be removed from a groundwater model.

This package is fundamental for representing features that drain water out of an aquifer when the simulated groundwater head rises above a specific elevation. The rate of flow out of the model is linearly proportional to the difference between the head in the model cell and the fixed elevation of the drain.

The governing equation for a single drain is:

*   `Q = C * (h - d_elev)`   for   `h > d_elev`
*   `Q = 0`   for   `h <= d_elev`

Where:
*   `Q` is the flow rate out of the model (discharge).
*   `C` is the **conductance** of the drain, a parameter that represents how easily water can flow from the aquifer into the drain.
*   `h` is the simulated head in the model cell.
*   `d_elev` is the fixed elevation of the drain.

The DRN package is a boundary condition package. It does not solve the groundwater flow equations itself (that is the job of a numerical solver like the a **Matrix Solver (SMS)**). Instead, it contributes terms to the flow matrix that the solver then uses to compute head values for each time step. **Scenario 1: Agricultural Tile Drains** **Scenario 2: Simulating Springs and Seeps** **Scenario 3: Simplified River/Aquifer Interaction (Gaining Stream)** **Scenario 4: Foundation Drains or Excavation Dewatering** **River (RIV) Package:** The RIV package is the most closely related concept. The key difference is that RIV allows for **two-way flow**. Water can flow from the aquifer to the river (if head > river stage) and from the river to the aquifer (if head < river stage). DRN only allows for the first case (one-way flow out). RIV is more appropriate for streams that can switch between gaining and losing conditions. **General-Head Boundary (GHB) Package:** The GHB package also simulates head-dependent flux and allows for two-way flow. It is conceptually different from DRN and RIV. A GHB represents a connection to a distant, constant-head source (e.g., a large lake, a regional aquifer). The conductance term represents the bulk hydraulic properties of the aquifer material *between* the model cell and that distant source. In contrast, DRN conductance represents the local resistance at the drain-aquifer interface. **Evapotranspiration (EVT) Package:** The EVT package also removes water from the model in a head-dependent manner. However, it operates differently. EVT removes water from the uppermost active cells at a maximum rate until the head drops to an ""extinction depth,"" below which the ET ceases. It simulates a surface process driven by atmospheric demand, whereas DRN simulates a physical feature with a fixed elevation.","The `flopy/mf6/modflow/mfgwfdrn.py` module implements the **MODFLOW 6 Drain (DRN) Package**. Its primary purpose is to simulate a head-dependent flux boundary condition where water can only be removed from a groundwater model.

This package is fundamental for representing features that drain water out of an aquifer when the simulated groundwater head rises above a specific elevation. The rate of flow out of the model is linearly proportional to the difference between the head in the model cell and the fixed elevation of the drain.

The governing equation for a single drain is:

*   `Q = C * (h - d_elev)`   for   `h > d_elev`
*   `Q = 0`   for   `h <= d_elev`

Where:
*   `Q` is the flow rate out of the model (discharge).
*   `C` is the **conductance** of the drain, a parameter that represents how easily water can flow from the aquifer into the drain.
*   `h` is the simulated head in the model cell.
*   `d_elev` is the fixed elevation of the drain.

The DRN package is a boundary condition package. It does not solve the groundwater flow equations itself (that is the job of a numerical solver like the a **Matrix Solver (SMS)**). Instead, it contributes terms to the flow matrix that the solver then uses to compute head values for each time step."
mfgwfevt.py,EVT,"EVT mf6 ModflowGwfevt defines a EVT package.

Parameters
----------
fixed_cell : keyword
    indicates that evapotranspiration will not be reassigned to a cell underlying
    the cell specified in the list if the specified cell is inactive.
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of dat The `flopy.mf6.modflow.mfgwfevt` module provides the FloPy interface for the **Evapotranspiration (EVT) Package** of a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the removal of groundwater from the saturated zone due to plant uptake and soil evaporation.

EVT is a **head-dependent flux boundary condition**, meaning the rate of water removal is not fixed but varies based on the calculated groundwater head (the water table elevation). The process is defined by three key parameters for each model cell:

1.  **SURFACE:** The land surface elevation. When the water table is at or above this elevation, ET occurs at the maximum potential rate.
2.  **RATE:** The maximum potential ET rate (units of L/T).
3.  **DEPTH:** The ""extinction depth."" As the water table drops below the SURFACE, the ET rate decreases linearly. At a depth equal to or greater than the extinction depth below the surface, the ET rate becomes zero.

In essence, this package simulates a ""sink"" that removes water from the uppermost active model cell in a column, representing a critical component of the water budget in many natural and agricultural systems. It is a simpler alternative to the Unsaturated Zone Flow (UZF) package, used when detailed simulation of the vadose zone is not necessary or data is limited. **Scenario 1: Assessing Water Use in an Agricultural Basin** **Scenario 2: Modeling a Wetland or Riparian Ecosystem** **Scenario 3: Developing a Regional Water Budget** **Unsaturated Zone Flow (UZF) Package:** UZF is the more complex and physically comprehensive alternative to EVT. While EVT removes water directly from the saturated zone, UZF simulates water movement through the unsaturated zone, including infiltration, storage, and ET from soil moisture. The choice between EVT and UZF is a major modeling decision: use EVT for simplicity when the water table is shallow and the focus is on the saturated system; use UZF when unsaturated zone processes are critical to the study objectives. **Recharge (RCH) Package:** RCH and EVT are often conceptual opposites in a water budget. The RCH package adds water to the model (an inflow or *source*), representing infiltration from precipitation. The EVT package removes water (an outflow or *sink*). In many models, net recharge is calculated externally as `Precipitation - ET`, but using separate RCH and EVT packages allows the model to dynamically calculate the ET outflow based on the simulated water table depth, providing a more robust simulation. **Head-Dependent Flux Boundaries (e.g., DRN, RIV, GHB):** The EVT package belongs to this category of boundaries where the flux into or out of a cell depends on the simulated head. It is important to distinguish it from others: **Drain (DRN) Package:** Removes water only when the head is *above* a specified drain elevation. **River (RIV) Package:** Can add or remove water depending on whether the head is below or above the river stage. **EVT Package:** Removes water only when the head is *below* the land surface and above the extinction elevation.","The `flopy.mf6.modflow.mfgwfevt` module provides the FloPy interface for the **Evapotranspiration (EVT) Package** of a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the removal of groundwater from the saturated zone due to plant uptake and soil evaporation.

EVT is a **head-dependent flux boundary condition**, meaning the rate of water removal is not fixed but varies based on the calculated groundwater head (the water table elevation). The process is defined by three key parameters for each model cell:

1.  **SURFACE:** The land surface elevation. When the water table is at or above this elevation, ET occurs at the maximum potential rate.
2.  **RATE:** The maximum potential ET rate (units of L/T).
3.  **DEPTH:** The ""extinction depth."" As the water table drops below the SURFACE, the ET rate decreases linearly. At a depth equal to or greater than the extinction depth below the surface, the ET rate becomes zero.

In essence, this package simulates a ""sink"" that removes water from the uppermost active model cell in a column, representing a critical component of the water budget in many natural and agricultural systems. It is a simpler alternative to the Unsaturated Zone Flow (UZF) package, used when detailed simulation of the vadose zone is not necessary or data is limited."
mfgwfevta.py,EVTA,"EVTA mf6 ModflowGwfevta defines a EVTA package.

Parameters
----------
readasarrays : keyword
    indicates that array-based input will be used for the evapotranspiration
    package.  this keyword must be specified to use array-based input.  when
    readasarrays is specified, values must be provided for every cell within a
    model layer, even those cells that have an idomain value less than one.  values
    assigned to cells with idomain values less than one are not used and have no
    effect on sim The `flopy.mf6.modflow.mfgwfevta` module implements the **Evapotranspiration (EVT) Package** for a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the removal of water from the saturated groundwater system due to the combined effects of direct evaporation from the water table and transpiration by plants (phreatophytes) whose roots extend to the capillary fringe or the water table itself.

The EVT package is a ""head-dependent flux"" boundary condition, meaning the rate of water removal is a function of the calculated groundwater head. Specifically, it works as follows:

-   Water is removed at a maximum, user-specified rate (the potential evapotranspiration rate) when the water table is at or above a specified surface elevation (typically the land surface).
-   When the water table drops below this surface, the ET rate decreases linearly.
-   The ET rate becomes zero when the water table reaches or drops below a specified ""extinction depth"" beneath the surface.
-   The package applies this process to the highest active cell in each vertical column of the model grid.

In essence, `mfgwfevta.py` provides the Python interface for constructing, reading, and writing the input file for the EVT package within a FloPy-based MODFLOW 6 modeling workflow. It is a simpler alternative to the Unsaturated Zone Flow (UZF) package for simulating vegetative water loss, focusing solely on uptake from the saturated zone. **Scenario 1: Modeling Agricultural Water Consumption in a Shallow Alluvial Aquifer** **Scenario 2: Assessing the Health of a Riparian Ecosystem** **Scenario 3: Designing a Vegetative Cap for a Landfill** **Scenario 4: Estimating Natural Groundwater Discharge in a Wetland** **`flopy.mf6.ModflowGwfuzf` (Unsaturated Zone Flow - UZF Package):** The UZF package is the more complex and physically comprehensive alternative to EVT. UZF simulates ET by removing water from both the unsaturated and saturated zones. A modeler chooses EVT over UZF when the water table is known to be very shallow, when data to parameterize the unsaturated zone is unavailable, or for simpler screening-level models. In contrast, UZF is necessary when the water table is deep and ET primarily occurs from soil moisture in the unsaturated zone. **`flopy.mf6.ModflowGwfrch` (Recharge - RCH Package):** Recharge and Evapotranspiration are the two primary vertical fluxes at the top of a groundwater model. They are conceptual opposites: RCH adds water (an aquifer source) and EVT removes it (an aquifer sink). They are often defined together to represent the net infiltration and are fundamental to the model's water balance. **`flopy.mf6.ModflowGwfdis` (Discretization Package):** The `surface` array required by the EVT package is fundamentally linked to the model grid defined in the Discretization (DIS) package. The `top` array of the model grid (from DIS) is commonly used as the input for the EVT `surface`. The modeler must ensure that the EVT `surface` is defined for the same grid dimensions as the model. **`flopy.mf6.ModflowTdis` (Time Discretization Package):** For transient simulations where ET rates change over time (e.g., seasonally), the `perioddata` dictionary in the EVT package is used. The keys in this dictionary correspond to the stress periods defined in the TDIS package, linking the timing of ET changes to the overall model time structure.","The `flopy.mf6.modflow.mfgwfevta` module implements the **Evapotranspiration (EVT) Package** for a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the removal of water from the saturated groundwater system due to the combined effects of direct evaporation from the water table and transpiration by plants (phreatophytes) whose roots extend to the capillary fringe or the water table itself.

The EVT package is a ""head-dependent flux"" boundary condition, meaning the rate of water removal is a function of the calculated groundwater head. Specifically, it works as follows:

-   Water is removed at a maximum, user-specified rate (the potential evapotranspiration rate) when the water table is at or above a specified surface elevation (typically the land surface).
-   When the water table drops below this surface, the ET rate decreases linearly.
-   The ET rate becomes zero when the water table reaches or drops below a specified ""extinction depth"" beneath the surface.
-   The package applies this process to the highest active cell in each vertical column of the model grid.

In essence, `mfgwfevta.py` provides the Python interface for constructing, reading, and writing the input file for the EVT package within a FloPy-based MODFLOW 6 modeling workflow. It is a simpler alternative to the Unsaturated Zone Flow (UZF) package for simulating vegetative water loss, focusing solely on uptake from the saturated zone."
mfgwfghb.py,GHB,"GHB mf6 ModflowGwfghb defines a GHB package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro The `flopy.mf6.modflow.mfgwfghb.py` module provides the Python interface for the **General-Head Boundary (GHB)** package in a **MODFLOW 6 Groundwater Flow (GWF)** model.

The primary purpose of the GHB package is to simulate a **head-dependent flux boundary**. This means that flow into or out of a model cell is directly proportional to the difference between a specified external head (the ""boundary head"") and the calculated head within the model cell. The governing equation for a single GHB cell is:

**Q = C * (H_b - H_m)**

Where:
*   **Q** is the volumetric flow rate into the aquifer (L³/T).
*   **C** is the hydraulic **conductance** of the boundary (L²/T).
*   **H_b** is the head at the external boundary (L).
*   **H_m** is the calculated head in the model cell (L).

This package is a boundary condition package, not a solver (like IMS or SMS) or an internal flow package (like UZF or SFR). It is used to represent features at the model's edge or within the domain that act as sources or sinks of water whose strength depends on the aquifer's head. Common examples include distant lakes, rivers, or the connection to a larger regional aquifer. **Scenario 1: Simulating Interaction with a Distant Water Body** **Scenario 2: Representing a Regional Aquifer System** **Scenario 3: Simplified River-Aquifer Interaction** **Constant-Head Boundary (CHD) Package:** The CHD package is the closest relative. It forces a model cell to a fixed head value, effectively representing a boundary with infinite conductance. A GHB is a ""softer"" version of a CHD. A GHB with a very high conductance value will behave almost identically to a CHD. The choice depends on whether there is significant resistance between the model cell and the external water source. **River (RIV) Package:** The RIV package is also very similar to GHB but includes one critical addition: the elevation of the riverbed bottom. In the RIV package, if the aquifer head drops below the riverbed bottom, the boundary ""dries up,"" and the connection is severed (or the leakage rate becomes constant). The GHB package does not have this feature; it will continue to simulate flow even if the model head drops to an unphysically low level. Therefore, RIV is preferred for shallow rivers that might disconnect from the aquifer. **Drain (DRN) Package:** The DRN package functions like a one-way GHB. It only allows water to flow *out* of the aquifer. If the aquifer head drops below the specified drain elevation, flow ceases. This is used to simulate agricultural drains, springs, or seepage faces where water cannot flow back into the system.","The `flopy.mf6.modflow.mfgwfghb.py` module provides the Python interface for the **General-Head Boundary (GHB)** package in a **MODFLOW 6 Groundwater Flow (GWF)** model.

The primary purpose of the GHB package is to simulate a **head-dependent flux boundary**. This means that flow into or out of a model cell is directly proportional to the difference between a specified external head (the ""boundary head"") and the calculated head within the model cell. The governing equation for a single GHB cell is:

**Q = C * (H_b - H_m)**

Where:
*   **Q** is the volumetric flow rate into the aquifer (L³/T).
*   **C** is the hydraulic **conductance** of the boundary (L²/T).
*   **H_b** is the head at the external boundary (L).
*   **H_m** is the calculated head in the model cell (L).

This package is a boundary condition package, not a solver (like IMS or SMS) or an internal flow package (like UZF or SFR). It is used to represent features at the model's edge or within the domain that act as sources or sinks of water whose strength depends on the aquifer's head. Common examples include distant lakes, rivers, or the connection to a larger regional aquifer."
mfgwfgnc.py,GNC,"GNC mf6 ModflowGwfgnc defines a GNC package.

Parameters
----------
print_input : keyword
    keyword to indicate that the list of gnc information will be written to the
    listing file immediately after it is read.
print_flows : keyword
    keyword to indicate that the list of gnc flow rates will be printed to the
    listing file for every stress period time step in which 'budget print' is
    specified in output control.  if there is no output control option and
    'print_flows' is specified, then  The `flopy.mf6.modflow.mfgwfgnc` Python module is a FloPy interface for the **Ghost Node Correction (GNC)** package in MODFLOW 6.

The primary purpose of the GNC package is to **improve the accuracy of flow calculations between two connected Groundwater Flow (GWF) models**. It is not a solver (like IMS or SMS) or a boundary condition package (like WEL or RIV). Instead, it is an advanced feature that modifies the underlying flow equations at the interface of connected models to provide a more physically accurate simulation.

Specifically, GNC corrects for discretization errors that occur when coupling a coarse-grid model with a fine-grid model, a technique commonly known as Local Grid Refinement (LGR). When water flows between the grids, MODFLOW 6's standard **GWF-GWF Exchange** calculates the flow based on a linear interpolation of head. The GNC package introduces ""ghost nodes"" on the coarse grid side of the interface. These ghost nodes allow for a higher-order, quadratic interpolation of the head surface, which results in a more accurate calculation of the hydraulic gradient and, consequently, the flow across the model interface.

In summary, the GNC package serves a single, highly specific purpose: **to increase the accuracy of a GWF-GWF Exchange**, almost exclusively in the context of Local Grid Refinement. **Scenario 1: Detailed Contaminant Plume Delineation** **Scenario 2: Assessing Wellfield Pumping Impacts** **Scenario 3: Simulating Complex Surface Water / Groundwater Interaction** **GWF-GWF Exchange (`GWFGWF`)**: This is the most critical related concept. The GNC package cannot be used on its own; it exists *only* to modify the behavior of a `GWFGWF` exchange. The GWF-GWF Exchange is the mechanism that connects two or more GWF models, defining the shared cell faces where flow can occur. The GNC package data explicitly references the `GWFGWF` exchange it is correcting. **Local Grid Refinement (LGR)**: While the GWF-GWF exchange can connect any two models, its most common application is LGR, where a fine-grid ""child"" model is nested within a coarse-grid ""parent"" model. GNC is almost exclusively used in LGR scenarios, as this is where the discretization mismatch is most significant and the correction provides the most benefit. Tools like `flopy.utils.Gridgen` are often used to create the necessary input for both the LGR connection (`GWFGWF`) and the GNC package. **Discretization by Vertices (`DISV`)**: The GNC package is fully compatible with unstructured grids defined by the DISV package. In fact, its ability to handle complex connections makes it particularly valuable for models using unstructured grids, where parent-child grid connections can be geometrically complex and standard interpolation methods are more likely to introduce errors.","The `flopy.mf6.modflow.mfgwfgnc` Python module is a FloPy interface for the **Ghost Node Correction (GNC)** package in MODFLOW 6.

The primary purpose of the GNC package is to **improve the accuracy of flow calculations between two connected Groundwater Flow (GWF) models**. It is not a solver (like IMS or SMS) or a boundary condition package (like WEL or RIV). Instead, it is an advanced feature that modifies the underlying flow equations at the interface of connected models to provide a more physically accurate simulation.

Specifically, GNC corrects for discretization errors that occur when coupling a coarse-grid model with a fine-grid model, a technique commonly known as Local Grid Refinement (LGR). When water flows between the grids, MODFLOW 6's standard **GWF-GWF Exchange** calculates the flow based on a linear interpolation of head. The GNC package introduces ""ghost nodes"" on the coarse grid side of the interface. These ghost nodes allow for a higher-order, quadratic interpolation of the head surface, which results in a more accurate calculation of the hydraulic gradient and, consequently, the flow across the model interface.

In summary, the GNC package serves a single, highly specific purpose: **to increase the accuracy of a GWF-GWF Exchange**, almost exclusively in the context of Local Grid Refinement."
mfgwfgwe.py,GWE,"GWE mf6 ModflowGwfgwe defines a GWFGWE package.

Parameters
---------- The `flopy.mf6.modflow.mfgwfgwe.py` module implements the **MODFLOW 6 Groundwater Flow (GWF) - Groundwater Energy (GWE) Exchange**. This is not a standalone package that defines a physical process (like Recharge or Wells) nor is it a numerical solver (like IMS or SMS). Instead, its sole purpose is to act as a data-passing mechanism that **couples a GWF Model with a GWE Model** running within the same simulation.

The primary functions of this exchange are:

1.  **Passing Flow Information to the GWE Model:** The GWF Model calculates the cell-by-cell groundwater flow rates. The GWFGWE exchange passes these flow rates (advective fluxes) to the GWE Model. The GWE Model then uses this flow field to solve the advection-dispersion equation for heat transport, simulating how temperature moves through the aquifer.

2.  **Enabling Density-Coupled Flow (Optional):** The GWE model calculates the temperature distribution in the aquifer. Temperature affects the density and viscosity of water. If density effects are significant, this exchange facilitates passing the temperature information back to the GWF model. When used in conjunction with the **Buoyancy (BUY) Package** in the GWF Model, these temperatures are used to calculate fluid density variations, which in turn affect the hydraulic head and groundwater flow patterns. This creates a fully coupled, two-way feedback loop where flow affects heat transport, and heat transport affects flow.

In essence, `mfgwfgwe` is the critical ""glue"" that allows a standard groundwater flow model and a heat transport model to interact and solve simultaneously. **Scenario 1: Assessing an Aquifer Thermal Energy Storage (ATES) System** **Scenario 2: Modeling Temperature-Dependent Contaminant Degradation** **Scenario 3: Investigating Surface Water-Groundwater Interaction using Heat as a Tracer** **GWE Model (`flopy.mf6.ModflowGwe`)**: The `GWFGWE` exchange is meaningless without a Groundwater Energy (GWE) model to exchange with. The GWE model is where the physics of heat transport are defined, including packages for thermal dispersion (`DSP`), heat capacity and storage (`MST`), and thermal sources/sinks (`SST`). The `ModflowGwfgwe` class directly connects a `ModflowGwf` object to a `ModflowGwe` object. **Buoyancy Package (`flopy.mf6.modflow.mfgwfbuy.py`)**: This package is the key to enabling two-way coupling. The GWE model computes temperatures, but these temperatures do not affect flow unless the GWF model's Buoyancy (`BUY`) package is activated. The `BUY` package takes the temperatures from the GWE model, calculates fluid density, and modifies the flow equations to account for density-driven flow. Without the `BUY` package, the exchange is one-way (flow influences heat, but heat does not influence flow). **MODFLOW 6 Simulation Structure (`flopy.mf6.MFSimulation`)**: The concept of exchanges is fundamental to the MODFLOW 6 architecture. Unlike older versions of MODFLOW, MF6 is designed as a framework to couple multiple models. The `MFSimulation` object is the top-level container where the user defines which models (e.g., `gwf_1`, `gwe_1`) and which exchanges (e.g., `gwf-gwe`) are part of the simulation. The `mfgwfgwe` module is a direct manifestation of this powerful, modular design.","The `flopy.mf6.modflow.mfgwfgwe.py` module implements the **MODFLOW 6 Groundwater Flow (GWF) - Groundwater Energy (GWE) Exchange**. This is not a standalone package that defines a physical process (like Recharge or Wells) nor is it a numerical solver (like IMS or SMS). Instead, its sole purpose is to act as a data-passing mechanism that **couples a GWF Model with a GWE Model** running within the same simulation.

The primary functions of this exchange are:

1.  **Passing Flow Information to the GWE Model:** The GWF Model calculates the cell-by-cell groundwater flow rates. The GWFGWE exchange passes these flow rates (advective fluxes) to the GWE Model. The GWE Model then uses this flow field to solve the advection-dispersion equation for heat transport, simulating how temperature moves through the aquifer.

2.  **Enabling Density-Coupled Flow (Optional):** The GWE model calculates the temperature distribution in the aquifer. Temperature affects the density and viscosity of water. If density effects are significant, this exchange facilitates passing the temperature information back to the GWF model. When used in conjunction with the **Buoyancy (BUY) Package** in the GWF Model, these temperatures are used to calculate fluid density variations, which in turn affect the hydraulic head and groundwater flow patterns. This creates a fully coupled, two-way feedback loop where flow affects heat transport, and heat transport affects flow.

In essence, `mfgwfgwe` is the critical ""glue"" that allows a standard groundwater flow model and a heat transport model to interact and solve simultaneously."
mfgwfgwf.py,GWF,"GWF mf6 ModflowGwfgwf defines a GWFGWF package.

Parameters
----------
auxiliary : [string]
    an array of auxiliary variable names.  there is no limit on the number of
    auxiliary variables that can be provided. most auxiliary variables will not be
    used by the gwf-gwf exchange, but they will be available for use by other parts
    of the program.  if an auxiliary variable with the name 'angldegx' is found,
    then this information will be used as the angle (provided in degrees) between
    the  The `flopy.mf6.modflow.mfgwfgwf` module provides the Python interface for the **MODFLOW 6 Groundwater Flow to Groundwater Flow (GWF-GWF) Exchange package**. Its specific purpose is to simulate the flow of water between two separate and distinct Groundwater Flow (GWF) models that are part of the same overall simulation.

This is not a solver (like `IMS` or `SMS`) or a standard boundary condition package (like `WEL` or `RCH`). It is an **exchange package**, a powerful feature in MODFLOW 6 that allows for model coupling. It works by creating hydraulic connections between pairs of cells, one from each of the two GWF models. For each connected pair, MODFLOW calculates a conductance value and simulates flow based on the head difference between the two cells.

Key features and capabilities include:

-   **Model Coupling:** It is the primary tool for coupling two `ModflowGwf` models. These models can have different grid resolutions, orientations, or even discretization types (e.g., connecting a structured grid model to an unstructured grid model).
-   **Horizontal & Vertical Connections:** It can represent both horizontal flow (between adjacent models) and vertical flow (between stacked models).
-   **Sub-modeling:** It is ideal for creating ""local grid refinement"" where a fine-resolution model is embedded within a coarse-resolution regional model.
-   **Faults & Barriers:** The exchange can represent complex hydrogeologic features like faults or leaky confining units by defining the specific hydraulic characteristics of the connection between model cells.

The package code represented by this module is `GWFGWF`, not `GWF`. `GWF` refers to the Groundwater Flow Model itself. **Scenario 1: Local-Scale Contaminant Site Investigation** **Scenario 2: Modeling a Faulted Basin** **Scenario 3: Simulating Flow Between Stacked, Discontinuous Aquifers** **`flopy.mf6.modflow.mfgwf.ModflowGwf`:** This is the most fundamental related concept. The `ModflowGwfgwf` exchange is meaningless on its own; it exists solely to connect two instances of the `ModflowGwf` class. You must define the two GWF models before you can define the exchange between them. **`flopy.mf6.MFSimulation`:** The entire simulation, including the two GWF models and the GWF-GWF exchange that connects them, is contained within an `MFSimulation` object. This parent object manages the models, exchanges, and the solution process. The exchange is registered with the simulation, telling MODFLOW how the models are coupled. **Grid Discretization Packages (`DIS`, `DISV`, `DISU`):** The exchange connects specific cells identified by their `cellid`. Understanding how these cell IDs are structured is critical. For structured grids (`DIS`), `cellid` is a tuple `(layer, row, column)`. For unstructured grids (`DISU`, `DISV`), it is a single integer `(nodenumber)`. The `ModflowGwfgwf` exchange is powerful because it can connect models with different grid types (e.g., `DIS` to `DISV`), but the user must provide the correct `cellid` for each respective model's grid type. **Other Exchange Packages (`GWT-GWT`, `GWF-GWT`, `GWF-SFR`):** The GWF-GWF exchange is one of many types of exchanges in MODFLOW 6. The same coupling concept is used to connect two groundwater transport models (`GWT-GWT`), a flow model to a transport model (`GWF-GWT`), or a flow model to a Streamflow Routing model (`GWF-SFR`). Understanding `GWFGWF` helps in understanding the broader, powerful model-coupling framework of MODFLOW 6.","The `flopy.mf6.modflow.mfgwfgwf` module provides the Python interface for the **MODFLOW 6 Groundwater Flow to Groundwater Flow (GWF-GWF) Exchange package**. Its specific purpose is to simulate the flow of water between two separate and distinct Groundwater Flow (GWF) models that are part of the same overall simulation.

This is not a solver (like `IMS` or `SMS`) or a standard boundary condition package (like `WEL` or `RCH`). It is an **exchange package**, a powerful feature in MODFLOW 6 that allows for model coupling. It works by creating hydraulic connections between pairs of cells, one from each of the two GWF models. For each connected pair, MODFLOW calculates a conductance value and simulates flow based on the head difference between the two cells.

Key features and capabilities include:

-   **Model Coupling:** It is the primary tool for coupling two `ModflowGwf` models. These models can have different grid resolutions, orientations, or even discretization types (e.g., connecting a structured grid model to an unstructured grid model).
-   **Horizontal & Vertical Connections:** It can represent both horizontal flow (between adjacent models) and vertical flow (between stacked models).
-   **Sub-modeling:** It is ideal for creating ""local grid refinement"" where a fine-resolution model is embedded within a coarse-resolution regional model.
-   **Faults & Barriers:** The exchange can represent complex hydrogeologic features like faults or leaky confining units by defining the specific hydraulic characteristics of the connection between model cells.

The package code represented by this module is `GWFGWF`, not `GWF`. `GWF` refers to the Groundwater Flow Model itself."
mfgwfgwt.py,GWT,"GWT mf6 ModflowGwfgwt defines a GWFGWT package.

Parameters
---------- The `mfgwfgwt` Python module serves a single, critical purpose: it **defines the high-level coupling, or ""exchange,"" between a MODFLOW 6 Groundwater Flow (GWF) Model and a Groundwater Transport (GWT) Model within the same simulation.**

This module is not a package that defines physical properties or boundaries (like `NPF` or `WEL`). Instead, it acts as a ""switchboard operator"" at the simulation level. When a user creates a `ModflowGwfgwt` object, FloPy writes an `EXCHANGE` record into the main simulation name file (`mfsim.nam`). This record tells the MODFLOW 6 executable that the two specified models are linked and that information should be passed between them.

Specifically, the `GWF-GWT` exchange enables the GWT model to receive the calculated cell-by-cell flow rates from the GWF model. These flow rates are essential for the GWT model to solve the advection component of the advection-dispersion equation, which governs how dissolved constituents (contaminants, tracers, etc.) are carried by the flowing groundwater. For variable-density problems, this exchange also facilitates the transfer of concentration data from the GWT model back to the GWF model via the Buoyancy (BUY) package. **Scenario 1: Contaminant Plume Delineation** **Scenario 2: Saltwater Intrusion in a Coastal Aquifer** **Scenario 3: Evaluating a Managed Aquifer Recharge (MAR) System** **`MFSimulation` Object (`flopy.mf6.MFSimulation`)**: The `ModflowGwfgwt` exchange is defined at the simulation level, not the model level, because its job is to connect two models. Therefore, the `MFSimulation` object is always the parent object passed to the `ModflowGwfgwt` constructor. **GWT Mover Package (`MVT`)**: This is the most critical related concept. While `ModflowGwfgwt` *declares* the exchange exists, the Mover (MVT) package within the GWT model is what actually *uses* it. The user must create an MVT package and explicitly tell it to use the `GWF` model as its source for flow rates (known as the Flow-Mover Interface, or FMI). Without a correctly configured MVT package, the exchange declared by `ModflowGwfgwt` is inert. **GWF Buoyancy Package (`BUY`)**: For variable-density simulations like saltwater intrusion (Scenario 2), the Buoyancy package is required in the GWF model. This package receives concentration data from the GWT model (facilitated by the `GWF-GWT` exchange) and adjusts the GWF flow equations to account for density differences. The `ModflowGwfgwt` object makes this two-way communication possible.","The `mfgwfgwt` Python module serves a single, critical purpose: it **defines the high-level coupling, or ""exchange,"" between a MODFLOW 6 Groundwater Flow (GWF) Model and a Groundwater Transport (GWT) Model within the same simulation.**

This module is not a package that defines physical properties or boundaries (like `NPF` or `WEL`). Instead, it acts as a ""switchboard operator"" at the simulation level. When a user creates a `ModflowGwfgwt` object, FloPy writes an `EXCHANGE` record into the main simulation name file (`mfsim.nam`). This record tells the MODFLOW 6 executable that the two specified models are linked and that information should be passed between them.

Specifically, the `GWF-GWT` exchange enables the GWT model to receive the calculated cell-by-cell flow rates from the GWF model. These flow rates are essential for the GWT model to solve the advection component of the advection-dispersion equation, which governs how dissolved constituents (contaminants, tracers, etc.) are carried by the flowing groundwater. For variable-density problems, this exchange also facilitates the transfer of concentration data from the GWT model back to the GWF model via the Buoyancy (BUY) package."
mfgwfhfb.py,HFB,"HFB mf6 ModflowGwfhfb defines a HFB package.

Parameters
----------
print_input : keyword
    keyword to indicate that the list of horizontal flow barriers will be written
    to the listing file immediately after it is read.
maxhfb : integer
    integer value specifying the maximum number of horizontal flow barriers that
    will be entered in this input file.  the value of maxhfb is used to allocate
    memory for the horizontal flow barriers.
stress_period_data : [list] This module implements the **Horizontal Flow Barrier (HFB)** package for a MODFLOW 6 Groundwater Flow (GWF) Model. The HFB package is designed to simulate thin, vertical, low-permeability geologic features that impede or restrict horizontal groundwater flow between adjacent model cells.

It is not a solver or a standard boundary condition package that adds or removes water from the model (like Wells, Rivers, or General-Head Boundaries). Instead, the HFB package functions as an **internal boundary condition** that modifies the hydraulic conductance at the interface between two specific cells. This allows for a more accurate representation of features like slurry walls, grout curtains, sheet piling, or natural fault gouge zones, especially when these features are significantly thinner than the width of a model grid cell.

The primary input for this package consists of pairs of horizontally adjacent model cells and a corresponding **hydraulic characteristic**. The hydraulic characteristic is defined as the hydraulic conductivity of the barrier material divided by its thickness (K/b), which the model uses to compute the conductance of the barrier. **Scenario 1: Engineering a Contaminant Containment System** **Scenario 2: Simulating the Hydrogeologic Impact of a Sealing Fault** **Scenario 3: Modeling a Cutoff Wall for Construction Dewatering** **Node Property Flow (NPF) Package:** The most basic alternative to HFB is to modify cell properties directly in the NPF package by assigning a very low horizontal hydraulic conductivity (`k`) to a line of cells. HFB is superior because it simulates a feature that lies *between* cells, whereas modifying the NPF `k` value implies the entire cell has low permeability. HFB is more accurate for features that are thin relative to the cell size. **Wall (WALL) Package:** The WALL package is another MODFLOW 6 feature for simulating thin barriers. The key difference is that the WALL package geometry is specified more explicitly with vertices, and MODFLOW internally determines which cell faces are intersected. HFB is simpler, requiring the user to explicitly provide the `cellid1` and `cellid2` pairs. HFB is often easier for simple, grid-aligned barriers. **Constant Head (CHD) Package:** A novice modeler might mistakenly try to use a line of Constant-Head cells to represent a barrier, assuming it will ""block"" flow. This is incorrect. A CHD cell fixes the head value, acting as an infinite source or sink of water. A barrier, simulated by HFB, restricts flow and *causes* a head differential; it does not set the head to a specific value.","This module implements the **Horizontal Flow Barrier (HFB)** package for a MODFLOW 6 Groundwater Flow (GWF) Model. The HFB package is designed to simulate thin, vertical, low-permeability geologic features that impede or restrict horizontal groundwater flow between adjacent model cells.

It is not a solver or a standard boundary condition package that adds or removes water from the model (like Wells, Rivers, or General-Head Boundaries). Instead, the HFB package functions as an **internal boundary condition** that modifies the hydraulic conductance at the interface between two specific cells. This allows for a more accurate representation of features like slurry walls, grout curtains, sheet piling, or natural fault gouge zones, especially when these features are significantly thinner than the width of a model grid cell.

The primary input for this package consists of pairs of horizontally adjacent model cells and a corresponding **hydraulic characteristic**. The hydraulic characteristic is defined as the hydraulic conductivity of the barrier material divided by its thickness (K/b), which the model uses to compute the conductance of the barrier."
mfgwfic.py,ic,"mf6 ModflowGwfic defines a IC package.

Parameters
----------
export_array_ascii : keyword
    keyword that specifies input griddata arrays should be written to layered ascii
    output files.
export_array_netcdf : keyword
    keyword that specifies input griddata arrays should be written to the model
    output netcdf file.
strt : [double precision]
    is the initial (starting) head---that is, head at the beginning of the gwf
    model simulation.  strt must be specified for all simulations, inclu This module, `mfgwfic.py`, serves a single, critical purpose: it provides the FloPy interface for the **Initial Conditions (IC) Package** of a **MODFLOW 6 Groundwater Flow (GWF) Model**.

In any transient groundwater simulation, the model must know the state of the system at time zero. The IC package is responsible for defining this initial state. Specifically, it sets the starting hydraulic head for every active cell in the model grid. This starting head array is referred to as `STRT` in MODFLOW documentation.

This module is a fundamental **model package**. It is **not** a solver (like IMS or SMS), which calculates the solution for each time step. Instead, the IC package provides the head values from which the solver *begins* its calculations for the very first time step. For steady-state models, `STRT` provides the initial guess from which the solver iterates to find a solution.

-   **Model Family**: `mf6`
-   **Package Code**: `ic`
-   **Function**: Defines the initial hydraulic head conditions (`STRT`) for a GWF model.

--- **`flopy.mf6.ModflowGwf` (Groundwater Flow Model):** The IC package is a child of a GWF model instance. It cannot exist independently. It is instantiated by passing a `ModflowGwf` object to its constructor, linking it directly to a specific flow model. **Discretization Packages (`DIS`, `DISV`, `DISU`):** The shape and structure of the `strt` array required by the IC package are entirely determined by the model's discretization. For a regular grid (`DIS`), `strt` must be an array of shape `(nlay, nrow, ncol)`. For a discretized by vertices grid (`DISV`), it must have shape `(nlay, ncpl)`. This link is fundamental; you cannot define initial conditions without first defining the model grid. **`flopy.mf6.ModflowIms` (Iterative Model Solver):** The IC package provides the ""H_0"" (head at time zero) to the solver. The solver uses this `strt` array as the starting point for its iterative process to find a solution for the first time step (in a transient model) or the final solution (in a steady-state model). A poor `strt` value can cause the IMS solver to fail to converge.","This module, `mfgwfic.py`, serves a single, critical purpose: it provides the FloPy interface for the **Initial Conditions (IC) Package** of a **MODFLOW 6 Groundwater Flow (GWF) Model**.

In any transient groundwater simulation, the model must know the state of the system at time zero. The IC package is responsible for defining this initial state. Specifically, it sets the starting hydraulic head for every active cell in the model grid. This starting head array is referred to as `STRT` in MODFLOW documentation.

This module is a fundamental **model package**. It is **not** a solver (like IMS or SMS), which calculates the solution for each time step. Instead, the IC package provides the head values from which the solver *begins* its calculations for the very first time step. For steady-state models, `STRT` provides the initial guess from which the solver iterates to find a solution.

-   **Model Family**: `mf6`
-   **Package Code**: `ic`
-   **Function**: Defines the initial hydraulic head conditions (`STRT`) for a GWF model.

---"
mfgwflak.py,LAK,"LAK mf6 ModflowGwflak defines a LAK package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro The `flopy/mf6/modflow/mfgwflak.py` module provides the FloPy interface for the **MODFLOW 6 Lake (LAK) Package**. This is a powerful and complex boundary package used within a Groundwater Flow (GWF) Model.

Its primary purpose is to simulate the effects of lakes, reservoirs, or other surface water impoundments on a groundwater system. The LAK package is not a solver; rather, it represents a distinct hydraulic feature with its own water budget that is dynamically coupled with the groundwater model.

Key functionalities include:

*   **Lake-Aquifer Interaction:** Simulates seepage between the lake and the underlying and adjacent aquifer cells. The exchange is calculated based on the head difference, lakebed conductance, and lake geometry.
*   **Water Budget Accounting:** Explicitly calculates a water budget for each lake, including terms for:
    *   Seepage to/from the groundwater system.
    *   Direct precipitation onto the lake surface.
    *   Evaporation from the lake surface.
    *   Withdrawals (e.g., for water supply).
    *   Inflows (e.g., from streams, runoff, or specified sources).
    *   Outflows (e.g., over a weir or through a culvert).
*   **Dynamic Stage Calculation:** The lake stage (water level) can be calculated by the model based on the balance of inflows and outflows, or it can be specified as a fixed value.
*   **Connectivity:** Lakes can be connected to other MODFLOW 6 packages, most notably the Streamflow Routing (SFR) package, to simulate complex surface water systems. This connection is managed by the Mover (MVR) Package.

In essence, this module allows a modeler to treat a lake not just as a simple constant-head boundary, but as an integrated and dynamic component of the hydrologic system. **Scenario 1: Evaluating Pumping Well Impacts on Lake Levels** **Scenario 2: Simulating a Managed Reservoir System** **Scenario 3: Assessing Contaminant Transport from a Contaminated Lake** **Groundwater Flow (GWF) Model:** The LAK package is a component of a GWF model (`flopy.mf6.ModflowGwf`). It cannot exist on its own and functions by interacting with the grid cells defined in the GWF model's Discretization (DIS) package. **Mover (MVR) Package (`flopy.mf6.ModflowGwfMvr`):** This is a critical companion package. While the LAK and SFR packages can define *potential* connections (e.g., a lake outlet connects to a stream reach), the MVR package is what actually *activates* and manages the water transfer between them. Forgetting to include the MVR package is a common error when connecting LAK to other packages. **Streamflow Routing (SFR) Package (`flopy.mf6.ModflowGwfSfr`):** Lakes and streams are often part of the same hydrologic system. A model might have a stream flowing into a lake and another stream carrying outflow away from it. The LAK and SFR packages are designed to work together (via the MVR package) to simulate these integrated systems. **Unsaturated Zone Flow (UZF) Package (`flopy.mf6.ModflowGwfUzf`):** The UZF package can simulate infiltration, runoff, and groundwater recharge. A key feature is its ability to route rejected infiltration (runoff) to specified features, including lakes or streams. This allows for a more complete representation of the watershed's water balance, where surface runoff contributes to a lake's inflow.","The `flopy/mf6/modflow/mfgwflak.py` module provides the FloPy interface for the **MODFLOW 6 Lake (LAK) Package**. This is a powerful and complex boundary package used within a Groundwater Flow (GWF) Model.

Its primary purpose is to simulate the effects of lakes, reservoirs, or other surface water impoundments on a groundwater system. The LAK package is not a solver; rather, it represents a distinct hydraulic feature with its own water budget that is dynamically coupled with the groundwater model.

Key functionalities include:

*   **Lake-Aquifer Interaction:** Simulates seepage between the lake and the underlying and adjacent aquifer cells. The exchange is calculated based on the head difference, lakebed conductance, and lake geometry.
*   **Water Budget Accounting:** Explicitly calculates a water budget for each lake, including terms for:
    *   Seepage to/from the groundwater system.
    *   Direct precipitation onto the lake surface.
    *   Evaporation from the lake surface.
    *   Withdrawals (e.g., for water supply).
    *   Inflows (e.g., from streams, runoff, or specified sources).
    *   Outflows (e.g., over a weir or through a culvert).
*   **Dynamic Stage Calculation:** The lake stage (water level) can be calculated by the model based on the balance of inflows and outflows, or it can be specified as a fixed value.
*   **Connectivity:** Lakes can be connected to other MODFLOW 6 packages, most notably the Streamflow Routing (SFR) package, to simulate complex surface water systems. This connection is managed by the Mover (MVR) Package.

In essence, this module allows a modeler to treat a lake not just as a simple constant-head boundary, but as an integrated and dynamic component of the hydrologic system."
mfgwfmaw.py,MAW,"MAW mf6 ModflowGwfmaw defines a MAW package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro The `mfgwfmaw.py` module provides the FloPy interface for the **Multi-Aquifer Well (MAW) Package** of the MODFLOW 6 Groundwater Flow (GWF) Model. The MAW package is designed to simulate wells that are screened across multiple model layers. It is an advanced, physically-based boundary condition that offers a more realistic representation of complex wells compared to the standard Well (WEL) package.

The core purpose of the MAW package is to:
1.  **Simulate Multi-Layer Wells:** Model a single well that can withdraw water from, or inject water into, several aquifer layers simultaneously.
2.  **Calculate a Single Well Head:** The package calculates a single, vertically-averaged hydraulic head within the well bore for each well at each time step.
3.  **Simulate Intra-Borehole Flow:** A key feature is its ability to simulate flow *within the well casing* itself. Water can move from a high-head aquifer layer to a low-head aquifer layer through the well screen, even when the net pumping rate for the well is zero. This is crucial for modeling scenarios like cross-contamination or passive aquifer connection through abandoned wells.
4.  **Flexible Conductance Equations:** It provides several methods (`CONDEQN`) for calculating the conductance between the well and the connected aquifer cells, including options based on the Thiem equation, skin effects, and user-specified values.

In essence, MAW is a sophisticated head-dependent boundary package. It is **not a solver** (like SMS or IMS) but rather a package that represents a physical feature within the groundwater model, similar to packages for Rivers (SFR) or Lakes (LAK). **Scenario 1: High-Capacity Municipal or Agricultural Well** **Scenario 2: Assessing Cross-Contamination via an Abandoned Well** **Scenario 3: Aquifer Storage and Recovery (ASR) System Design** **WEL Package (`flopy.mf6.ModflowGwfwel`)** **MNW1/MNW2 Packages (MODFLOW-2005)** **Mover Packages (SFR, LAK, UZF)**","The `mfgwfmaw.py` module provides the FloPy interface for the **Multi-Aquifer Well (MAW) Package** of the MODFLOW 6 Groundwater Flow (GWF) Model. The MAW package is designed to simulate wells that are screened across multiple model layers. It is an advanced, physically-based boundary condition that offers a more realistic representation of complex wells compared to the standard Well (WEL) package.

The core purpose of the MAW package is to:
1.  **Simulate Multi-Layer Wells:** Model a single well that can withdraw water from, or inject water into, several aquifer layers simultaneously.
2.  **Calculate a Single Well Head:** The package calculates a single, vertically-averaged hydraulic head within the well bore for each well at each time step.
3.  **Simulate Intra-Borehole Flow:** A key feature is its ability to simulate flow *within the well casing* itself. Water can move from a high-head aquifer layer to a low-head aquifer layer through the well screen, even when the net pumping rate for the well is zero. This is crucial for modeling scenarios like cross-contamination or passive aquifer connection through abandoned wells.
4.  **Flexible Conductance Equations:** It provides several methods (`CONDEQN`) for calculating the conductance between the well and the connected aquifer cells, including options based on the Thiem equation, skin effects, and user-specified values.

In essence, MAW is a sophisticated head-dependent boundary package. It is **not a solver** (like SMS or IMS) but rather a package that represents a physical feature within the groundwater model, similar to packages for Rivers (SFR) or Lakes (LAK)."
mfgwfmvr.py,MVR,"MVR mf6 ModflowGwfmvr defines a MVR package.

Parameters
----------
print_input : keyword
    keyword to indicate that the list of mvr information will be written to the
    listing file immediately after it is read.
print_flows : keyword
    keyword to indicate that the list of mvr flow rates will be printed to the
    listing file for every stress period time step in which 'budget print' is
    specified in output control.  if there is no output control option and
    'print_flows' is specified, then  The `flopy.mf6.modflow.mfgwfmvr` module provides the Python interface for the **MODFLOW 6 Mover (MVR) Package**. The primary purpose of the MVR package is to simulate the **explicit movement of water between different hydrologic features** that are represented by other MODFLOW 6 packages.

It is not a solver (like `IMS` or `SMS`), nor is it a fundamental flow package defining aquifer properties (like `NPF` or `STO`). Instead, it functions as an **advanced stress package that acts as a connector**. It takes a specified quantity of water from a ""provider"" package and delivers it to a ""receiver"" package.

Key characteristics:
- **Connector, not a Boundary:** Unlike standard boundary conditions like Wells (`WEL`) or Recharge (`RCH`) that add or remove water from the simulation domain, MVR moves water *internally* from one model component to another.
- **Explicit Flow:** The user defines the flow rate, which can be a constant value, tied to a Time Series, or linked to the flow rate of another MVR package. This gives the user direct control over managed water systems.
- **Package Interaction:** It is designed to link various advanced packages. Common providers and receivers include:
    - Streamflow Routing (`SFR`)
    - Lakes (`LAK`)
    - Unsaturated Zone Flow (`UZF`)
    - Multi-Aquifer Wells (`MAW`)
    - Other Groundwater Flow (`GWF`) models within the same simulation.

In essence, this module is the tool for simulating human-managed water infrastructure like canals, pipelines, irrigation diversions, and return flows. **Scenario 1: Simulating Surface Water Irrigation** **Provider:** A specific reach in the Streamflow Routing (`SFR`) package. **Receiver:** A group of grid cells in the Unsaturated Zone Flow (`UZF`) package, representing infiltration of irrigation water onto the fields. **MVR Usage:** The `ModflowGwfmvr` class is used to define a flow record that takes water from the specified SFR reach and adds it as infiltration to the specified UZF cells. The flow rate can be linked to a Time Series (`TS`) to represent seasonal irrigation demands. **Scenario 2: Managed Aquifer Recharge (MAR) Project** **Provider:** A high-flow reach in the Streamflow Routing (`SFR`) package. **Receiver:** The Lake (`LAK`) package, representing the recharge basin/reservoir. **MVR Usage:** The modeler defines an MVR transfer from the SFR package to the LAK package. An additional option (`maxmvr` in the `PERIOD` block) can be used to specify that the diversion only occurs when streamflow exceeds a certain threshold, preventing the model from dewatering the stream. **Scenario 3: Modeling Agricultural Return Flow** **Provider:** The Unsaturated Zone Flow (`UZF`) package. The mover can be configured to take a fraction of the groundwater discharge to the surface (GWSW-ET term) from UZF. **Receiver:** A different reach in the Streamflow Routing (`SFR`) package, representing the drainage ditch. **MVR Usage:** The `ModflowGwfmvr` class defines a transfer from the UZF package to the SFR package. This simulates the collection and routing of subsurface drainage, providing a more realistic water balance by ensuring this water re-enters the surface water system at a specific location. **Provider and Receiver Packages (SFR, LAK, UZF, MAW):** The MVR package is entirely dependent on other packages to function. It cannot exist in isolation. Its primary role is to create connections between instances of `ModflowGwfsfr`, `ModflowGwflak`, `ModflowGwfuzf`, and `ModflowGwfmaw`. Understanding the data requirements and behavior of these ""endpoint"" packages is critical for using MVR correctly. **Time Series (TS Package):** Mover flow rates are rarely constant. They often vary with seasonal demands, operational rules, or climatic conditions. The `mfgwfts` module is used to define these time-varying rates. The MVR package then references the Time Series by name, allowing for complex, dynamic simulations of water transfers. For example, monthly irrigation withdrawals can be defined in a `TS` file and referenced by MVR. **Observations (OBS Package):** To verify that the Mover package is behaving as expected, it's crucial to monitor its performance. The `mfgwfobs` module can be used to create observations of MVR flow rates (`mvr-flow`), as well as the status of the provider/receiver packages (e.g., `sfr-flow`, `lak-stage`). This allows the modeler to plot the amount of water transferred over time and ensure it is physically plausible (e.g., ensuring diversions do not exceed available streamflow).","The `flopy.mf6.modflow.mfgwfmvr` module provides the Python interface for the **MODFLOW 6 Mover (MVR) Package**. The primary purpose of the MVR package is to simulate the **explicit movement of water between different hydrologic features** that are represented by other MODFLOW 6 packages.

It is not a solver (like `IMS` or `SMS`), nor is it a fundamental flow package defining aquifer properties (like `NPF` or `STO`). Instead, it functions as an **advanced stress package that acts as a connector**. It takes a specified quantity of water from a ""provider"" package and delivers it to a ""receiver"" package.

Key characteristics:
- **Connector, not a Boundary:** Unlike standard boundary conditions like Wells (`WEL`) or Recharge (`RCH`) that add or remove water from the simulation domain, MVR moves water *internally* from one model component to another.
- **Explicit Flow:** The user defines the flow rate, which can be a constant value, tied to a Time Series, or linked to the flow rate of another MVR package. This gives the user direct control over managed water systems.
- **Package Interaction:** It is designed to link various advanced packages. Common providers and receivers include:
    - Streamflow Routing (`SFR`)
    - Lakes (`LAK`)
    - Unsaturated Zone Flow (`UZF`)
    - Multi-Aquifer Wells (`MAW`)
    - Other Groundwater Flow (`GWF`) models within the same simulation.

In essence, this module is the tool for simulating human-managed water infrastructure like canals, pipelines, irrigation diversions, and return flows."
mfgwfnam.py,NAM,"NAM mf6 ModflowGwfnam defines a NAM package.

Parameters
----------
list : string
    is name of the listing file to create for this gwf model.  if not specified,
    then the name of the list file will be the basename of the gwf model name file
    and the '.lst' extension.  for example, if the gwf name file is called
    'my.model.nam' then the list file will be called 'my.model.lst'.
print_input : keyword
    keyword to indicate that the list of all model stress package information will
    be writte The `flopy.mf6.modflow.mfgwfnam` module serves a single, critical function: it defines the **Name File** for a MODFLOW 6 **Groundwater Flow (GWF) Model**. It is the direct FloPy representation of the `gwf.nam` file.

In the MODFLOW 6 framework, a simulation can contain multiple models (e.g., one or more GWF models, a Groundwater Transport model). Each of these models has its own Name File that acts as a ""table of contents,"" listing all the input files for the packages that comprise that specific model.

The `mfgwfnam` module, and its `ModflowGwfnam` class, is responsible for:
1.  **Registering Packages:** It keeps track of all the packages associated with a single GWF Model (e.g., Discretization `DIS`, Node Property Flow `NPF`, Well `WEL`, Recharge `RCH`, etc.).
2.  **Writing the Name File:** When the user writes the simulation files, this class generates the text for the `[modelname].nam` file. This file contains a list of file types and their corresponding filenames (e.g., `NPF6 mymodel.npf`, `WEL6 mymodel.wel`).
3.  **Managing Model-Level Options:** It handles optional entries in the Name File, such as specifying the filename for the model's output listing file (`.lst`).

This module is a structural component, not a physics package or a solver.

*   **Distinction from a Solver (e.g., IMS):** The `mfgwfnam` module *lists* the packages that define the groundwater flow problem. The **Iterative Model Solution (IMS)** is the numerical solver that actually solves the system of equations defined by those packages. The solver is defined at the *simulation* level, not the model level, and is referenced in the `mfsim.nam` file, not the `gwf.nam` file.
*   **Distinction from a Package (e.g., UZF):** A package like Unsaturated Zone Flow (`UZF`) contains the physical data and options for a specific process. The `mfgwfnam` module simply adds a line to the `gwf.nam` file that says, ""Use the `uzf` package, and its data is in the file named `mymodel.uzf`.""

In short, `mfgwfnam` is the central organizer for a single GWF model, telling MODFLOW 6 which components to assemble. **Scenario 1: Building a Standard Regional Aquifer Model** **Scenario 2: Adding and Removing Boundary Conditions Programmatically** **Scenario 3: Customizing Model Output File Names** **`flopy.mf6.MFSimulation`**: This is the parent object. A simulation is the top-level container in MODFLOW 6 and is represented by the `mfsim.nam` file. It holds models (like GWF), the temporal discretization (TDIS), and the solver (IMS). The `mfgwfnam` object exists *within* a model, which in turn exists *within* a simulation. **`flopy.mf6.ModflowGwf`**: This is the primary FloPy class for a MODFLOW 6 Groundwater Flow Model. It acts as a high-level container for all the individual packages (`DIS`, `NPF`, `WEL`, etc.). When a user creates a `ModflowGwf` instance, that instance immediately creates its own `ModflowGwfnam` object to manage its file list. You can think of `ModflowGwf` as the user-facing model object and `ModflowGwfnam` as its internal bookkeeper. **Package Classes (e.g., `flopy.mf6.ModflowGwfwel`, `flopy.mf6.ModflowGwfrch`)**: These classes represent the individual components of a groundwater model. Each time you add one of these package objects to a `ModflowGwf` model, a reference to it is added to the `ModflowGwfnam` object's internal registry. The `mfgwfnam` module is what ensures that a line like `WEL6 mymodel.wel` is written to the name file.","The `flopy.mf6.modflow.mfgwfnam` module serves a single, critical function: it defines the **Name File** for a MODFLOW 6 **Groundwater Flow (GWF) Model**. It is the direct FloPy representation of the `gwf.nam` file.

In the MODFLOW 6 framework, a simulation can contain multiple models (e.g., one or more GWF models, a Groundwater Transport model). Each of these models has its own Name File that acts as a ""table of contents,"" listing all the input files for the packages that comprise that specific model.

The `mfgwfnam` module, and its `ModflowGwfnam` class, is responsible for:
1.  **Registering Packages:** It keeps track of all the packages associated with a single GWF Model (e.g., Discretization `DIS`, Node Property Flow `NPF`, Well `WEL`, Recharge `RCH`, etc.).
2.  **Writing the Name File:** When the user writes the simulation files, this class generates the text for the `[modelname].nam` file. This file contains a list of file types and their corresponding filenames (e.g., `NPF6 mymodel.npf`, `WEL6 mymodel.wel`).
3.  **Managing Model-Level Options:** It handles optional entries in the Name File, such as specifying the filename for the model's output listing file (`.lst`).

This module is a structural component, not a physics package or a solver.

*   **Distinction from a Solver (e.g., IMS):** The `mfgwfnam` module *lists* the packages that define the groundwater flow problem. The **Iterative Model Solution (IMS)** is the numerical solver that actually solves the system of equations defined by those packages. The solver is defined at the *simulation* level, not the model level, and is referenced in the `mfsim.nam` file, not the `gwf.nam` file.
*   **Distinction from a Package (e.g., UZF):** A package like Unsaturated Zone Flow (`UZF`) contains the physical data and options for a specific process. The `mfgwfnam` module simply adds a line to the `gwf.nam` file that says, ""Use the `uzf` package, and its data is in the file named `mymodel.uzf`.""

In short, `mfgwfnam` is the central organizer for a single GWF model, telling MODFLOW 6 which components to assemble."
mfgwfnpf.py,NPF,"NPF mf6 ModflowGwfnpf defines a NPF package.

Parameters
----------
save_flows : keyword
    keyword to indicate that budget flow terms will be written to the file
    specified with 'budget save file' in output control.
print_flows : keyword
    keyword to indicate that calculated flows between cells will be printed to the
    listing file for every stress period time step in which 'budget print' is
    specified in output control. if there is no output control option and
    'print_flows' is specified The `flopy.mf6.modflow.mfgwfnpf` module implements the **Node Property Flow (NPF)** package for a MODFLOW 6 Groundwater Flow (GWF) Model. The NPF package is one of the most fundamental components of a GWF model, as it defines the hydraulic properties of the porous medium for each model cell (node).

Specifically, this module is responsible for:

*   **Hydraulic Conductivity:** Defining the rate at which water can move through the aquifer material. It supports isotropic conditions (hydraulic conductivity is the same in all directions) and anisotropic conditions (conductivity varies with direction), specified through `k`, `k22`, and `k33`.
*   **Cell State:** Determining whether a model cell is active, inactive, or a constant-head boundary. This is controlled by the `icelltype` parameter.
*   **Wetting and Drying:** Simulating how unconfined aquifer cells behave when the water table drops below the cell bottom. The NPF package controls if and how these ""dry"" cells can be ""rewet"" if the water table rises again. This is crucial for accurately modeling water table fluctuations, perched aquifers, and surface water interactions.

The NPF package in MODFLOW 6 consolidates functionality that was spread across multiple packages in previous MODFLOW versions, such as the Block-Centered Flow (BCF), Layer-Property Flow (LPF), and Upstream-Weighting (UPW) packages. It is not a solver (like IMS or SMS) or a boundary condition package (like WEL or RCH), but rather a core *property* package that describes the physical system itself. **Scenario 1: Simulating a simple, layered sedimentary basin.** **Scenario 2: Modeling a fractured bedrock aquifer with preferential flow.** **Scenario 3: Assessing dewatering impacts in an open-pit mine.** **Discretization Package (`DIS`, `DISV`, `DISU`):** The NPF package is fundamentally linked to the model grid defined by a Discretization package. The `DIS` package specifies the number of layers, rows, and columns (`nlay`, `nrow`, `ncol`), and the NPF package must provide property arrays (`k`, `icelltype`, etc.) with dimensions that match the grid. You cannot define node properties without first defining the nodes. **Storage Package (`STO`):** For any transient simulation, the NPF and STO packages work together. NPF governs how easily water *flows* between cells (conductivity), while STO governs how much water is released from *storage* within a cell when the head changes (specific yield and specific storage). The combination of these two packages dictates the aquifer's dynamic response (e.g., the speed and extent of a spreading cone of depression). **Initial Conditions Package (`IC`):** The `IC` package sets the starting head for the simulation. The `icelltype` property within the NPF package determines the initial state of these cells. For example, if a cell's `icelltype` is set to `0` (inactive), the head value provided by the `IC` package for that cell is ignored. If `icelltype` is `-1` (constant head), the `IC` starting head for that cell will be maintained throughout the simulation.","The `flopy.mf6.modflow.mfgwfnpf` module implements the **Node Property Flow (NPF)** package for a MODFLOW 6 Groundwater Flow (GWF) Model. The NPF package is one of the most fundamental components of a GWF model, as it defines the hydraulic properties of the porous medium for each model cell (node).

Specifically, this module is responsible for:

*   **Hydraulic Conductivity:** Defining the rate at which water can move through the aquifer material. It supports isotropic conditions (hydraulic conductivity is the same in all directions) and anisotropic conditions (conductivity varies with direction), specified through `k`, `k22`, and `k33`.
*   **Cell State:** Determining whether a model cell is active, inactive, or a constant-head boundary. This is controlled by the `icelltype` parameter.
*   **Wetting and Drying:** Simulating how unconfined aquifer cells behave when the water table drops below the cell bottom. The NPF package controls if and how these ""dry"" cells can be ""rewet"" if the water table rises again. This is crucial for accurately modeling water table fluctuations, perched aquifers, and surface water interactions.

The NPF package in MODFLOW 6 consolidates functionality that was spread across multiple packages in previous MODFLOW versions, such as the Block-Centered Flow (BCF), Layer-Property Flow (LPF), and Upstream-Weighting (UPW) packages. It is not a solver (like IMS or SMS) or a boundary condition package (like WEL or RCH), but rather a core *property* package that describes the physical system itself."
mfgwfoc.py,oc,"mf6 ModflowGwfoc defines a OC package.

Parameters
----------
budget_filerecord : (budgetfile)
    * budgetfile : string
            name of the output file to write budget information.

budgetcsv_filerecord : (budgetcsvfile)
    * budgetcsvfile : string
            name of the comma-separated value (CSV) output file to write budget summary
            information.  A budget summary record will be written to this file for each
            time step of the simulation.

head_filerecord : (headfile)
   The `flopy.mf6.modflow.mfgwfoc` module implements the **Output Control (OC) Package** for a **MODFLOW 6 Groundwater Flow (GWF) Model**. Its sole purpose is to manage and schedule the output generated by the GWF model during a simulation run.

This module does **not** represent a physical process (like a river or well) nor does it solve the groundwater flow equations (like the IMS or NWT solvers). Instead, it acts as a control panel, telling the model:

1.  **WHAT** to save: You can specify whether to save calculated heads, cell-by-cell budget flows, or budget terms for specific packages (e.g., just the flows from the Well package).
2.  **WHEN** to save: You can control the frequency of output, such as saving at every time step, only the last time step of a stress period, or a custom list of specific times.
3.  **HOW** to save: You can direct output to be printed in the text-based listing file (`.lst`) for quick inspection or saved to more efficient binary files (`.hds` for heads, `.cbb` for budgets) for post-processing and visualization.
4.  **IN WHAT FORMAT** to save: You can specify formats like `BINARY` or `ASCII` for the output files.

In essence, this package is crucial for managing simulation results, controlling file sizes, and enabling detailed diagnostics and post-processing workflows. **Scenario 1: Detailed Hydrograph Generation for Calibration** **Scenario 2: Annual Water Budget Reporting for a Water District** **Scenario 3: Debugging a Model with Unstable Boundary Conditions** **Time Discretization Package (TDIS)**: The OC package is fundamentally linked to the TDIS package. The stress periods and time steps defined in `TDIS` form the calendar that the `OC` package uses for scheduling output. You cannot request output for a time step or period that does not exist in the TDIS definition. Understanding the TDIS setup is a prerequisite for correctly configuring output control. **Binary Utility Readers (`flopy.utils.HeadFile`, `flopy.utils.CellBudgetFile`)**: These FloPy utility classes are the primary consumers of the files generated by the OC package. After the `OC` package instructs MODFLOW to create a binary head file (`.hds`) or cell-by-cell budget file (`.cbb`), the modeler uses these reader classes in a separate Python script to extract the data, analyze it, plot it, and perform calculations like water balance checks or drawdown analysis. **The Listing File (`.lst`)**: This is the main text-based output file from a MODFLOW run. The `PRINT_HEAD` and `PRINT_BUDGET` options within the OC package directly control how much head and budget information is written to this file. While binary files are better for large datasets, the listing file is invaluable for a quick, human-readable summary and for debugging convergence issues.","The `flopy.mf6.modflow.mfgwfoc` module implements the **Output Control (OC) Package** for a **MODFLOW 6 Groundwater Flow (GWF) Model**. Its sole purpose is to manage and schedule the output generated by the GWF model during a simulation run.

This module does **not** represent a physical process (like a river or well) nor does it solve the groundwater flow equations (like the IMS or NWT solvers). Instead, it acts as a control panel, telling the model:

1.  **WHAT** to save: You can specify whether to save calculated heads, cell-by-cell budget flows, or budget terms for specific packages (e.g., just the flows from the Well package).
2.  **WHEN** to save: You can control the frequency of output, such as saving at every time step, only the last time step of a stress period, or a custom list of specific times.
3.  **HOW** to save: You can direct output to be printed in the text-based listing file (`.lst`) for quick inspection or saved to more efficient binary files (`.hds` for heads, `.cbb` for budgets) for post-processing and visualization.
4.  **IN WHAT FORMAT** to save: You can specify formats like `BINARY` or `ASCII` for the output files.

In essence, this package is crucial for managing simulation results, controlling file sizes, and enabling detailed diagnostics and post-processing workflows."
mfgwfprt.py,PRT,"PRT mf6 ModflowGwfprt defines a GWFPRT package.

Parameters
---------- The `flopy.mf6.modflow.mfgwfprt` module provides the Python interface for the **Particle-Tracking (PRT) Package** of a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the advective movement of imaginary particles of water through a groundwater system whose flow field has been calculated by the GWF Model.

This module is used for:
*   **Pathline Analysis:** Determining the path a particle of water will take from a starting point to an endpoint.
*   **Travel Time Calculation:** Estimating the time it takes for water to travel along these pathlines.
*   **Source/Receptor Delineation:** Identifying the source areas of water arriving at a specific location (e.g., a well) or the potential endpoints of water originating from a source (e.g., a contaminant spill).

The PRT package is an integrated component of MODFLOW 6, meaning it runs as part of a single MODFLOW 6 simulation. It uses the pre-calculated head and cell-by-cell flow results from the associated GWF model to compute groundwater velocities.

**Crucially, PRT is not a solute transport model** like the MODFLOW 6 Groundwater Transport (GWT) Model. It only simulates advection and does not account for dispersion, diffusion, or chemical reactions. It is also distinct from a solver package (like IMS or SMS), as it does not solve the primary flow equations but rather post-processes the results of that solution. **Scenario 1: Delineating a Wellhead Protection Area (WHPA)** **Scenario 2: Identifying the Source of Known Contamination** **Scenario 3: Assessing Future Risk from a Contaminant Spill** **MODFLOW 6 GWF Model:** The PRT package is inextricably linked to a GWF Model. It cannot run on its own. The PRT package requires the hydraulic heads and, most importantly, the cell-by-cell flow budget (which must be saved by the GWF model) to calculate the velocity vectors that drive particle movement. The quality of the particle tracking results is entirely dependent on the quality and calibration of the underlying GWF model. **MODPATH:** This is the standalone particle-tracking program historically used with older versions of MODFLOW (e.g., MODFLOW-2005). The PRT package is the direct successor to MODPATH, now integrated within the MODFLOW 6 framework. While the concepts are nearly identical (forward/backward tracking, pathline/endpoint files), the PRT package simplifies the workflow by eliminating the need to run a separate executable. Users familiar with MODPATH will find PRT's functionality very familiar. **Effective Porosity (`nₑ`):** This is a critical hydrogeologic parameter for particle tracking. The GWF model calculates Darcy velocity (flow per unit area). To get the average linear groundwater velocity (the speed at which water particles move), the Darcy velocity must be divided by the effective porosity of the medium. An incorrect porosity value will lead to proportionally incorrect travel time calculations. This parameter is specified directly within the `ModflowGwfprt` class constructor. **MODFLOW 6 GWT Model:** The Groundwater Transport (GWT) model is used for comprehensive solute transport modeling. Unlike PRT, GWT solves the advection-dispersion equation, simulating how a plume of contamination spreads out (dispersion) and changes concentration over time. A modeler chooses PRT for quick pathline and travel time estimates, but must use GWT for a more realistic simulation of plume migration and concentration.","The `flopy.mf6.modflow.mfgwfprt` module provides the Python interface for the **Particle-Tracking (PRT) Package** of a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the advective movement of imaginary particles of water through a groundwater system whose flow field has been calculated by the GWF Model.

This module is used for:
*   **Pathline Analysis:** Determining the path a particle of water will take from a starting point to an endpoint.
*   **Travel Time Calculation:** Estimating the time it takes for water to travel along these pathlines.
*   **Source/Receptor Delineation:** Identifying the source areas of water arriving at a specific location (e.g., a well) or the potential endpoints of water originating from a source (e.g., a contaminant spill).

The PRT package is an integrated component of MODFLOW 6, meaning it runs as part of a single MODFLOW 6 simulation. It uses the pre-calculated head and cell-by-cell flow results from the associated GWF model to compute groundwater velocities.

**Crucially, PRT is not a solute transport model** like the MODFLOW 6 Groundwater Transport (GWT) Model. It only simulates advection and does not account for dispersion, diffusion, or chemical reactions. It is also distinct from a solver package (like IMS or SMS), as it does not solve the primary flow equations but rather post-processes the results of that solution."
mfgwfrch.py,RCH,"RCH mf6 ModflowGwfrch defines a RCH package.

Parameters
----------
fixed_cell : keyword
    indicates that recharge will not be reassigned to a cell underlying the cell
    specified in the list if the specified cell is inactive.
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for  This module, `mfgwfrch.py`, implements the **Recharge (RCH)** package for a **MODFLOW 6 Groundwater Flow (GWF) Model**. Its primary purpose is to simulate areally distributed recharge to the groundwater system.

Recharge is a flux boundary condition that represents water entering the model domain, typically from precipitation infiltrating through the land surface and percolating through the unsaturated zone to reach the water table.

Key characteristics of the RCH package as implemented by this module:

*   **Boundary Condition Type:** It is a specified flux boundary condition. The user *prescribes* the rate of water addition per unit area (e.g., in meters/day).
*   **Areal vs. Point:** It applies to entire grid cells, representing a distributed flux over the cell's horizontal area, unlike the Well (WEL) package which simulates flux at a point.
*   **Model Association:** It is a package that belongs to a GWF Model, not a solver (like IMS) or a different model type (like GWT for transport).
*   **Simplicity:** It is the simplest way to represent recharge. It does not simulate the complex physics of the unsaturated zone. For that, a more advanced package like the Unsaturated Zone Flow (UZF) package would be used. With RCH, the user provides the *result* of the infiltration process as a direct input.

In essence, `ModflowGwfrch` is the FloPy class used to construct the RCH input file for a MODFLOW 6 simulation, defining where and at what rate water is added to the uppermost active model layers. **Scenario 1: Regional Water Budget Assessment** **Scenario 2: Evaluating Land Use Change Impacts** **Scenario 3: Simulating Managed Aquifer Recharge (MAR)** **Unsaturated Zone Flow (UZF) Package:** UZF is a more complex and physically-based alternative to RCH. While RCH takes a specified recharge *rate* as input, UZF takes precipitation *rate* and potential ET as input and *simulates* infiltration, runoff, and percolation through the unsaturated zone to calculate the recharge that reaches the water table. A modeler chooses RCH for simplicity or when recharge is already well-quantified; they choose UZF when they need to explicitly model the soil moisture dynamics. **Evapotranspiration (EVT) Package:** EVT is the natural counterpart to RCH. It simulates water removal from the uppermost active layer due to plant transpiration and evaporation, up to a user-defined maximum rate and below a specified extinction depth. RCH and EVT are often used together to represent the primary atmospheric additions and withdrawals from the groundwater system. The recharge value provided to RCH often represents *net* recharge (Precipitation - ET - Runoff). **Time Discretization (TDIS) and Stress Periods:** The RCH package is tightly linked to the model's time structure, defined in the TDIS package. As shown in Scenario 3, recharge rates can be defined on a per-stress-period basis, allowing for the simulation of transient phenomena like seasonal precipitation patterns, irrigation schedules, or climate change scenarios. The `recharge` data can be provided as a dictionary keyed by zero-based stress period indices to achieve this.","This module, `mfgwfrch.py`, implements the **Recharge (RCH)** package for a **MODFLOW 6 Groundwater Flow (GWF) Model**. Its primary purpose is to simulate areally distributed recharge to the groundwater system.

Recharge is a flux boundary condition that represents water entering the model domain, typically from precipitation infiltrating through the land surface and percolating through the unsaturated zone to reach the water table.

Key characteristics of the RCH package as implemented by this module:

*   **Boundary Condition Type:** It is a specified flux boundary condition. The user *prescribes* the rate of water addition per unit area (e.g., in meters/day).
*   **Areal vs. Point:** It applies to entire grid cells, representing a distributed flux over the cell's horizontal area, unlike the Well (WEL) package which simulates flux at a point.
*   **Model Association:** It is a package that belongs to a GWF Model, not a solver (like IMS) or a different model type (like GWT for transport).
*   **Simplicity:** It is the simplest way to represent recharge. It does not simulate the complex physics of the unsaturated zone. For that, a more advanced package like the Unsaturated Zone Flow (UZF) package would be used. With RCH, the user provides the *result* of the infiltration process as a direct input.

In essence, `ModflowGwfrch` is the FloPy class used to construct the RCH input file for a MODFLOW 6 simulation, defining where and at what rate water is added to the uppermost active model layers."
mfgwfrcha.py,RCHA,"RCHA mf6 ModflowGwfrcha defines a RCHA package.

Parameters
----------
readasarrays : keyword
    indicates that array-based input will be used for the recharge package.  this
    keyword must be specified to use array-based input.  when readasarrays is
    specified, values must be provided for every cell within a model layer, even
    those cells that have an idomain value less than one.  values assigned to cells
    with idomain values less than one are not used and have no effect on simulation
    re The `flopy/mf6/modflow/mfgwfrcha.py` module implements the **MODFLOW 6 Recharge (RCHA) Package**. Its primary purpose is to simulate areally distributed recharge entering a groundwater flow (GWF) model. Recharge is a specified flux boundary condition representing water moving downward into the saturated zone, typically originating from precipitation infiltrating through the land surface and unsaturated zone.

Key characteristics of the RCHA package are:

*   **Boundary Condition:** It is a source term that adds water to the model domain.
*   **Areal Distribution:** Unlike point sources (like the Well package), recharge is applied over the area of model cells.
*   **Application Layer:** By default, MODFLOW 6 applies recharge to the highest active cell in each vertical column. The user can, however, specify a different layer using the `irch` option.
*   **Model Type:** It is specifically for the Groundwater Flow (GWF) Model in MODFLOW 6.
*   **Distinction from UZF:** The RCHA package is a simplified representation of recharge. The user provides a final recharge *rate* (e.g., meters/day). This contrasts with the more complex Unsaturated Zone Flow (UZF) package, which simulates the physical processes of water movement through the unsaturated zone and *calculates* the recharge rate that reaches the water table based on soil properties and precipitation. RCHA is not a solver; it is a boundary condition package that provides flow terms to the matrix equations solved by a solver like SMS (Sparse Matrix Solver).

In essence, `mfgwfrcha.py` provides the Python interface for hydrologists to define and control this fundamental water input in a MODFLOW 6 simulation using FloPy. **Scenario 1: Regional Water Budget Analysis** **Scenario 2: Assessing Impacts of Land Use Change** **Scenario 3: Simulating Managed Aquifer Recharge (MAR)** **UZF (Unsaturated Zone Flow) Package:** This is the most closely related, but more physically complex, alternative to RCHA. While RCHA requires the user to pre-calculate the recharge rate, UZF simulates water movement through the vadose zone. The modeler provides precipitation, ET demand, and unsaturated soil hydraulic properties, and UZF calculates the recharge that reaches the water table. The choice between RCHA and UZF depends on the study's objectives and data availability; RCHA is simpler, while UZF provides a more dynamic and process-based simulation of recharge. **EVT (Evapotranspiration) Package:** EVT and RCH are the two primary flux packages that represent interactions with the atmosphere at the top of the model. They are often used together. Recharge (RCH) adds water, while Evapotranspiration (EVT) removes water when the water table is near the land surface. A careful conceptual model is needed to ensure that net infiltration (used for RCH) and ET from the water table (used for EVT) are not double-counted or conflicting. **Time Series (`TS`) and `AUXILIARY` Variables:** MODFLOW 6 allows recharge rates to be specified using time series, which is highly efficient for transient models with many stress periods (e.g., daily time steps). Instead of providing a unique rate for every cell in every stress period, a user can define a time series for recharge (e.g., `recharge_ts`) and assign it to cells. Furthermore, the `AUXILIARY` keyword can be used with `RCHA` to tag recharge from different sources (e.g., 'irrigation', 'natural'), which can then be tracked separately using the budget post-processing tools.","The `flopy/mf6/modflow/mfgwfrcha.py` module implements the **MODFLOW 6 Recharge (RCHA) Package**. Its primary purpose is to simulate areally distributed recharge entering a groundwater flow (GWF) model. Recharge is a specified flux boundary condition representing water moving downward into the saturated zone, typically originating from precipitation infiltrating through the land surface and unsaturated zone.

Key characteristics of the RCHA package are:

*   **Boundary Condition:** It is a source term that adds water to the model domain.
*   **Areal Distribution:** Unlike point sources (like the Well package), recharge is applied over the area of model cells.
*   **Application Layer:** By default, MODFLOW 6 applies recharge to the highest active cell in each vertical column. The user can, however, specify a different layer using the `irch` option.
*   **Model Type:** It is specifically for the Groundwater Flow (GWF) Model in MODFLOW 6.
*   **Distinction from UZF:** The RCHA package is a simplified representation of recharge. The user provides a final recharge *rate* (e.g., meters/day). This contrasts with the more complex Unsaturated Zone Flow (UZF) package, which simulates the physical processes of water movement through the unsaturated zone and *calculates* the recharge rate that reaches the water table based on soil properties and precipitation. RCHA is not a solver; it is a boundary condition package that provides flow terms to the matrix equations solved by a solver like SMS (Sparse Matrix Solver).

In essence, `mfgwfrcha.py` provides the Python interface for hydrologists to define and control this fundamental water input in a MODFLOW 6 simulation using FloPy."
mfgwfriv.py,RIV,"RIV mf6 ModflowGwfriv defines a RIV package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro The `flopy.mf6.modflow.mfgwfriv` module provides the Python interface for the **River (RIV) Package** in a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the exchange of water between a surface water body, such as a river or stream, and the underlying groundwater system.

The RIV package functions as a **head-dependent flux boundary condition**. This means the rate and direction of water flow between the river and the aquifer are determined by the difference between the water level in the river (stage) and the groundwater head in the adjacent model cell.

The core calculation is governed by the following logic:
-   **Flow Equation:** `Q = C * (H_riv - H_gw)`
    -   `Q` is the volumetric flow rate between the river and aquifer.
    -   `H_riv` is the user-specified stage (head) of the river.
    -   `H_gw` is the simulated head in the aquifer cell.
    -   `C` is the **conductance** of the riverbed, representing how easily water can pass through it. Conductance is typically calculated as `C = (K * L * W) / M`, where `K` is the riverbed's vertical hydraulic conductivity, `L` and `W` are the length and width of the river reach within the cell, and `M` is the thickness of the riverbed sediment.

-   **Flow Direction:**
    -   If `H_riv > H_gw`, water flows from the river into the aquifer (a ""losing"" stream).
    -   If `H_gw > H_riv`, water flows from the aquifer into the river (a ""gaining"" stream or baseflow).

-   **Seepage Limitation:** A critical feature of the RIV package is its ability to handle situations where the aquifer head drops significantly. If the groundwater head (`H_gw`) falls below the specified elevation of the riverbed bottom (`RBOT`), the flux from the river becomes constant and is no longer dependent on the aquifer head. This prevents the model from unrealistically pulling an infinite amount of water from a disconnected or ""dry"" river.

In summary, this module is used to build a fundamental and widely used boundary condition that represents stream-aquifer interaction where the river stage is known or can be reasonably estimated. **Scenario 1: Assessing Streamflow Depletion from Pumping** **Scenario 2: Quantifying Gaining and Losing Reaches** **Scenario 3: Evaluating Climate Change Impacts on Groundwater-Dependent Ecosystems** **`ModflowGwfdrn` (Drain Package):** The Drain (DRN) package is also a head-dependent flux boundary. However, it only allows for one-way flow *out* of the aquifer. Water is removed from a cell if the groundwater head rises above the specified drain elevation. It cannot add water to the model. The RIV package allows for two-way flow, making it suitable for rivers that can both gain and lose water. **`ModflowGwfsfr` (Streamflow Routing Package):** The SFR package is a more complex and powerful alternative for simulating streams. Unlike RIV, where the river stage is a specified input, SFR dynamically calculates the stage and depth in each stream reach based on routed streamflow, inflows, and channel geometry (e.g., using Manning's equation). SFR should be used when the streamflow itself is a key variable to be simulated, while RIV is appropriate when the river acts as a simpler boundary with a known stage. **`ModflowGwfghb` (General-Head Boundary Package):** The GHB package also simulates head-dependent flux. The conceptual difference lies in the conductance term. For RIV, conductance represents the hydraulic resistance of the riverbed sediments directly beneath the river. For GHB, conductance represents the bulk resistance of the aquifer material between the model cell and a distant, constant-head source (e.g., a large lake or a regional aquifer). Furthermore, GHB does not have a bottom elevation (`RBOT`) to limit seepage if the head drops too low.","The `flopy.mf6.modflow.mfgwfriv` module provides the Python interface for the **River (RIV) Package** in a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to simulate the exchange of water between a surface water body, such as a river or stream, and the underlying groundwater system.

The RIV package functions as a **head-dependent flux boundary condition**. This means the rate and direction of water flow between the river and the aquifer are determined by the difference between the water level in the river (stage) and the groundwater head in the adjacent model cell.

The core calculation is governed by the following logic:
-   **Flow Equation:** `Q = C * (H_riv - H_gw)`
    -   `Q` is the volumetric flow rate between the river and aquifer.
    -   `H_riv` is the user-specified stage (head) of the river.
    -   `H_gw` is the simulated head in the aquifer cell.
    -   `C` is the **conductance** of the riverbed, representing how easily water can pass through it. Conductance is typically calculated as `C = (K * L * W) / M`, where `K` is the riverbed's vertical hydraulic conductivity, `L` and `W` are the length and width of the river reach within the cell, and `M` is the thickness of the riverbed sediment.

-   **Flow Direction:**
    -   If `H_riv > H_gw`, water flows from the river into the aquifer (a ""losing"" stream).
    -   If `H_gw > H_riv`, water flows from the aquifer into the river (a ""gaining"" stream or baseflow).

-   **Seepage Limitation:** A critical feature of the RIV package is its ability to handle situations where the aquifer head drops significantly. If the groundwater head (`H_gw`) falls below the specified elevation of the riverbed bottom (`RBOT`), the flux from the river becomes constant and is no longer dependent on the aquifer head. This prevents the model from unrealistically pulling an infinite amount of water from a disconnected or ""dry"" river.

In summary, this module is used to build a fundamental and widely used boundary condition that represents stream-aquifer interaction where the river stage is known or can be reasonably estimated."
mfgwfsfr.py,SFR,"SFR mf6 ModflowGwfsfr defines a SFR package.

Parameters
----------
storage : keyword
    keyword that activates storage contributions to the stream-flow routing package
    continuity equation.
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined The `flopy.mf6.modflow.mfgwfsfr` module provides the Python interface for the **Streamflow-Routing (SFR) Package** within a **MODFLOW 6 Groundwater Flow (GWF) Model**. The primary purpose of this module is to simulate surface water flow in streams and the dynamic, two-way exchange of water between these streams and the underlying aquifer.

Unlike simpler boundary packages like the River (RIV) or Drain (DRN) packages, SFR is a process-based package. It does not assume a fixed stream stage. Instead, it **calculates stream stage and depth** dynamically based on:
*   Flow routed from upstream reaches.
*   Inflows from tributaries, runoff, or specified sources.
*   Outflows to downstream reaches or diversions.
*   The gain or loss of water from the connected groundwater system.

The SFR package uses a continuity equation to route flow along a network of interconnected ""reaches."" For each reach, it computes flow to the next downstream reach using Manning's equation or a simple stage-discharge table. The interaction with the aquifer is calculated based on the head difference between the calculated stream stage and the groundwater head in the corresponding model cell, governed by the hydraulic properties of the streambed.

In essence, this module allows a hydrologist to build a fully coupled groundwater-surface water model, where the stream is an active and responsive component of the system, not just a passive boundary. **Scenario 1: Assessing Stream Depletion from Pumping** **Scenario 2: Conjunctive Use and Water Rights Management** **Scenario 3: Evaluating Stream Restoration and Habitat Suitability** **Scenario 4: Simulating Runoff and Recharge in an Integrated Watershed Model** **RIV (River) and DRN (Drain) Packages:** These are simpler alternatives to SFR. They model stream-aquifer interaction as a one-way or head-dependent flux boundary with a *fixed* external head (river stage). SFR is superior when the streamflow itself is expected to change significantly due to groundwater interaction or other factors in the model. A common choice is to use SFR for the main, dynamic river system and RIV for large rivers whose stage is unaffected by the local model (e.g., the Missouri River). **UZF (Unsaturated Zone Flow) Package:** This package is a frequent companion to SFR. UZF calculates infiltration and recharge based on precipitation. Critically, it can also calculate surface runoff, which can then be specified as a direct inflow into SFR reaches. This UZF-SFR linkage allows for a more complete representation of the watershed's hydrologic cycle. **LAK (Lake) Package:** In MODFLOW 6, the SFR and LAK packages are designed to work together seamlessly. A stream reach in SFR can be defined to flow into a lake, and another reach can be defined to flow out of it. This allows for the simulation of complex systems where rivers are connected by lakes. **GWT (Groundwater Transport) Model and SSM (Source-Sink Mixing) Package:** While SFR itself only simulates water flow, its outputs are crucial for contaminant transport modeling. The GWT model's SSM package uses the flow exchange rates calculated by SFR to determine the mass of a dissolved solute moving between the stream and the aquifer. Without SFR, accurately simulating contaminant fate and transport in a gaining or losing stream is not possible.","The `flopy.mf6.modflow.mfgwfsfr` module provides the Python interface for the **Streamflow-Routing (SFR) Package** within a **MODFLOW 6 Groundwater Flow (GWF) Model**. The primary purpose of this module is to simulate surface water flow in streams and the dynamic, two-way exchange of water between these streams and the underlying aquifer.

Unlike simpler boundary packages like the River (RIV) or Drain (DRN) packages, SFR is a process-based package. It does not assume a fixed stream stage. Instead, it **calculates stream stage and depth** dynamically based on:
*   Flow routed from upstream reaches.
*   Inflows from tributaries, runoff, or specified sources.
*   Outflows to downstream reaches or diversions.
*   The gain or loss of water from the connected groundwater system.

The SFR package uses a continuity equation to route flow along a network of interconnected ""reaches."" For each reach, it computes flow to the next downstream reach using Manning's equation or a simple stage-discharge table. The interaction with the aquifer is calculated based on the head difference between the calculated stream stage and the groundwater head in the corresponding model cell, governed by the hydraulic properties of the streambed.

In essence, this module allows a hydrologist to build a fully coupled groundwater-surface water model, where the stream is an active and responsive component of the system, not just a passive boundary."
mfgwfsto.py,STO,"STO mf6 ModflowGwfsto defines a STO package.

Parameters
----------
save_flows : keyword
    keyword to indicate that cell-by-cell flow terms will be written to the file
    specified with 'budget save file' in output control.
storagecoefficient : keyword
    keyword to indicate that the ss array is read as storage coefficient rather
    than specific storage.
ss_confined_only : keyword
    keyword to indicate that compressible storage is only calculated for a
    convertible cell (iconvert>0) when the  The `flopy.mf6.modflow.mfgwfsto` module provides the Python interface for the **MODFLOW 6 Storage (STO) Package**. The primary purpose of this package is to define how water is released from or taken into storage within an aquifer system when hydraulic heads change over time.

This package is **fundamental and required for any transient groundwater flow simulation**. It essentially activates the time-dependent term in the groundwater flow equation. Without the STO package, a MODFLOW 6 Groundwater Flow (GWF) model can only be run in steady-state, where storage terms are considered zero.

Key properties defined by this package include:

*   **Specific Storage (`ss`)**: The volume of water released from storage per unit volume of aquifer per unit decline in hydraulic head. This property governs storage changes in **confined** aquifers due to the compressibility of the porous matrix and the water itself.
*   **Specific Yield (`sy`)**: The volume of water released from storage per unit surface area of aquifer per unit decline in the water table. This property governs storage changes in **unconfined** aquifers due to the actual dewatering or filling of pore spaces.
*   **Convertibility (`iconvert`)**: A flag for each model cell that indicates if it can convert between confined and unconfined conditions during a simulation.

The STO package is a core **property package**, not a solver (like IMS or SMS) or a boundary condition (like WEL or RCH). It defines the intrinsic physical storage characteristics of the aquifer materials themselves. **Scenario 1: Pumping Well Drawdown Analysis** **Scenario 2: Managed Aquifer Recharge (MAR) Assessment** **Scenario 3: Simulating Seasonal Water Table Fluctuations** **Time Discretization (TDIS) Package**: The STO package is only active during transient stress periods. The TDIS package is where the user defines the length, number of time steps, and type (steady-state or transient) of each stress period. The STO package relies entirely on the TDIS setup to know *when* to calculate changes in storage. **Node Property Flow (NPF) Package**: The NPF package defines hydraulic conductivity (`k`) and cell convertibility (`icelltype`). The STO package defines storativity (`sy`, `ss`). Together, NPF and STO define the fundamental hydraulic properties of the aquifer. The ratio of transmissivity (from NPF) to the storage coefficient (from STO) is the hydraulic diffusivity, which controls the rate at which head changes propagate through the system. The `icelltype` in NPF works with `iconvert` in STO to manage transitions between confined and unconfined states. **Initial Conditions (IC) Package**: For any transient simulation, the model needs a starting point. The IC package specifies the hydraulic head in every model cell at time zero. The STO package then uses these initial heads as the basis from which to calculate storage changes in the first time step and all subsequent steps.","The `flopy.mf6.modflow.mfgwfsto` module provides the Python interface for the **MODFLOW 6 Storage (STO) Package**. The primary purpose of this package is to define how water is released from or taken into storage within an aquifer system when hydraulic heads change over time.

This package is **fundamental and required for any transient groundwater flow simulation**. It essentially activates the time-dependent term in the groundwater flow equation. Without the STO package, a MODFLOW 6 Groundwater Flow (GWF) model can only be run in steady-state, where storage terms are considered zero.

Key properties defined by this package include:

*   **Specific Storage (`ss`)**: The volume of water released from storage per unit volume of aquifer per unit decline in hydraulic head. This property governs storage changes in **confined** aquifers due to the compressibility of the porous matrix and the water itself.
*   **Specific Yield (`sy`)**: The volume of water released from storage per unit surface area of aquifer per unit decline in the water table. This property governs storage changes in **unconfined** aquifers due to the actual dewatering or filling of pore spaces.
*   **Convertibility (`iconvert`)**: A flag for each model cell that indicates if it can convert between confined and unconfined conditions during a simulation.

The STO package is a core **property package**, not a solver (like IMS or SMS) or a boundary condition (like WEL or RCH). It defines the intrinsic physical storage characteristics of the aquifer materials themselves."
mfgwfuzf.py,UZF,"UZF mf6 ModflowGwfuzf defines a UZF package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro The Python module `mfgwfuzf.py` provides the FloPy interface for the **Unsaturated Zone Flow (UZF) Package** within a **MODFLOW 6 Groundwater Flow (GWF) Model**. Its primary purpose is to simulate the vertical movement of water through the unsaturated zone, which lies between the land surface and the groundwater table.

This module allows a modeler to define and parameterize the processes governing infiltration, evapotranspiration (ET), soil water storage, and deep percolation (recharge) to the saturated zone. It does this by implementing a simplified one-dimensional kinematic-wave approximation of Richards' equation for each vertical column of cells.

Key functionalities include:

*   **Calculating Recharge:** Instead of specifying a fixed recharge rate (as with the RCH Package), UZF calculates recharge dynamically based on surface infiltration rates, ET demands, and the moisture state of the unsaturated zone.
*   **Simulating Evapotranspiration:** It simulates actual ET as a function of potential ET, rooting depth, and available soil moisture. Water is first removed from the unsaturated zone before being extracted from the saturated zone.
*   **Routing Surface Runoff:** UZF can calculate ""rejected infiltration""—water that cannot enter the soil profile because it is already saturated. This excess water can be removed from the model or, more powerfully, be routed to a connected **Streamflow Routing (SFR)** or **Lake (LAK)** package, creating a fully-coupled surface-groundwater interaction model.
*   **Tracking Soil Moisture:** The package tracks the water content within the unsaturated zone, which can be critical for agricultural or ecohydrology studies.

In short, `mfgwfuzf.py` is the tool for building a more physically realistic representation of the land surface boundary of a groundwater model, moving beyond simple prescribed fluxes. It is a process-based *package*, not a *solver* like the Iterative Matrix Solver (IMS). **Scenario 1: Agricultural Water Budget and Irrigation Efficiency** **Scenario 2: Assessing Landfill or Mine Tailing Leachate Travel Time** **Scenario 3: Managed Aquifer Recharge (MAR) and Climate Change Impacts** **`ModflowGwfrch` (Recharge Package):** This is the simpler alternative to UZF. RCH applies a specified recharge flux directly to the top active cells of the model. UZF is chosen over RCH when the intermediate processes of soil storage, ET, and infiltration capacity are important to the modeling objectives. A model cannot have both UZF and RCH active in the same cell. **`ModflowGwfevt` (Evapotranspiration Package):** This is the simpler alternative for simulating ET. EVT removes water directly from the saturated zone at a rate dependent on the depth of the water table. UZF provides a more realistic simulation where ET first depletes soil moisture in the unsaturated zone before affecting the water table. UZF's internal ET calculations are generally used instead of the EVT package. **`ModflowGwfsfr` and `ModflowGwfLak` (Streamflow Routing and Lake Packages):** A key feature of MODFLOW 6 is the ability to connect packages. UZF can be configured to route rejected infiltration (surface runoff) directly to specified reaches of an SFR model or cells of a LAK model. This creates a powerful, integrated model where heavy rainfall can generate runoff that directly enters the stream network, a process not easily simulated with older MODFLOW versions. This connection is defined using the `uzf-sfr` or `uzf-lak` auxiliary options. **`ModflowGwt` (Groundwater Transport Model):** While UZF itself does not simulate solute transport, it provides the advective flux (recharge) that drives transport from the land surface. In a coupled GWF-GWT model, the recharge calculated by UZF is passed to the GWT model, carrying solutes into the aquifer. This is handled by the Source Sink Mixing (SSM) package, which requires specifying the concentration of the infiltrating water.","The Python module `mfgwfuzf.py` provides the FloPy interface for the **Unsaturated Zone Flow (UZF) Package** within a **MODFLOW 6 Groundwater Flow (GWF) Model**. Its primary purpose is to simulate the vertical movement of water through the unsaturated zone, which lies between the land surface and the groundwater table.

This module allows a modeler to define and parameterize the processes governing infiltration, evapotranspiration (ET), soil water storage, and deep percolation (recharge) to the saturated zone. It does this by implementing a simplified one-dimensional kinematic-wave approximation of Richards' equation for each vertical column of cells.

Key functionalities include:

*   **Calculating Recharge:** Instead of specifying a fixed recharge rate (as with the RCH Package), UZF calculates recharge dynamically based on surface infiltration rates, ET demands, and the moisture state of the unsaturated zone.
*   **Simulating Evapotranspiration:** It simulates actual ET as a function of potential ET, rooting depth, and available soil moisture. Water is first removed from the unsaturated zone before being extracted from the saturated zone.
*   **Routing Surface Runoff:** UZF can calculate ""rejected infiltration""—water that cannot enter the soil profile because it is already saturated. This excess water can be removed from the model or, more powerfully, be routed to a connected **Streamflow Routing (SFR)** or **Lake (LAK)** package, creating a fully-coupled surface-groundwater interaction model.
*   **Tracking Soil Moisture:** The package tracks the water content within the unsaturated zone, which can be critical for agricultural or ecohydrology studies.

In short, `mfgwfuzf.py` is the tool for building a more physically realistic representation of the land surface boundary of a groundwater model, moving beyond simple prescribed fluxes. It is a process-based *package*, not a *solver* like the Iterative Matrix Solver (IMS)."
mfgwfvsc.py,VSC,"VSC mf6 ModflowGwfvsc defines a VSC package.

Parameters
----------
viscref : double precision
    fluid reference viscosity used in the equation of state.  this value is set to
    1.0 if not specified as an option.
temperature_species_name : string
    string used to identify the auxspeciesname in packagedata that corresponds to
    the temperature species.  there can be only one occurrence of this temperature
    species name in the packagedata block or the program will terminate with an
    error.   The `flopy.mf6.modflow.mfgwfvsc` module implements the **Viscosity (VSC) Package** for a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to account for the effects of variable fluid viscosity on groundwater flow.

In the standard groundwater flow equation, hydraulic conductivity is treated as a property of the porous medium alone. However, the ease with which a fluid moves through a medium (the hydraulic conductivity) also depends on the fluid's properties, namely its density and viscosity. The VSC package allows the model to dynamically adjust hydraulic conductivity based on changes in fluid viscosity.

This package is almost exclusively used in simulations of **variable-density flow**, where viscosity is a function of solute concentration (e.g., salinity) or temperature. The VSC package works in concert with the Groundwater Transport (GWT) Model. The GWT model calculates the concentration or temperature field, and the VSC package uses this information to modify the hydraulic conductivity in the GWF Model for the next time step. This creates a fully coupled feedback loop: flow affects transport, and transport (via concentration/temperature) affects fluid properties (viscosity), which in turn affects flow.

It is important to distinguish the VSC package from other components:
*   **It is not a solver:** It does not solve the matrix equations (like `IMS` or `SMS`).
*   **It is not a boundary condition:** It does not add or remove water from the model (like `WEL`, `RCH`, or `GHB`).
*   **It is a property package:** Similar to the Node Property Flow (`NPF`) or Storage (`STO`) packages, it defines physical properties of the flow system. Specifically, it modifies the hydraulic conductivity defined in the `NPF` package to account for fluid effects. **Scenario 1: Coastal Aquifer Management** **Scenario 2: Brine Contamination from Industrial Sources** **Scenario 3: Geothermal Energy Simulation** **Groundwater Transport (GWT) Model and the Buoyancy (BUY) Package** **Density-Dependent Flow** **Node Property Flow (NPF) Package**","The `flopy.mf6.modflow.mfgwfvsc` module implements the **Viscosity (VSC) Package** for a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to account for the effects of variable fluid viscosity on groundwater flow.

In the standard groundwater flow equation, hydraulic conductivity is treated as a property of the porous medium alone. However, the ease with which a fluid moves through a medium (the hydraulic conductivity) also depends on the fluid's properties, namely its density and viscosity. The VSC package allows the model to dynamically adjust hydraulic conductivity based on changes in fluid viscosity.

This package is almost exclusively used in simulations of **variable-density flow**, where viscosity is a function of solute concentration (e.g., salinity) or temperature. The VSC package works in concert with the Groundwater Transport (GWT) Model. The GWT model calculates the concentration or temperature field, and the VSC package uses this information to modify the hydraulic conductivity in the GWF Model for the next time step. This creates a fully coupled feedback loop: flow affects transport, and transport (via concentration/temperature) affects fluid properties (viscosity), which in turn affects flow.

It is important to distinguish the VSC package from other components:
*   **It is not a solver:** It does not solve the matrix equations (like `IMS` or `SMS`).
*   **It is not a boundary condition:** It does not add or remove water from the model (like `WEL`, `RCH`, or `GHB`).
*   **It is a property package:** Similar to the Node Property Flow (`NPF`) or Storage (`STO`) packages, it defines physical properties of the flow system. Specifically, it modifies the hydraulic conductivity defined in the `NPF` package to account for fluid effects."
mfgwfwel.py,WEL,"WEL mf6 ModflowGwfwel defines a WEL package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro This module, `mfgwfwel.py`, implements the **Well (WEL) Package** for a **MODFLOW 6 (MF6) Groundwater Flow (GWF) Model**. Its primary purpose is to simulate volumetric fluxes (water being added or removed) at specific locations within the model grid at a user-specified rate.

The WEL package is one of the most fundamental and widely used ""source/sink"" packages in groundwater modeling. Key characteristics include:

*   **Boundary Condition Type:** It represents a specified-flux (Neumann) boundary condition.
*   **Flux Specification:** The flux (pumping or injection rate) is explicitly defined by the user and is **independent of the simulated groundwater head** in the cell. This means the well will add or remove water at the given rate regardless of whether the cell becomes dry or the head rises significantly.
*   **Simulated Processes:**
    *   **Extraction:** Simulates pumping from wells, such as for municipal water supply, irrigation, or dewatering. These are represented by **negative** flow rates.
    *   **Injection:** Simulates the injection of water into the aquifer, such as for Aquifer Storage and Recovery (ASR) or waste disposal. These are represented by **positive** flow rates.
*   **Role in FloPy:** The `ModflowGwfwel` class acts as a Pythonic interface for users. It allows them to define well locations, pumping/injection rates, and time-varying schedules. FloPy then takes this Python object and writes the correctly formatted text-based input file that the MODFLOW 6 executable reads.

In short, this module is the tool for adding simple, prescribed-rate wells to a MODFLOW 6 groundwater flow simulation.","This module, `mfgwfwel.py`, implements the **Well (WEL) Package** for a **MODFLOW 6 (MF6) Groundwater Flow (GWF) Model**. Its primary purpose is to simulate volumetric fluxes (water being added or removed) at specific locations within the model grid at a user-specified rate.

The WEL package is one of the most fundamental and widely used ""source/sink"" packages in groundwater modeling. Key characteristics include:

*   **Boundary Condition Type:** It represents a specified-flux (Neumann) boundary condition.
*   **Flux Specification:** The flux (pumping or injection rate) is explicitly defined by the user and is **independent of the simulated groundwater head** in the cell. This means the well will add or remove water at the given rate regardless of whether the cell becomes dry or the head rises significantly.
*   **Simulated Processes:**
    *   **Extraction:** Simulates pumping from wells, such as for municipal water supply, irrigation, or dewatering. These are represented by **negative** flow rates.
    *   **Injection:** Simulates the injection of water into the aquifer, such as for Aquifer Storage and Recovery (ASR) or waste disposal. These are represented by **positive** flow rates.
*   **Role in FloPy:** The `ModflowGwfwel` class acts as a Pythonic interface for users. It allows them to define well locations, pumping/injection rates, and time-varying schedules. FloPy then takes this Python object and writes the correctly formatted text-based input file that the MODFLOW 6 executable reads.

In short, this module is the tool for adding simple, prescribed-rate wells to a MODFLOW 6 groundwater flow simulation."
mfgwt.py,GWT,"GWT mf6 ModflowGwt defines a GWT model.

Parameters
----------
list : string
    is name of the listing file to create for this gwt model.  if not specified,
    then the name of the list file will be the basename of the gwt model name file
    and the '.lst' extension.  for example, if the gwt name file is called
    'my.model.nam' then the list file will be called 'my.model.lst'.
print_input : keyword
    keyword to indicate that the list of all model stress package information will
    be written to  This module provides the `ModflowGwt` class, which serves as the top-level container for a **MODFLOW 6 Groundwater Transport (GWT) Model**. Its primary purpose is to simulate the fate and transport of a single, dissolved chemical species (solute) through a porous medium.

The `ModflowGwt` class itself does not implement the physics of transport. Instead, it acts as a ""model"" object that holds and manages all the individual packages defining the transport simulation. A GWT model is fundamentally dependent on a pre-existing Groundwater Flow (GWF) model, as it uses the flow velocities calculated by the GWF model to drive the advective movement of solutes.

In essence, a user creates an instance of `ModflowGwt` and then adds various transport-related packages to it, such as:
*   **Core Packages:** `IC` (Initial Conditions), `ADV` (Advection), `DSP` (Dispersion), `MST` (Mobile Storage and Transfer), and `SSM` (Source-Sink Mixing).
*   **Boundary Conditions:** `CNC` (Constant Concentration), `SRC` (Source Concentration).
*   **Output Control:** `OC` (Output Control), `OBS` (Observations).

This module is **not a solver**. A solver package, like `IMS` (Iterative Model Solution), is defined at the simulation level and is used to numerically solve the system of linear equations generated by both the GWF and GWT models. The `ModflowGwt` object defines the *problem* to be solved, not the method for solving it. **Scenario 1: Contaminant Plume Migration** **Scenario 2: Saltwater Intrusion Assessment** **Scenario 3: Agricultural Nutrient Loading** **`flopy.mf6.ModflowGwf`**: This is the most critical related concept. A `ModflowGwt` model is almost always driven by the velocity field calculated by a `ModflowGwf` (Groundwater Flow) model. They represent the two halves of a standard flow-and-transport simulation, with `Gwf` handling the water movement and `Gwt` handling the solute movement within that water. **`flopy.mf6.MFSimulation`**: The `ModflowGwt` model object cannot be run in isolation. It must be added to an `MFSimulation` object, which is the top-level container for the entire simulation. The simulation object manages the models (e.g., one GWF and one GWT), the solution method (`IMS` package), and the coupling between models (the `GWF-GWT` Exchange). **Source-Sink Mixing (`SSM`) Package (`flopy.mf6.modflow.mfgwtssm`)**: This package is the essential ""bridge"" between flow boundaries and transport. If a GWF model has packages like wells (`WEL`), recharge (`RCH`), or rivers (`RIV`), the `SSM` package must be included in the `ModflowGwt` model to define the concentrations associated with these flows. For example, `SSM` tells the model the concentration of injected water or specifies that recharge water carries a certain concentration of a contaminant. Without it, flow boundaries do not act as sources or sinks of solute mass.","This module provides the `ModflowGwt` class, which serves as the top-level container for a **MODFLOW 6 Groundwater Transport (GWT) Model**. Its primary purpose is to simulate the fate and transport of a single, dissolved chemical species (solute) through a porous medium.

The `ModflowGwt` class itself does not implement the physics of transport. Instead, it acts as a ""model"" object that holds and manages all the individual packages defining the transport simulation. A GWT model is fundamentally dependent on a pre-existing Groundwater Flow (GWF) model, as it uses the flow velocities calculated by the GWF model to drive the advective movement of solutes.

In essence, a user creates an instance of `ModflowGwt` and then adds various transport-related packages to it, such as:
*   **Core Packages:** `IC` (Initial Conditions), `ADV` (Advection), `DSP` (Dispersion), `MST` (Mobile Storage and Transfer), and `SSM` (Source-Sink Mixing).
*   **Boundary Conditions:** `CNC` (Constant Concentration), `SRC` (Source Concentration).
*   **Output Control:** `OC` (Output Control), `OBS` (Observations).

This module is **not a solver**. A solver package, like `IMS` (Iterative Model Solution), is defined at the simulation level and is used to numerically solve the system of linear equations generated by both the GWF and GWT models. The `ModflowGwt` object defines the *problem* to be solved, not the method for solving it."
mfgwtadv.py,ADV,"ADV mf6 ModflowGwtadv defines a ADV package.

Parameters
----------
scheme : string
    scheme used to solve the advection term.  can be upstream, central, or tvd.  if
    not specified, upstream weighting is the default weighting scheme.
ats_percel : double precision
    fractional cell distance submitted by the adv package to the adaptive time
    stepping (ats) package.  if ats_percel is specified and the ats package is
    active, a time step calculation will be made for each cell based on flow
     The `flopy.mf6.modflow.mfgwtadv` Python module is a FloPy wrapper for the **Advection (ADV) Package** of the MODFLOW 6 Groundwater Transport (GWT) Model.

The primary purpose of this module is to configure and solve the advection term of the solute transport equation. Advection is the process by which a dissolved substance (solute) is transported by the bulk movement of flowing groundwater. The velocity of the groundwater, which drives advection, is calculated by the Groundwater Flow (GWF) Model and passed to the GWT Model.

This package is **not a solver** in the same sense as the IMS (Iterative Model Solution) or SMS (Sparse Matrix Solver) packages. Instead, it is a **process package** that defines the numerical method for handling one specific physical process (advection). The GWT Model as a whole is solved using a solution package like IMS, but the `ADV` package dictates *how* the advection component is formulated within the governing equations.

It is a **mandatory package** for any GWT Model simulation. You cannot run a transport simulation in MODFLOW 6 without including and configuring the Advection Package. Its key responsibility is to let the user choose the numerical scheme for solving advection, which has a major impact on model stability and accuracy. The primary user-configurable option is the `scheme`, which can be set to:
-   **UPSTREAM**: A simple, robust, and numerically stable first-order method. It is often used for initial model runs but can introduce significant numerical dispersion (artificial spreading of the plume).
-   **CENTRAL**: A second-order accurate method that reduces numerical dispersion but is prone to non-physical oscillations and instability, especially where sharp concentration fronts exist.
-   **TVD (Total Variation Diminishing)**: A higher-order, computationally more intensive method that provides sharp front tracking (low numerical dispersion) while suppressing the oscillations common to the central-difference scheme. This is often the preferred scheme for accurate plume delineation. **Scenario 1: Initial Contaminant Plume Screening** **Scenario 2: Refining a Model for Accurate Plume Front Tracking** **Scenario 3: Modeling Saltwater Intrusion** **Groundwater Transport Model (`flopy.mf6.ModflowGwt`)**: The `ModflowGwtadv` package cannot exist on its own. It is a component package that must be created and passed into the constructor of a `ModflowGwt` model object. The GWT model is the container for all transport-related processes. **Dispersion Package (`flopy.mf6.mfgwtdsp.ModflowGwtdsp`)**: Advection is only one part of the advection-dispersion equation. The `DSP` package is used to simulate hydrodynamic dispersion and molecular diffusion, which describes the spreading of a plume due to small-scale variations in velocity and random molecular motion. In nearly all practical transport simulations, the `ADV` and `DSP` packages are used together within the same GWT Model. **GWF-GWT Exchange (`flopy.mf6.ModflowGwfgwt`)**: The `ADV` package relies on groundwater flow velocities to calculate solute movement. These velocities are computed by a MODFLOW 6 Groundwater Flow (GWF) Model. The `ModflowGwfgwt` exchange file is the critical link that tells the simulation how to pass the calculated flows from the GWF Model to the GWT Model so they can be used by the `ADV` package. For density-dependent models (like saltwater intrusion), this exchange is two-way, as concentration changes also affect flow.","The `flopy.mf6.modflow.mfgwtadv` Python module is a FloPy wrapper for the **Advection (ADV) Package** of the MODFLOW 6 Groundwater Transport (GWT) Model.

The primary purpose of this module is to configure and solve the advection term of the solute transport equation. Advection is the process by which a dissolved substance (solute) is transported by the bulk movement of flowing groundwater. The velocity of the groundwater, which drives advection, is calculated by the Groundwater Flow (GWF) Model and passed to the GWT Model.

This package is **not a solver** in the same sense as the IMS (Iterative Model Solution) or SMS (Sparse Matrix Solver) packages. Instead, it is a **process package** that defines the numerical method for handling one specific physical process (advection). The GWT Model as a whole is solved using a solution package like IMS, but the `ADV` package dictates *how* the advection component is formulated within the governing equations.

It is a **mandatory package** for any GWT Model simulation. You cannot run a transport simulation in MODFLOW 6 without including and configuring the Advection Package. Its key responsibility is to let the user choose the numerical scheme for solving advection, which has a major impact on model stability and accuracy. The primary user-configurable option is the `scheme`, which can be set to:
-   **UPSTREAM**: A simple, robust, and numerically stable first-order method. It is often used for initial model runs but can introduce significant numerical dispersion (artificial spreading of the plume).
-   **CENTRAL**: A second-order accurate method that reduces numerical dispersion but is prone to non-physical oscillations and instability, especially where sharp concentration fronts exist.
-   **TVD (Total Variation Diminishing)**: A higher-order, computationally more intensive method that provides sharp front tracking (low numerical dispersion) while suppressing the oscillations common to the central-difference scheme. This is often the preferred scheme for accurate plume delineation."
mfgwtapi.py,API,"API mf6 ModflowGwtapi defines a API package.

Parameters
----------
boundnames : keyword
    keyword to indicate that boundary names may be provided with the list of api
    boundary cells.
print_input : keyword
    keyword to indicate that the list of api boundary information will be written
    to the listing file immediately after it is read.
print_flows : keyword
    keyword to indicate that the list of api boundary flow rates will be printed to
    the listing file for every stress period time step The `flopy.mf6.modflow.mfgwtapi` module provides the `ModflowGwtapi` class, which serves a single, crucial purpose: **to enable the MODFLOW 6 Application Programming Interface (API) for a Groundwater Transport (GWT) model.**

This module does **not** define a physical process like advection (`ADV`), dispersion (`DSP`), or source/sink mixing (`SSM`). It is also not a numerical solver like the a preconditioned conjugate-gradient solver (`PCG`). Instead, it acts as a configuration ""switch."" When an instance of the `ModflowGwtapi` class is added to a FloPy GWT model object, FloPy writes a corresponding `API6` entry into that GWT model's name file (`.nam` file).

The MODFLOW 6 API allows a user to interact with a model *while it is running*. By loading the MODFLOW 6 shared library (e.g., `mf6.dll` or `libmf6.so`) into memory, a Python script can:
-   Advance the model one time step at a time.
-   Get pointers to internal model data arrays (e.g., concentration, saturation).
-   Read and **modify** these data arrays in memory between time steps.

Enabling the API for a GWT model is essential for advanced modeling workflows like model coupling, real-time control, and on-the-fly analysis of transport results. **Scenario 1: Adaptive Pump-and-Treat Optimization** **Scenario 2: Coupling with a Complex Geochemical Reaction Model** **Scenario 3: Live Visualization and Progress Monitoring** **`flopy.mf6.modflow.mfgwfapi.ModflowGwfapi`** **`MFSimulation.run_simulation(use_api=True, mf6_lib=...)`** **MODFLOW 6 GWT Model (`flopy.mf6.ModflowGwt`)**","The `flopy.mf6.modflow.mfgwtapi` module provides the `ModflowGwtapi` class, which serves a single, crucial purpose: **to enable the MODFLOW 6 Application Programming Interface (API) for a Groundwater Transport (GWT) model.**

This module does **not** define a physical process like advection (`ADV`), dispersion (`DSP`), or source/sink mixing (`SSM`). It is also not a numerical solver like the a preconditioned conjugate-gradient solver (`PCG`). Instead, it acts as a configuration ""switch."" When an instance of the `ModflowGwtapi` class is added to a FloPy GWT model object, FloPy writes a corresponding `API6` entry into that GWT model's name file (`.nam` file).

The MODFLOW 6 API allows a user to interact with a model *while it is running*. By loading the MODFLOW 6 shared library (e.g., `mf6.dll` or `libmf6.so`) into memory, a Python script can:
-   Advance the model one time step at a time.
-   Get pointers to internal model data arrays (e.g., concentration, saturation).
-   Read and **modify** these data arrays in memory between time steps.

Enabling the API for a GWT model is essential for advanced modeling workflows like model coupling, real-time control, and on-the-fly analysis of transport results."
mfgwtcnc.py,CNC,"CNC mf6 ModflowGwtcnc defines a CNC package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro The `mfgwtcnc.py` module implements the **Constant Concentration (CNC)** package for a MODFLOW 6 Groundwater Transport (GWT) Model. Its primary purpose is to define a boundary condition where the concentration of a dissolved solute is held at a specified, constant value within one or more model cells.

This package acts as a boundary condition for the solute transport equation. It does not solve the equation itself, nor does it define transport processes like advection or dispersion. Conceptually, it is the transport equivalent of the Constant-Head (CHD) package in a Groundwater Flow (GWF) model.

A cell assigned a constant concentration will act as an **infinite source or sink for solute mass**.
- If the concentration in the surrounding aquifer is lower than the specified CNC value, the CNC cell will continuously add mass to the system to maintain its fixed concentration.
- If the concentration in the surrounding aquifer is higher, the CNC cell will continuously remove mass.

This process occurs without creating or destroying water; it only affects the solute mass balance. The CNC package is a component of a GWT model and is almost always used in conjunction with a coupled GWF model that provides the flow field. **Scenario 1: Modeling Saltwater Intrusion** **Scenario 2: Simulating a Persistent Contaminant Source** **Scenario 3: Analyzing a Controlled Tracer Test** **GWT Model (`flopy.mf6.ModflowGwt`)**: The CNC package is a child of the GWT Model. A GWT model must be created first before a CNC package can be added. The GWT model is the overarching container for all transport-related packages. **GWF-GWT Exchange (`flopy.mf6.ModflowGwfgwt`)**: Solute transport is driven by groundwater flow. The GWT model (containing CNC) must be coupled to a GWF (Groundwater Flow) model. This exchange file facilitates the passing of cell-by-cell flow rates from the GWF solution to the GWT model, which are then used to calculate advective transport. Without this link, the transport simulation has no flow field to operate on. **Transport Process Packages (ADV, DSP, MST)**: For a transport simulation to be complete, the physical processes governing transport must be defined. The CNC package only sets a boundary condition. It must be used alongside the Advection (`ADV`), Dispersion (`DSP`), and Mass Storage (`MST` - which also handles sources/sinks) packages to form a complete and solvable transport equation. **Source/Sink Mixing Package (`SSM`)**: The SSM package is used to define the concentration of water entering the aquifer from flow packages like Wells (`WEL`), Recharge (`RCH`), or Rivers (`RIV`). It is crucial to distinguish its use from CNC. Use CNC for boundaries where concentration is fixed regardless of flow (like an ocean). Use SSM to define the concentration *of the source water* (e.g., the concentration of injected water in a well or infiltrating water from recharge).","The `mfgwtcnc.py` module implements the **Constant Concentration (CNC)** package for a MODFLOW 6 Groundwater Transport (GWT) Model. Its primary purpose is to define a boundary condition where the concentration of a dissolved solute is held at a specified, constant value within one or more model cells.

This package acts as a boundary condition for the solute transport equation. It does not solve the equation itself, nor does it define transport processes like advection or dispersion. Conceptually, it is the transport equivalent of the Constant-Head (CHD) package in a Groundwater Flow (GWF) model.

A cell assigned a constant concentration will act as an **infinite source or sink for solute mass**.
- If the concentration in the surrounding aquifer is lower than the specified CNC value, the CNC cell will continuously add mass to the system to maintain its fixed concentration.
- If the concentration in the surrounding aquifer is higher, the CNC cell will continuously remove mass.

This process occurs without creating or destroying water; it only affects the solute mass balance. The CNC package is a component of a GWT model and is almost always used in conjunction with a coupled GWF model that provides the flow field."
mfgwtdis.py,DIS,"DIS mf6 ModflowGwtdis defines a DIS package.

Parameters
----------
length_units : string
    is the length units used for this model.  values can be 'feet', 'meters', or
    'centimeters'.  if not specified, the default is 'unknown'.
nogrb : keyword
    keyword to deactivate writing of the binary grid file.
grb_filerecord : (grb6_filename)
    * grb6_filename : string
            defines a binary grid output file. If this option is not provided, the output
            file will have the same name as th The `mfgwtdis.py` module implements the **Discretization (DIS) Package** for a **MODFLOW 6 Groundwater Transport (GWT) Model**. Its fundamental purpose is to define the spatial framework—the grid—for a transport simulation.

This is a ""package"" module, not a ""solver."" It does not solve the transport equations but rather provides the foundational grid upon which the simulation is built. Specifically, it defines a **structured, finite-difference grid** composed of layers, rows, and columns.

Key responsibilities of this package include:

*   **Grid Dimensions:** Defining the number of layers (`nlay`), rows (`nrow`), and columns (`ncol`).
*   **Cell Dimensions:** Specifying horizontal cell sizes with `delr` (column widths) and `delc` (row widths).
*   **Vertical Discretization:** Setting the elevation of the model top (`top`) and the bottom elevation of each model layer (`botm`).
*   **Spatial Reference:** Optionally defining the model grid's origin (`xorigin`, `yorigin`) and rotation (`angrot`) in a real-world coordinate system.
*   **Domain Activity:** Defining which cells are active (`idomain > 0`), inactive (`idomain = 0`), or have fixed concentrations (`idomain < 0`) for the transport simulation.

A crucial distinction is that this package is for the **GWT Model**, not the Groundwater Flow (GWF) Model. While a GWF model *always* requires its own discretization package (e.g., `mfgwfdis`), a GWT model often **does not**. In a typical coupled GWF-GWT simulation, the GWT model inherits the grid from the GWF model via the GWF-GWT Exchange (`mfgwfgwt`). Therefore, `mfgwtdis` is used primarily for **standalone GWT models**. **Scenario 1: Simulating Transport in a Pre-defined Flow Field** **Scenario 2: Analytical Solution Benchmarking** **Scenario 3: Modeling Transport Using Externally-Calculated Flows** **GWF Discretization (`mfgwfdis`)** **GWF-GWT Exchange (`mfgwfgwt`)** **Standalone vs. Coupled Models** **DISV and DISU Packages (`mfgwtdisv`, `mfgwtdisu`)**","The `mfgwtdis.py` module implements the **Discretization (DIS) Package** for a **MODFLOW 6 Groundwater Transport (GWT) Model**. Its fundamental purpose is to define the spatial framework—the grid—for a transport simulation.

This is a ""package"" module, not a ""solver."" It does not solve the transport equations but rather provides the foundational grid upon which the simulation is built. Specifically, it defines a **structured, finite-difference grid** composed of layers, rows, and columns.

Key responsibilities of this package include:

*   **Grid Dimensions:** Defining the number of layers (`nlay`), rows (`nrow`), and columns (`ncol`).
*   **Cell Dimensions:** Specifying horizontal cell sizes with `delr` (column widths) and `delc` (row widths).
*   **Vertical Discretization:** Setting the elevation of the model top (`top`) and the bottom elevation of each model layer (`botm`).
*   **Spatial Reference:** Optionally defining the model grid's origin (`xorigin`, `yorigin`) and rotation (`angrot`) in a real-world coordinate system.
*   **Domain Activity:** Defining which cells are active (`idomain > 0`), inactive (`idomain = 0`), or have fixed concentrations (`idomain < 0`) for the transport simulation.

A crucial distinction is that this package is for the **GWT Model**, not the Groundwater Flow (GWF) Model. While a GWF model *always* requires its own discretization package (e.g., `mfgwfdis`), a GWT model often **does not**. In a typical coupled GWF-GWT simulation, the GWT model inherits the grid from the GWF model via the GWF-GWT Exchange (`mfgwfgwt`). Therefore, `mfgwtdis` is used primarily for **standalone GWT models**."
mfgwtdisu.py,DISU,"DISU mf6 ModflowGwtdisu defines a DISU package.

Parameters
----------
length_units : string
    is the length units used for this model.  values can be 'feet', 'meters', or
    'centimeters'.  if not specified, the default is 'unknown'.
nogrb : keyword
    keyword to deactivate writing of the binary grid file.
grb_filerecord : (grb6_filename)
    * grb6_filename : string
            defines a binary grid output file. If this option is not provided, the output
            file will have the same name as  The `flopy.mf6.modflow.mfgwtdisu` module serves a single, critical purpose: **to define the unstructured spatial grid for a MODFLOW 6 Groundwater Transport (GWT) Model.**

This module implements the **Unstructured Discretization (DISU)** package for the GWT model. It is not a solver (like IMS) or a boundary condition package (like CNC). Instead, it's a foundational package that defines the model domain's geometry and connectivity. It specifies:

*   **Nodes/Cells:** The number of model cells (`nodes`).
*   **Connectivity:** How each cell is connected to its neighbors. For unstructured grids, this is defined by the `nja` (number of connections), `ihc` (connectivity array), and `ja` (connection array) parameters.
*   **Geometry:** The physical dimensions of each cell, including its top elevation (`top`), bottom elevation (`botm`), and horizontal area (`area`).
*   **Domain Status:** Which cells are active, inactive, or have a specified concentration, defined by the `idomain` array.

Crucially, this `DISU` package belongs to the **GWT Model**, not the Groundwater Flow (GWF) Model. In MODFLOW 6, the flow and transport simulations are treated as separate models that are coupled together. While the GWT model almost always uses the same grid as the corresponding GWF model, it must have its own discretization package defined. This module provides the FloPy class `ModflowGwtdisu` to create that package for the GWT model. **Scenario 1: Simulating Contaminant Transport Along Complex Geological Features** **Scenario 2: Refining the Grid Around Sources and Receptors** **Scenario 3: Integrating with Surface Water or Geomechanical Models** **`mfgwfdisu` (GWF Unstructured Discretization):** This is the direct counterpart to `mfgwtdisu` for the Groundwater Flow (GWF) model. A functioning GWT simulation almost always requires a companion GWF model to provide the flow field (cell-by-cell fluxes). The grid defined in `mfgwfdisu` and `mfgwtdisu` must be identical in terms of cell count, connectivity, and geometry for the models to couple correctly. **MODFLOW 6 GWT Model (`flopy.mf6.ModflowGwt`):** The `ModflowGwtdisu` object is a package that is added to a parent `ModflowGwt` model object. The GWT model is the container for all transport-related packages, such as advection (ADV), dispersion (DSP), source/sink mixing (SSM), and mobile storage (MST). **Grid Generation Utilities (`flopy.utils.gridgen`, `flopy.utils.triangle`, external meshers):** FloPy itself is not a primary mesh generation tool for complex unstructured grids. Users typically generate the necessary grid information (vertices, cell definitions, connectivity) using external programs like Gmsh or specialized FloPy utilities like `Gridgen` (for quadtree refinement) or the `Triangle` and `Voronoi` utilities. The output from these tools (e.g., `cell2d`, `ivc`, `ja`) is then passed directly into the `ModflowGwtdisu` constructor.","The `flopy.mf6.modflow.mfgwtdisu` module serves a single, critical purpose: **to define the unstructured spatial grid for a MODFLOW 6 Groundwater Transport (GWT) Model.**

This module implements the **Unstructured Discretization (DISU)** package for the GWT model. It is not a solver (like IMS) or a boundary condition package (like CNC). Instead, it's a foundational package that defines the model domain's geometry and connectivity. It specifies:

*   **Nodes/Cells:** The number of model cells (`nodes`).
*   **Connectivity:** How each cell is connected to its neighbors. For unstructured grids, this is defined by the `nja` (number of connections), `ihc` (connectivity array), and `ja` (connection array) parameters.
*   **Geometry:** The physical dimensions of each cell, including its top elevation (`top`), bottom elevation (`botm`), and horizontal area (`area`).
*   **Domain Status:** Which cells are active, inactive, or have a specified concentration, defined by the `idomain` array.

Crucially, this `DISU` package belongs to the **GWT Model**, not the Groundwater Flow (GWF) Model. In MODFLOW 6, the flow and transport simulations are treated as separate models that are coupled together. While the GWT model almost always uses the same grid as the corresponding GWF model, it must have its own discretization package defined. This module provides the FloPy class `ModflowGwtdisu` to create that package for the GWT model."
mfgwtdisv.py,DISV,"DISV mf6 ModflowGwtdisv defines a DISV package.

Parameters
----------
length_units : string
    is the length units used for this model.  values can be 'feet', 'meters', or
    'centimeters'.  if not specified, the default is 'unknown'.
nogrb : keyword
    keyword to deactivate writing of the binary grid file.
grb_filerecord : (grb6_filename)
    * grb6_filename : string
            defines a binary grid output file. If this option is not provided, the output
            file will have the same name as  The `flopy.mf6.modflow.mfgwtdisv` module serves a single, fundamental purpose: to define the **spatial and vertical discretization** for a **MODFLOW 6 Groundwater Transport (GWT) Model** using an **unstructured grid**.

Breaking this down:

*   **MODFLOW 6 (mf6):** This module is exclusively for the modern, restructured version of MODFLOW. It does not apply to MODFLOW-2005 or earlier versions.
*   **Groundwater Transport (GWT) Model:** In MODFLOW 6, groundwater flow (GWF Model) and solute transport (GWT Model) are simulated by separate, but coupled, models. This `mfgwtdisv` module belongs specifically to the GWT Model, defining the grid on which contaminant concentrations and other transport properties are calculated.
*   **Discretization by Vertices (DISV):** This is the key. The `DISV` package defines an unstructured grid where model cells can be irregular polygons (e.g., triangles, quadrilaterals, Voronoi cells). This is in contrast to the traditional structured `DIS` package, which only allows for rectangular cells. The `DISV` package defines the model mesh using vertices and a connectivity array that specifies which vertices form each cell.
*   **Not a Solver or Boundary Condition:** This module is a **discretization package**. It is the foundational framework that defines the model's geometry. It is not a numerical solver (like `IMS`), a flow package (like `NPF`), or a boundary condition package (like `CHD` or `CNC`). All other packages in the GWT model rely on the grid defined by `DISV`.

In essence, `mfgwtdisv` is the blueprint for the transport model's computational mesh, specifying the number of layers, the shape and location of every cell, and their top and bottom elevations. **Scenario 1: Modeling Contaminant Transport Along a Meandering River** **Scenario 2: Saltwater Intrusion with Targeted Grid Refinement** **Scenario 3: Simulating Transport in a Faulted Aquifer System** **Grid Generation Software (e.g., Gridgen, pygridgen, Gmsh):** You almost never create a `DISV` grid's vertex and connectivity data by hand. A user must rely on external meshing software. A typical workflow involves creating the conceptual model geometry (e.g., from shapefiles) in a tool like QGIS, using a meshing utility (like `pygridgen` in Python or a standalone program like `Gridgen`) to generate the vertices and cell definitions, and then feeding this information into the `ModflowGwtdisv` class. **GWF-GWT Exchange:** Since the GWT model simulates transport, it requires flow velocities from a corresponding GWF (Groundwater Flow) model. In MODFLOW 6, this is handled by a `GWF-GWT` Exchange file. A critical requirement is that the `DISV` grid defined for the GWT model must be **identical** to the `DISV` grid used in the coupled GWF model. FloPy facilitates this by allowing the user to create one set of grid data and pass it to both the `mfgwfdisv` and `mfgwtdisv` package constructors. **`flopy.discretization.VertexGrid`:** This is a key FloPy class for working with `DISV` (and `DISU`) grids. Once you have your grid information, you can instantiate a `VertexGrid` object. This object provides powerful methods for inspecting the grid (`grid.is_valid`), checking for errors (`grid.check()`), and, most importantly, plotting the grid (`grid.plot()`) to visually confirm it's correct before running the simulation. This is an indispensable tool for debugging unstructured grids.","The `flopy.mf6.modflow.mfgwtdisv` module serves a single, fundamental purpose: to define the **spatial and vertical discretization** for a **MODFLOW 6 Groundwater Transport (GWT) Model** using an **unstructured grid**.

Breaking this down:

*   **MODFLOW 6 (mf6):** This module is exclusively for the modern, restructured version of MODFLOW. It does not apply to MODFLOW-2005 or earlier versions.
*   **Groundwater Transport (GWT) Model:** In MODFLOW 6, groundwater flow (GWF Model) and solute transport (GWT Model) are simulated by separate, but coupled, models. This `mfgwtdisv` module belongs specifically to the GWT Model, defining the grid on which contaminant concentrations and other transport properties are calculated.
*   **Discretization by Vertices (DISV):** This is the key. The `DISV` package defines an unstructured grid where model cells can be irregular polygons (e.g., triangles, quadrilaterals, Voronoi cells). This is in contrast to the traditional structured `DIS` package, which only allows for rectangular cells. The `DISV` package defines the model mesh using vertices and a connectivity array that specifies which vertices form each cell.
*   **Not a Solver or Boundary Condition:** This module is a **discretization package**. It is the foundational framework that defines the model's geometry. It is not a numerical solver (like `IMS`), a flow package (like `NPF`), or a boundary condition package (like `CHD` or `CNC`). All other packages in the GWT model rely on the grid defined by `DISV`.

In essence, `mfgwtdisv` is the blueprint for the transport model's computational mesh, specifying the number of layers, the shape and location of every cell, and their top and bottom elevations."
mfgwtdsp.py,DSP,"DSP mf6 ModflowGwtdsp defines a DSP package.

Parameters
----------
xt3d_off : keyword
    deactivate the xt3d method and use the faster and less accurate approximation.
    this option may provide a fast and accurate solution under some circumstances,
    such as when flow aligns with the model grid, there is no mechanical
    dispersion, or when the longitudinal and transverse dispersivities are equal.
    this option may also be used to assess the computational demand of the xt3d
    approach by noti The `mfgwtdsp.py` module provides the FloPy interface for the **Dispersion (DSP) Package** of the MODFLOW 6 Groundwater Transport (GWT) Model. The primary purpose of this module is to define the parameters that govern how a solute plume spreads out as it moves through an aquifer. This spreading phenomenon is a combination of two processes:

1.  **Mechanical Dispersion:** The spreading of solutes caused by variations in groundwater velocity at the microscopic (pore) scale and macroscopic (heterogeneity) scale. Faster flow paths cause some solute particles to move ahead, while slower paths cause others to lag behind, resulting in plume elongation.
2.  **Molecular Diffusion:** The random thermal motion of solute molecules, which causes them to spread from areas of high concentration to low concentration, even in stationary water.

This module is a **process package**, not a solver or a boundary condition. It works in concert with the Advection (ADV) package to solve the Advection-Dispersion equation, which is the fundamental governing equation for solute transport. Specifically, it allows the user to define the following key physical properties of the aquifer system:

*   **`al`**: Longitudinal dispersivity, which controls spreading in the principal direction of flow.
*   **`ath1`**: Transverse horizontal dispersivity, controlling spreading perpendicular to flow in the horizontal plane.
*   **`ath2`**: Transverse vertical dispersivity, controlling spreading perpendicular to flow in the vertical direction.
*   **`dmcoef`**: The effective molecular diffusion coefficient.

These parameters can be defined as single values for a homogeneous system or as 3D arrays to represent spatial heterogeneity. **Scenario 1: Simulating a Contaminant Plume** **Scenario 2: Modeling Saltwater Intrusion in Coastal Aquifers** **Scenario 3: Calibrating Aquifer Properties with a Tracer Test** **GWT Model (Groundwater Transport Model)** **ADV Package (Advection)** **SSM Package (Source-Sink Mixing)**","The `mfgwtdsp.py` module provides the FloPy interface for the **Dispersion (DSP) Package** of the MODFLOW 6 Groundwater Transport (GWT) Model. The primary purpose of this module is to define the parameters that govern how a solute plume spreads out as it moves through an aquifer. This spreading phenomenon is a combination of two processes:

1.  **Mechanical Dispersion:** The spreading of solutes caused by variations in groundwater velocity at the microscopic (pore) scale and macroscopic (heterogeneity) scale. Faster flow paths cause some solute particles to move ahead, while slower paths cause others to lag behind, resulting in plume elongation.
2.  **Molecular Diffusion:** The random thermal motion of solute molecules, which causes them to spread from areas of high concentration to low concentration, even in stationary water.

This module is a **process package**, not a solver or a boundary condition. It works in concert with the Advection (ADV) package to solve the Advection-Dispersion equation, which is the fundamental governing equation for solute transport. Specifically, it allows the user to define the following key physical properties of the aquifer system:

*   **`al`**: Longitudinal dispersivity, which controls spreading in the principal direction of flow.
*   **`ath1`**: Transverse horizontal dispersivity, controlling spreading perpendicular to flow in the horizontal plane.
*   **`ath2`**: Transverse vertical dispersivity, controlling spreading perpendicular to flow in the vertical direction.
*   **`dmcoef`**: The effective molecular diffusion coefficient.

These parameters can be defined as single values for a homogeneous system or as 3D arrays to represent spatial heterogeneity."
mfgwtfmi.py,FMI,"FMI mf6 ModflowGwtfmi defines a FMI package.

Parameters
----------
save_flows : keyword
    keyword to indicate that fmi flow terms will be written to the file specified
    with 'budget fileout' in output control.
flow_imbalance_correction : keyword
    correct for an imbalance in flows by assuming that any residual flow error
    comes in or leaves at the concentration of the cell.  when this option is
    activated, the gwt model budget written to the listing file will contain two
    additional ent The `mfgwtfmi` module implements the **Flow Model Interface (FMI)** package for a MODFLOW 6 Groundwater Transport (GWT) model. Its sole purpose is to act as a ""connector"" or ""linker"" that tells a GWT model where to get the necessary flow information to perform a transport simulation.

In MODFLOW 6's modular structure, a flow simulation (GWF Model) and a transport simulation (GWT Model) are distinct models, even when run together. The GWT model needs to know the cell-by-cell flow rates calculated by the GWF model to solve the advection part of the advection-dispersion equation.

The FMI package is the mechanism within the GWT model that formally declares this dependency. It essentially says, ""This transport model requires flow data from a groundwater flow model."" It does not define any physical processes like advection (`ADV`), dispersion (`DSP`), or chemical reactions. It is a structural package required for any coupled GWF-GWT simulation. Without it, the GWT model would be isolated and unable to simulate the movement of solutes. **Scenario 1: Predicting a Contaminant Plume** **Scenario 2: Simulating Saltwater Intrusion in a Coastal Aquifer** **Scenario 3: Evaluating a Managed Aquifer Recharge (MAR) System** **Groundwater Transport (GWT) Model (`flopy.mf6.ModflowGwt`)** **GWF-GWT Exchange (`flopy.mf6.ModflowGwfgwt`)** **Groundwater Flow (GWF) Model (`flopy.mf6.ModflowGwf`)**","The `mfgwtfmi` module implements the **Flow Model Interface (FMI)** package for a MODFLOW 6 Groundwater Transport (GWT) model. Its sole purpose is to act as a ""connector"" or ""linker"" that tells a GWT model where to get the necessary flow information to perform a transport simulation.

In MODFLOW 6's modular structure, a flow simulation (GWF Model) and a transport simulation (GWT Model) are distinct models, even when run together. The GWT model needs to know the cell-by-cell flow rates calculated by the GWF model to solve the advection part of the advection-dispersion equation.

The FMI package is the mechanism within the GWT model that formally declares this dependency. It essentially says, ""This transport model requires flow data from a groundwater flow model."" It does not define any physical processes like advection (`ADV`), dispersion (`DSP`), or chemical reactions. It is a structural package required for any coupled GWF-GWT simulation. Without it, the GWT model would be isolated and unable to simulate the movement of solutes."
mfgwtgwt.py,GWT,"GWT mf6 ModflowGwtgwt defines a GWTGWT package.

Parameters
----------
gwfmodelname1 : string
    keyword to specify name of first corresponding gwf model.  in the simulation
    name file, the gwt6-gwt6 entry contains names for gwt models (exgmnamea and
    exgmnameb).  the gwt model with the name exgmnamea must correspond to the gwf
    model with the name gwfmodelname1.
gwfmodelname2 : string
    keyword to specify name of second corresponding gwf model.  in the simulation
    name file, the gwt6-gwt The `flopy.mf6.modflow.mfgwtgwt` module implements the **MODFLOW 6 GWT-GWT Exchange**. This is not a standalone modeling package but rather a **coupling package** used at the simulation level. Its specific purpose is to simulate the transfer of solute mass between two separate Groundwater Transport (GWT) models that exist within the same MODFLOW 6 simulation.

This exchange is critical for building complex, multi-model simulations where different parts of the study area are represented by distinct model grids. The GWT-GWT exchange defines the physical connections between cells in the first GWT model and cells in the second GWT model. MODFLOW 6 then calculates the solute mass flux between these connected cells based on concentration gradients (diffusion/dispersion) and, crucially, the water flux provided by a corresponding GWF-GWF Exchange.

In essence, this module tells MODFLOW 6: ""Take the solute from cell (i,j,k) in GWT Model 1 and move it to/from cell (l,m,n) in GWT Model 2."" It generates the `gwt-gwt.dat` input file for the simulation.

It is distinct from:
*   **Solver Packages (e.g., IMS, SMS):** It does not solve the system of linear equations. The solver is defined separately and solves the combined equations for all coupled models.
*   **Process Packages (e.g., ADV, DSP, MST):** It does not simulate a physical process *within* a single model. Instead, it facilitates the interaction *between* two models.
*   **Boundary Condition Packages (e.g., CNC, SRC):** It does not represent an external source/sink of solute to the simulation domain. It represents an internal transfer of mass already within the simulation. **Scenario 1: Local-Scale Refinement (Telescopic Mesh Refinement)** **Scenario 2: Coupling Models Across a Management Boundary** **Scenario 3: Simulating Transport in Distinct Hydrogeologic Units** **`flopy.mf6.modflow.ModflowGwt` (GWT Model)** **`flopy.mf6.modflow.mfgwfgwf` (GWF-GWF Exchange)** **`flopy.mf6.MFSimulation` (MODFLOW Simulation Object)**","The `flopy.mf6.modflow.mfgwtgwt` module implements the **MODFLOW 6 GWT-GWT Exchange**. This is not a standalone modeling package but rather a **coupling package** used at the simulation level. Its specific purpose is to simulate the transfer of solute mass between two separate Groundwater Transport (GWT) models that exist within the same MODFLOW 6 simulation.

This exchange is critical for building complex, multi-model simulations where different parts of the study area are represented by distinct model grids. The GWT-GWT exchange defines the physical connections between cells in the first GWT model and cells in the second GWT model. MODFLOW 6 then calculates the solute mass flux between these connected cells based on concentration gradients (diffusion/dispersion) and, crucially, the water flux provided by a corresponding GWF-GWF Exchange.

In essence, this module tells MODFLOW 6: ""Take the solute from cell (i,j,k) in GWT Model 1 and move it to/from cell (l,m,n) in GWT Model 2."" It generates the `gwt-gwt.dat` input file for the simulation.

It is distinct from:
*   **Solver Packages (e.g., IMS, SMS):** It does not solve the system of linear equations. The solver is defined separately and solves the combined equations for all coupled models.
*   **Process Packages (e.g., ADV, DSP, MST):** It does not simulate a physical process *within* a single model. Instead, it facilitates the interaction *between* two models.
*   **Boundary Condition Packages (e.g., CNC, SRC):** It does not represent an external source/sink of solute to the simulation domain. It represents an internal transfer of mass already within the simulation."
mfgwtic.py,ic,"mf6 ModflowGwtic defines a IC package.

Parameters
----------
export_array_ascii : keyword
    keyword that specifies input griddata arrays should be written to layered ascii
    output files.
export_array_netcdf : keyword
    keyword that specifies input griddata arrays should be written to the model
    output netcdf file.
strt : [double precision]
    is the initial (starting) concentration---that is, concentration at the
    beginning of the gwt model simulation.  strt must be specified for all  This module, `mfgwtic.py`, is designed to construct the **Initial Conditions (IC) Package** for a **MODFLOW 6 Groundwater Transport (GWT) Model**. Its sole purpose is to define the starting concentration of a simulated solute for every active cell in the model domain at time zero.

The package code for this component within the MODFLOW 6 framework is **`ic`**.

To be precise:
- **Model:** MODFLOW 6
- **Simulation Component:** Groundwater Transport (GWT)
- **Package:** Initial Conditions (IC)
- **Core Function:** It specifies the initial mass-per-volume concentration (e.g., mg/L or kg/m³) or temperature for heat transport simulations. It sets the value for the `strt` variable in the GWT simulation.

This package is **not a solver**. It does not compute any part of the transport solution. It is also distinct from:
- **Flow Initial Conditions (`mfgwfic`):** That package sets the initial hydraulic heads for the Groundwater Flow (GWF) Model. This module (`mfgwtic`) sets initial concentrations for the GWT Model.
- **Boundary Conditions (`mfgwtcnc`, `mfgwtsrc`):** Boundary conditions define how solute mass enters or leaves the model *during* the simulation. The IC package only defines the state at the very beginning (`t=0`).

Every transient GWT simulation requires this package to establish the baseline from which all subsequent transport calculations will proceed. **Scenario 1: Simulating the migration of a known, existing contaminant plume.** **Description:** An industrial site has been leaking a solvent for years, and a contaminant plume has already formed in the underlying aquifer. The goal is to predict the plume's future movement. The hydrologist has monitoring well data showing the current extent and concentration of the plume. They would use a geostatistical method (like kriging) to interpolate these data points onto the model grid, creating a 3D NumPy array of initial concentrations. This array is then passed as the `strt` argument to `ModflowGwtic` to represent the known, present-day contamination as the starting point for the predictive simulation. **Scenario 2: Modeling a potential future contamination event in a pristine aquifer.** **Description:** A hydrogeologist is assessing the risk of a proposed new landfill or injection well. The native groundwater is clean, with background concentrations of the contaminant of concern being effectively zero. In this case, the initial condition is simple: the concentration is zero everywhere. The user would instantiate `ModflowGwtic` with `strt=0.0`. This sets a clean baseline. The contamination itself would then be introduced into the simulation using a boundary condition package, such as the Source/Sink Mixing (SRC) package to represent a leaking landfill cell. **Scenario 3: Modeling saltwater intrusion in a coastal aquifer.** **Description:** A model is being built to manage pumping in a coastal aquifer to prevent further seawater intrusion. The current position of the freshwater-saltwater interface is known approximately from well salinity logs or geophysical surveys. The hydrologist would create a 3D `strt` array where cells on the landward, freshwater side are assigned a concentration of 0 (or total dissolved solids equivalent), cells on the seaward, saltwater side are assigned a concentration of 35 (representing 35,000 ppm or 35 kg/m³ for seawater), and cells in the transition zone are given intermediate values. This complex initial state, defined via `ModflowGwtic`, is critical for accurately simulating how the interface will advance or retreat in response to management actions. **Related Concept 1: The GWT Model (`flopy.mf6.ModflowGwt`)** The `ModflowGwtic` object is a required child package of the parent `ModflowGwt` object. You instantiate the GWT model first and then create and attach the IC package to it. The GWT model is the container for all transport-related packages (advection, dispersion, sources/sinks, etc.). **Related Concept 2: GWT Boundary and Source/Sink Packages** While IC sets the stage, the simulation's evolution depends on packages that add or remove mass. The most common is the **Source/Sink Mixing Package (`mfgwtsrc`)**, which defines the concentration of water entering the GWT domain from flow packages (e.g., the concentration of recharge water, river leakage, or injected water from a well). Another is the **Constant Concentration Package (`mfgwtcnc`)**, used to fix the concentration in specific cells, such as at a boundary with a large contaminated lake. **Related Concept 3: The GWF-GWT Exchange (`flopy.mf6.ModflowGwfgwt`)** This is the critical link between the flow and transport models. Solutes are transported by moving groundwater (advection). The GWF-GWT Exchange takes the cell-by-cell flow budgets calculated by the GWF Model and provides them to the GWT Model so it can calculate the advective movement of the solute. Without this exchange, the solute would only move by diffusion, and the simulation would be physically incorrect.","This module, `mfgwtic.py`, is designed to construct the **Initial Conditions (IC) Package** for a **MODFLOW 6 Groundwater Transport (GWT) Model**. Its sole purpose is to define the starting concentration of a simulated solute for every active cell in the model domain at time zero.

The package code for this component within the MODFLOW 6 framework is **`ic`**.

To be precise:
- **Model:** MODFLOW 6
- **Simulation Component:** Groundwater Transport (GWT)
- **Package:** Initial Conditions (IC)
- **Core Function:** It specifies the initial mass-per-volume concentration (e.g., mg/L or kg/m³) or temperature for heat transport simulations. It sets the value for the `strt` variable in the GWT simulation.

This package is **not a solver**. It does not compute any part of the transport solution. It is also distinct from:
- **Flow Initial Conditions (`mfgwfic`):** That package sets the initial hydraulic heads for the Groundwater Flow (GWF) Model. This module (`mfgwtic`) sets initial concentrations for the GWT Model.
- **Boundary Conditions (`mfgwtcnc`, `mfgwtsrc`):** Boundary conditions define how solute mass enters or leaves the model *during* the simulation. The IC package only defines the state at the very beginning (`t=0`).

Every transient GWT simulation requires this package to establish the baseline from which all subsequent transport calculations will proceed."
mfgwtist.py,IST,"IST mf6 ModflowGwtist defines a IST package.

Parameters
----------
save_flows : keyword
    keyword to indicate that ist flow terms will be written to the file specified
    with 'budget fileout' in output control.
budget_filerecord : (budgetfile)
    * budgetfile : string
            name of the binary output file to write budget information.

budgetcsv_filerecord : (budgetcsvfile)
    * budgetcsvfile : string
            name of the comma-separated value (CSV) output file to write budget summary
     The `flopy.mf6.modflow.mfgwtist` module provides the Python interface for creating and managing the **Immiscible-Brine Transport (IST) Package** for a MODFLOW 6 **Groundwater Transport (GWT) Model**.

The primary purpose of the IST package is to simulate **variable-density groundwater flow** where the fluid density is a function of solute concentration. It is the standard method in MODFLOW 6 for tackling problems like **saltwater intrusion**, brine migration, or the movement of any solute that significantly impacts water density.

Despite the name ""Immiscible-Brine,"" the package simulates the transport of a solute that is fully **miscible** with water. The name refers to the specific mathematical formulation, which treats the system as if it were composed of two fluids: native freshwater and a reference-concentration brine. The model then solves for the fractional concentration of the reference brine throughout the domain.

Key functions of the IST package include:
*   Defining the properties of the ""freshwater"" and ""brine"" components, such as their respective densities (`DENSES` and `DENSER`) and the reference brine concentration (`CBRINE`).
*   Assigning solute concentrations to sources and sinks that are defined in the Groundwater Flow (GWF) Model. For example, it specifies the concentration of water entering the model via a recharge (`RCH`) boundary or being injected through a well (`WEL`).
*   Working in tandem with the **Buoyancy (BUY) Package** to couple the GWT model results (concentration-derived density) back to the GWF model, creating a fully linked simulation of flow and transport. **Scenario 1: Coastal Aquifer Management** **Scenario 2: Brine Plume Migration from Industrial Sources** **Scenario 3: Evaluating a Desalination Plant's Brine Discharge** **Groundwater Transport (GWT) Model (`ModflowGwt`)** **Buoyancy (BUY) Package (`mfbuy`)** **Flow-Transport Exchanges (GWF-GWT)** **Source and Sink Packages (`WEL`, `DRN`, `RCH`, `EVT`, `SFR`, etc.)**","The `flopy.mf6.modflow.mfgwtist` module provides the Python interface for creating and managing the **Immiscible-Brine Transport (IST) Package** for a MODFLOW 6 **Groundwater Transport (GWT) Model**.

The primary purpose of the IST package is to simulate **variable-density groundwater flow** where the fluid density is a function of solute concentration. It is the standard method in MODFLOW 6 for tackling problems like **saltwater intrusion**, brine migration, or the movement of any solute that significantly impacts water density.

Despite the name ""Immiscible-Brine,"" the package simulates the transport of a solute that is fully **miscible** with water. The name refers to the specific mathematical formulation, which treats the system as if it were composed of two fluids: native freshwater and a reference-concentration brine. The model then solves for the fractional concentration of the reference brine throughout the domain.

Key functions of the IST package include:
*   Defining the properties of the ""freshwater"" and ""brine"" components, such as their respective densities (`DENSES` and `DENSER`) and the reference brine concentration (`CBRINE`).
*   Assigning solute concentrations to sources and sinks that are defined in the Groundwater Flow (GWF) Model. For example, it specifies the concentration of water entering the model via a recharge (`RCH`) boundary or being injected through a well (`WEL`).
*   Working in tandem with the **Buoyancy (BUY) Package** to couple the GWT model results (concentration-derived density) back to the GWF model, creating a fully linked simulation of flow and transport."
mfgwtlkt.py,LKT,"LKT mf6 ModflowGwtlkt defines a LKT package.

Parameters
----------
flow_package_name : string
    keyword to specify the name of the corresponding flow package.  if not
    specified, then the corresponding flow package must have the same name as this
    advanced transport package (the name associated with this package in the gwt
    name file).
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be pro The `flopy.mf6.modflow.mfgwtlkt` module serves as the FloPy interface for the **Lake Transport (LKT)** package in a MODFLOW 6 **Groundwater Transport (GWT) Model**. Its primary purpose is to simulate the concentration of a dissolved chemical species (solute) within a lake that is hydraulically connected to the groundwater system.

This module does **not** simulate water flow; it exclusively handles solute transport. It is a process package, analogous to how the Unsaturated Zone Flow (UZF) package defines a flow process. The LKT package relies entirely on the flow budget (inflows, outflows, and stage) calculated by the **Lake (LAK) package** in a corresponding Groundwater Flow (GWF) Model.

Specifically, the LKT package accounts for:
*   **Advective Transport:** Solute movement into and out of the lake via groundwater seepage, connected streams, precipitation, and surface runoff.
*   **Source/Sink Concentrations:** Assigning solute concentrations to external water sources entering the lake, such as rain or streamflow.
*   **Lake Concentration:** Simulating the fully-mixed concentration of the solute within the lake volume over time.
*   **Diffusive Transport:** Simulating molecular diffusion between the lake water and the underlying groundwater at the lakebed.

In summary, if you are modeling solute transport (e.g., a contaminant plume) in a system that includes a lake, the LKT package is essential for representing how the lake interacts with and affects the transport process. **Scenario 1: Assessing Contaminant Impact on a Recreational Lake** **Scenario 2: Modeling Nutrient Loading from Agricultural Runoff** **Scenario 3: Simulating Salinity Dynamics in a Coastal Lake** **GWF Lake (LAK) Package (`flopy.mf6.ModflowGwfLak`)**: This is the most critical dependency. The LKT package is meaningless without a corresponding LAK package in the GWF model. The LAK package computes the water budget (flows and stage) for the lake, which the LKT package uses to compute the solute mass budget. The `flow_package_object` argument in the LKT constructor must be linked to the GWF LAK object. **Groundwater Transport (GWT) Model (`flopy.mf6.ModflowGwt`)**: The LKT package is a component of a GWT model. It cannot be used in isolation or within a GWF model directly. It operates alongside other GWT packages to form a complete transport simulation. **Source Sink Mixing (SSM) Package (`flopy.mf6.ModflowGwtSsm`)**: While the LKT package handles concentrations for sources entering the lake itself (like rain), the SSM package is used to specify the concentration of sources/sinks entering the *aquifer* (e.g., a contaminated injection well). The SSM package tells the GWT model the concentration of water entering the simulation domain, which might then flow towards a lake. **Streamflow Routing (SFR) Package (`flopy.mf6.ModflowGwfSfr`)**: If a stream flows into or out of the lake, its flow dynamics are handled by the SFR package in the GWF model. The LKT package allows you to specify a concentration for the stream water that enters the lake, thereby simulating the advective transport of solutes from the stream into the lake.","The `flopy.mf6.modflow.mfgwtlkt` module serves as the FloPy interface for the **Lake Transport (LKT)** package in a MODFLOW 6 **Groundwater Transport (GWT) Model**. Its primary purpose is to simulate the concentration of a dissolved chemical species (solute) within a lake that is hydraulically connected to the groundwater system.

This module does **not** simulate water flow; it exclusively handles solute transport. It is a process package, analogous to how the Unsaturated Zone Flow (UZF) package defines a flow process. The LKT package relies entirely on the flow budget (inflows, outflows, and stage) calculated by the **Lake (LAK) package** in a corresponding Groundwater Flow (GWF) Model.

Specifically, the LKT package accounts for:
*   **Advective Transport:** Solute movement into and out of the lake via groundwater seepage, connected streams, precipitation, and surface runoff.
*   **Source/Sink Concentrations:** Assigning solute concentrations to external water sources entering the lake, such as rain or streamflow.
*   **Lake Concentration:** Simulating the fully-mixed concentration of the solute within the lake volume over time.
*   **Diffusive Transport:** Simulating molecular diffusion between the lake water and the underlying groundwater at the lakebed.

In summary, if you are modeling solute transport (e.g., a contaminant plume) in a system that includes a lake, the LKT package is essential for representing how the lake interacts with and affects the transport process."
mfgwtmst.py,MST,"MST mf6 ModflowGwtmst defines a MST package.

Parameters
----------
save_flows : keyword
    keyword to indicate that mst flow terms will be written to the file specified
    with 'budget fileout' in output control.
first_order_decay : keyword
    is a text keyword to indicate that first-order decay will occur.  use of this
    keyword requires that decay and decay_sorbed (if sorption is active) are
    specified in the griddata block.
zero_order_decay : keyword
    is a text keyword to indicate that ze The `flopy.mf6.modflow.mfgwtmst` module serves as the FloPy interface for the **Mobile Storage and Transfer (MST)** package of the MODFLOW 6 Groundwater Transport (GWT) Model.

The primary purpose of the MST package is to simulate solute transport in systems where the subsurface can be conceptualized as two distinct domains:

1.  **Mobile Domain:** The portion of the aquifer where groundwater is actively flowing and solutes are transported via advection and dispersion. This is the standard domain represented in a groundwater flow model.
2.  **Immobile Domain:** A portion of the aquifer that stores water and solutes but does not contribute to the bulk groundwater flow. Solute exchange between the mobile and immobile domains occurs through a rate-limited diffusion or sorption process.

In essence, the MST package adds a term to the governing transport equation that accounts for mass transfer between these two domains. This is crucial for accurately simulating ""non-ideal"" transport phenomena, particularly the long concentration ""tailing"" often observed in contaminant breakthrough curves. This tailing occurs because contaminants that have diffused into the immobile domain slowly diffuse back out into the mobile domain long after the main advective front has passed.

The MST package is a **process package** within a GWT model. It is not a solver (like IMS or SMS) or a boundary condition (like CHD or RCH). It modifies the fundamental transport behavior throughout the model grid where it is active. **Scenario 1: Contaminant Transport in Fractured Rock Aquifers** **Scenario 2: Fate of Agricultural Contaminants in Alluvial Aquifers** **Scenario 3: Simulating Non-Equilibrium Sorption** **GWT Model (`flopy.mf6.ModflowGwt`)**: The MST package is a child of a GWT Model instance. It cannot exist on its own and must be part of a larger transport simulation defined by `ModflowGwt`. **Storage Package (`mfgwtsto`)**: The GWT Storage (STO) package handles properties like porosity, and most importantly, instantaneous, equilibrium sorption via the retardation factor. The MST package complements this by adding a *second* storage domain (the immobile one) and simulating the *rate-limited* transfer between the mobile and immobile domains. A model can use both STO (for mobile domain storage and equilibrium sorption) and MST (for immobile domain transfer) simultaneously. **Advection (`mfgwtadv`) and Dispersion (`mfgwtdsp`) Packages**: These packages define the primary transport mechanisms in the mobile domain. The MST package adds a source/sink term to the advection-dispersion equation solved by the GWT model, representing the mass moving into or out of the immobile domain at each time step. **GWF-GWT Exchange (`mfgwfgwt`)**: The GWT model, including its MST component, is almost always coupled to a Groundwater Flow (GWF) model via a GWF-GWT Exchange file. The GWF model provides the flow field (velocities) that drives the advective transport in the GWT model's mobile domain.","The `flopy.mf6.modflow.mfgwtmst` module serves as the FloPy interface for the **Mobile Storage and Transfer (MST)** package of the MODFLOW 6 Groundwater Transport (GWT) Model.

The primary purpose of the MST package is to simulate solute transport in systems where the subsurface can be conceptualized as two distinct domains:

1.  **Mobile Domain:** The portion of the aquifer where groundwater is actively flowing and solutes are transported via advection and dispersion. This is the standard domain represented in a groundwater flow model.
2.  **Immobile Domain:** A portion of the aquifer that stores water and solutes but does not contribute to the bulk groundwater flow. Solute exchange between the mobile and immobile domains occurs through a rate-limited diffusion or sorption process.

In essence, the MST package adds a term to the governing transport equation that accounts for mass transfer between these two domains. This is crucial for accurately simulating ""non-ideal"" transport phenomena, particularly the long concentration ""tailing"" often observed in contaminant breakthrough curves. This tailing occurs because contaminants that have diffused into the immobile domain slowly diffuse back out into the mobile domain long after the main advective front has passed.

The MST package is a **process package** within a GWT model. It is not a solver (like IMS or SMS) or a boundary condition (like CHD or RCH). It modifies the fundamental transport behavior throughout the model grid where it is active."
mfgwtmvt.py,MVT,"MVT mf6 ModflowGwtmvt defines a MVT package.

Parameters
----------
print_input : keyword
    keyword to indicate that the list of mover information will be written to the
    listing file immediately after it is read.
print_flows : keyword
    keyword to indicate that the list of lake flow rates will be printed to the
    listing file for every stress period time step in which 'budget print' is
    specified in output control.  if there is no output control option and
    'print_flows' is specified, th The `mfgwtmvt.py` module implements the **MVT (Viscosity and Miscible Density Transport) Package** for a MODFLOW 6 **GWT (Groundwater Transport) Model**.

Its specific purpose is to simulate the effects of variable fluid density and viscosity on groundwater flow and solute transport. This is essential for modeling scenarios where the density of groundwater changes significantly due to variations in solute concentration (e.g., salinity) or temperature.

The MVT package calculates fluid density and viscosity on a cell-by-cell basis according to the simulated solute concentration. These properties are then used to modify the groundwater flow equation, creating a coupled flow-and-transport simulation. This coupling is fundamental for accurately modeling density-driven flow phenomena like saltwater intrusion or the migration of dense contaminant plumes.

Key functionalities include:
-   **Density Calculation:** It computes fluid density as a linear function of concentration, defined by a reference density (`rhorhef`), a reference concentration (`crhoref`), and the slope of the density-concentration line (`drhodc`).
-   **Viscosity Calculation:** It computes fluid viscosity based on concentration using a reference viscosity (`viscref`) and a viscosity coefficient (`visccoef`).
-   **Coupling Mechanism:** The calculated density is passed to the Groundwater Flow (GWF) Model via the Flow-Transport Link (FTL). The GWF Model must include the **Buoyancy (BUY) Package** to receive this density information and adjust the hydraulic conductivity and storage terms accordingly, thereby influencing the flow field.

The MVT package is a **process package** within the GWT model. It is not a solver (like SMS or IMS) nor a boundary condition package (like WEL or RCH). It describes a fundamental physical process that links the GWT and GWF models. **Scenario 1: Coastal Aquifer Management and Saltwater Intrusion** **Scenario 2: Contaminant Plume Migration from Industrial Brine** **Scenario 3: Geothermal Reservoir Simulation** **GWT Model (`ModflowGwt`)** **GWF-GWT Coupling (BUY Package and FTL Exchange)** **SSM (Source-Sink Mixing) Package (`ModflowGwtssm`)**","The `mfgwtmvt.py` module implements the **MVT (Viscosity and Miscible Density Transport) Package** for a MODFLOW 6 **GWT (Groundwater Transport) Model**.

Its specific purpose is to simulate the effects of variable fluid density and viscosity on groundwater flow and solute transport. This is essential for modeling scenarios where the density of groundwater changes significantly due to variations in solute concentration (e.g., salinity) or temperature.

The MVT package calculates fluid density and viscosity on a cell-by-cell basis according to the simulated solute concentration. These properties are then used to modify the groundwater flow equation, creating a coupled flow-and-transport simulation. This coupling is fundamental for accurately modeling density-driven flow phenomena like saltwater intrusion or the migration of dense contaminant plumes.

Key functionalities include:
-   **Density Calculation:** It computes fluid density as a linear function of concentration, defined by a reference density (`rhorhef`), a reference concentration (`crhoref`), and the slope of the density-concentration line (`drhodc`).
-   **Viscosity Calculation:** It computes fluid viscosity based on concentration using a reference viscosity (`viscref`) and a viscosity coefficient (`visccoef`).
-   **Coupling Mechanism:** The calculated density is passed to the Groundwater Flow (GWF) Model via the Flow-Transport Link (FTL). The GWF Model must include the **Buoyancy (BUY) Package** to receive this density information and adjust the hydraulic conductivity and storage terms accordingly, thereby influencing the flow field.

The MVT package is a **process package** within the GWT model. It is not a solver (like SMS or IMS) nor a boundary condition package (like WEL or RCH). It describes a fundamental physical process that links the GWT and GWF models."
mfgwtmwt.py,MWT,"MWT mf6 ModflowGwtmwt defines a MWT package.

Parameters
----------
flow_package_name : string
    keyword to specify the name of the corresponding flow package.  if not
    specified, then the corresponding flow package must have the same name as this
    advanced transport package (the name associated with this package in the gwt
    name file).
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be pro The `flopy.mf6.modflow.mfgwtmwt` module serves as the FloPy interface for the **Mass Water Transfer (MWT)** package of the MODFLOW 6 Groundwater Transport (GWT) Model. The primary purpose of the MWT package is to **link the GWT model to a source of volumetric flow rates from another MODFLOW 6 package**, enabling the simulation of advective transport associated with that specific flow process.

In simpler terms, if a GWF (Groundwater Flow) model simulates water moving between an aquifer and a river, the MWT package tells the GWT (Transport) model to use those exact river-aquifer exchange rates to move dissolved solutes. It acts as a specialized data bridge for complex flow boundaries.

The MWT package is **not a solver** (like IMS or SMS) and it is **not a boundary condition** in itself (like a Well or General-Head Boundary). Instead, it is a **process-linking package**. It is crucial for building comprehensive transport models where solute movement is driven by flows from sources like:

*   **SFR:** Streamflow Routing Package
*   **LAK:** Lake Package
*   **MAW:** Multi-Aquifer Well Package
*   **UZF:** Unsaturated Zone Flow Package

Without the MWT package, the GWT model would not be aware of the water (and therefore solute) entering or leaving the system through these complex boundary features. **Scenario 1: Modeling Contaminant Transport in a River System** **Scenario 2: Simulating Salinity Impacts from a Coastal Lake** **Scenario 3: Assessing Agricultural Contaminant Leaching** **GWF-GWT Exchange (`mfgwfgwt`)**: This is the most fundamental link between a GWF and GWT model. It handles the transfer of inter-cell flows (i.e., groundwater moving from one model cell to another) from the flow model to the transport model. While the GWF-GWT Exchange handles the aquifer's internal advective transport, the `MWT` package is required to handle advective transport associated with specific boundary packages like streams (`SFR`) and lakes (`LAK`). A typical coupled model will have **both** a GWF-GWT Exchange and one or more `MWT` packages. **Source-Sink Mixing Package (`SSM`)**: The `SSM` package is the primary way to specify the concentration of water entering the GWT model from ""standard"" GWF boundary packages like Wells (`WEL`), Recharge (`RCH`), Drains (`DRN`), and General-Head Boundaries (`GHB`). `MWT` and `SSM` have distinct roles. `SSM` assigns a concentration to flows defined directly within the GWF model's input. `MWT` links to entire flow packages that have their own complex calculations (`SFR`, `LAK`, `UZF`). You often use both in the same model: `SSM` for well injection concentrations and `MWT` for stream interaction. **Advanced GWF Flow Packages (`SFR`, `LAK`, `MAW`, `UZF`)**: These are the packages in the GWF model that `MWT` connects *to*. A modeler must first properly configure one of these packages in their GWF model before they can use `MWT` to link to it. The existence and naming of these packages in the GWF model are prerequisites for using `MWT` in the GWT model.","The `flopy.mf6.modflow.mfgwtmwt` module serves as the FloPy interface for the **Mass Water Transfer (MWT)** package of the MODFLOW 6 Groundwater Transport (GWT) Model. The primary purpose of the MWT package is to **link the GWT model to a source of volumetric flow rates from another MODFLOW 6 package**, enabling the simulation of advective transport associated with that specific flow process.

In simpler terms, if a GWF (Groundwater Flow) model simulates water moving between an aquifer and a river, the MWT package tells the GWT (Transport) model to use those exact river-aquifer exchange rates to move dissolved solutes. It acts as a specialized data bridge for complex flow boundaries.

The MWT package is **not a solver** (like IMS or SMS) and it is **not a boundary condition** in itself (like a Well or General-Head Boundary). Instead, it is a **process-linking package**. It is crucial for building comprehensive transport models where solute movement is driven by flows from sources like:

*   **SFR:** Streamflow Routing Package
*   **LAK:** Lake Package
*   **MAW:** Multi-Aquifer Well Package
*   **UZF:** Unsaturated Zone Flow Package

Without the MWT package, the GWT model would not be aware of the water (and therefore solute) entering or leaving the system through these complex boundary features."
mfgwtnam.py,NAM,"NAM mf6 ModflowGwtnam defines a NAM package.

Parameters
----------
list : string
    is name of the listing file to create for this gwt model.  if not specified,
    then the name of the list file will be the basename of the gwt model name file
    and the '.lst' extension.  for example, if the gwt name file is called
    'my.model.nam' then the list file will be called 'my.model.lst'.
print_input : keyword
    keyword to indicate that the list of all model stress package information will
    be writte The `flopy.mf6.modflow.mfgwtnam` module serves a single, critical, and structural purpose: it creates the **MODFLOW 6 Name File for a Groundwater Transport (GWT) Model**.

In the MODFLOW 6 framework, a simulation is composed of one or more models (e.g., a Groundwater Flow model, a Groundwater Transport model). Each of these models has its own ""Name File"" (with a `.nam` extension) that lists all the input packages and files required for that specific model to run.

This module, and its `ModflowGwtnam` class, is responsible for writing the `gwt.nam` file. This file acts as the central ""table of contents"" for a single GWT model. It tells the MODFLOW 6 executable which packages to use for simulating the transport of a dissolved solute.

**Key Distinctions:**

*   **Not a Process Package:** This is *not* a package that simulates a physical process. For example, it does not calculate advection (`ADV` package) or dispersion (`DSP` package). Instead, it lists that the `ADV` and `DSP` packages are part of the GWT model.
*   **Not a Solver:** It is *not* a numerical solver like the Iterative Model Solution (`IMS`) or the Matrix Solver (`SMS`). The Name File simply lists which solver the GWT model will use.
*   **Structural Component:** Think of this module as an organizational tool or a container. Its primary role is to assemble the list of all components belonging to one specific GWT model within a larger simulation. A user will almost never interact with this module directly; FloPy uses it automatically in the background when a `flopy.mf6.ModflowGwt` model object is created and packages are added to it. **Scenario 1: Contaminant Plume Migration** **Scenario 2: Saltwater Intrusion Assessment** **Scenario 3: Evaluating a Managed Aquifer Recharge (MAR) System** **Related concept 1: The MODFLOW 6 Simulation Structure** **Related concept 2: GWF-GWT Exchange (Flow Model Interface)** **Related concept 3: Source-Sink Mixing (SSM) Package**","The `flopy.mf6.modflow.mfgwtnam` module serves a single, critical, and structural purpose: it creates the **MODFLOW 6 Name File for a Groundwater Transport (GWT) Model**.

In the MODFLOW 6 framework, a simulation is composed of one or more models (e.g., a Groundwater Flow model, a Groundwater Transport model). Each of these models has its own ""Name File"" (with a `.nam` extension) that lists all the input packages and files required for that specific model to run.

This module, and its `ModflowGwtnam` class, is responsible for writing the `gwt.nam` file. This file acts as the central ""table of contents"" for a single GWT model. It tells the MODFLOW 6 executable which packages to use for simulating the transport of a dissolved solute.

**Key Distinctions:**

*   **Not a Process Package:** This is *not* a package that simulates a physical process. For example, it does not calculate advection (`ADV` package) or dispersion (`DSP` package). Instead, it lists that the `ADV` and `DSP` packages are part of the GWT model.
*   **Not a Solver:** It is *not* a numerical solver like the Iterative Model Solution (`IMS`) or the Matrix Solver (`SMS`). The Name File simply lists which solver the GWT model will use.
*   **Structural Component:** Think of this module as an organizational tool or a container. Its primary role is to assemble the list of all components belonging to one specific GWT model within a larger simulation. A user will almost never interact with this module directly; FloPy uses it automatically in the background when a `flopy.mf6.ModflowGwt` model object is created and packages are added to it."
mfgwtoc.py,oc,"mf6 ModflowGwtoc defines a OC package.

Parameters
----------
budget_filerecord : (budgetfile)
    * budgetfile : string
            name of the output file to write budget information.

budgetcsv_filerecord : (budgetcsvfile)
    * budgetcsvfile : string
            name of the comma-separated value (CSV) output file to write budget summary
            information.  A budget summary record will be written to this file for each
            time step of the simulation.

concentration_filerecord : (con The `mfgwtoc.py` module implements the **Output Control (OC)** package for a MODFLOW 6 **Groundwater Transport (GWT) Model**. Its sole purpose is to manage and specify *what* simulation results are saved to output files or printed to the listing file, *when* they are saved, and in *what format*.

This module does **not** simulate any physical groundwater processes. It is a utility package that works in conjunction with a GWT model. It is distinct from:
*   **Physical Packages:** like Advection (`adv`), Dispersion (`dsp`), or Source-Sink Mixing (`ssm`), which simulate the physical movement and reaction of solutes. The OC package saves the *results* calculated by these packages.
*   **Solver Packages:** like the an Implicit Metadynamics Solver (`ims`), which solves the system of linear equations for concentration. The OC package is independent of the solver choice.

Specifically, `ModflowGwtoc` allows the user to control:
*   **Concentration Output:** Saving the calculated concentration array for the entire model grid to a file (`.ucn` extension by convention) at specified times.
*   **Budget Output:** Saving the volumetric flow rates and mass flux terms for the entire model or on a cell-by-cell basis (`.cbc` extension by convention). This is critical for checking mass balance.
*   **Output Timing:** Defining the frequency of output, such as at the end of every time step, at the end of specific stress periods, or at a user-defined interval.
*   **Listing File Verbosity:** Controlling what information (e.g., budget summaries) is printed to the main MODFLOW listing file (`.lst`) during the simulation run.
*   **Output Format:** Specifying whether output files should be saved in binary (compact, efficient) or formatted (human-readable text) formats. **Scenario 1: Long-Term Plume Migration Monitoring** **Scenario 2: Debugging a Mass Balance Error** **Scenario 3: Model Calibration against Monitoring Well Data** **`ModflowGwt` (The GWT Model):** The `ModflowGwtoc` package is a child of a `ModflowGwt` model object. It cannot exist on its own. It defines the output behavior *for that specific GWT model*. **`mfgwfoc` (GWF Output Control):** This is the direct counterpart to `mfgwtoc` but for the Groundwater Flow (GWF) model. Users familiar with `mfgwfoc` for saving heads and flow budgets will find the structure and purpose of `mfgwtoc` to be nearly identical, except it controls concentration and mass budget output instead of head and flow budget output. **`flopy.utils.UcnFile` and `flopy.utils.CellBudgetFile`:** These are FloPy utility classes used for post-processing the output files created by the `mfgwtoc` package. After a simulation runs, a user would instantiate `UcnFile` to read the concentration data (`.ucn` file) and `CellBudgetFile` to read the mass budget data (`.cbc` file) for analysis, plotting, and creating animations.","The `mfgwtoc.py` module implements the **Output Control (OC)** package for a MODFLOW 6 **Groundwater Transport (GWT) Model**. Its sole purpose is to manage and specify *what* simulation results are saved to output files or printed to the listing file, *when* they are saved, and in *what format*.

This module does **not** simulate any physical groundwater processes. It is a utility package that works in conjunction with a GWT model. It is distinct from:
*   **Physical Packages:** like Advection (`adv`), Dispersion (`dsp`), or Source-Sink Mixing (`ssm`), which simulate the physical movement and reaction of solutes. The OC package saves the *results* calculated by these packages.
*   **Solver Packages:** like the an Implicit Metadynamics Solver (`ims`), which solves the system of linear equations for concentration. The OC package is independent of the solver choice.

Specifically, `ModflowGwtoc` allows the user to control:
*   **Concentration Output:** Saving the calculated concentration array for the entire model grid to a file (`.ucn` extension by convention) at specified times.
*   **Budget Output:** Saving the volumetric flow rates and mass flux terms for the entire model or on a cell-by-cell basis (`.cbc` extension by convention). This is critical for checking mass balance.
*   **Output Timing:** Defining the frequency of output, such as at the end of every time step, at the end of specific stress periods, or at a user-defined interval.
*   **Listing File Verbosity:** Controlling what information (e.g., budget summaries) is printed to the main MODFLOW listing file (`.lst`) during the simulation run.
*   **Output Format:** Specifying whether output files should be saved in binary (compact, efficient) or formatted (human-readable text) formats."
mfgwtsft.py,SFT,"SFT mf6 ModflowGwtsft defines a SFT package.

Parameters
----------
flow_package_name : string
    keyword to specify the name of the corresponding flow package.  if not
    specified, then the corresponding flow package must have the same name as this
    advanced transport package (the name associated with this package in the gwt
    name file).
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be pro The `mfgwtsft.py` module implements the **Stream Flow Transport (SFT)** package for the **MODFLOW 6 Groundwater Transport (GWT) Model**. Its primary purpose is to simulate the fate and transport of dissolved solutes within a stream network and the exchange of those solutes between the stream and the underlying aquifer.

This is a **process package**, not a solver. It works in tight coordination with the Streamflow Routing (SFR) package from a Groundwater Flow (GWF) Model. While SFR calculates the *flow* of water in streams and the *rate* of exchange with the aquifer, SFT uses that flow information to calculate the *transport* of solutes.

Key functions of the SFT package include:
-   **Advection and Dispersion:** Simulating the movement and spreading of a solute plume along the stream network.
-   **Source/Sink Loading:** Adding solutes to the stream network from point sources (e.g., tributary inflows, wastewater discharge) and non-point sources (e.g., runoff).
-   **Stream-Aquifer Interaction:** Simulating the mass flux of solutes between the stream and the aquifer. When water leaks from the stream to the aquifer, it carries solutes at the stream's concentration. When groundwater discharges into the stream, it adds solutes at the aquifer's concentration.
-   **Evaporation:** Removing solute mass from the stream when water is lost to evaporation, thereby increasing the concentration of the remaining water.

In essence, SFT provides the transport physics for the surface water component of a coupled groundwater-surface water model. **Scenario 1: Assessing the Impact of a Contaminant Spill** **Scenario 2: Nutrient Loading from Agricultural Watersheds** **Scenario 3: Evaluating Mine Water Discharge** **Streamflow Routing Package (`flopy.mf6.ModflowGwfsfr`)**: This is the most critical dependency. The SFT package is the transport-equivalent of the SFR package. SFT uses the stream network geometry, flow rates, depths, and stream-aquifer exchange fluxes calculated by SFR. You cannot have an SFT package without a corresponding SFR package in a linked GWF model. **Groundwater Transport Model (`flopy.mf6.ModflowGwt`)**: SFT is a package *within* a GWT Model. The GWT Model is the container that solves the solute transport equation for the entire simulation domain, including both the aquifer and the stream network defined by SFT. **GWF-GWT Exchange (`flopy.mf6.ModflowGwfGwt`)**: This is the ""glue"" that connects the flow model (GWF) and the transport model (GWT). It tells the simulation how to map flow exchanges calculated in the GWF model (like stream leakage from SFR) to the GWT model, enabling the transfer of solute mass between the two domains. Without this exchange, the stream and aquifer are hydraulically connected but isolated in terms of solute transport. **Source/Sink Mixing Package (`flopy.mf6.ModflowGwtssm`)**: This package determines the concentration of water entering the GWT model from any source or from a connected model. For stream-aquifer interaction, the SSM package is essential. It instructs the model to use the concentration calculated by the SFT package for any water leaking from the stream into the aquifer.","The `mfgwtsft.py` module implements the **Stream Flow Transport (SFT)** package for the **MODFLOW 6 Groundwater Transport (GWT) Model**. Its primary purpose is to simulate the fate and transport of dissolved solutes within a stream network and the exchange of those solutes between the stream and the underlying aquifer.

This is a **process package**, not a solver. It works in tight coordination with the Streamflow Routing (SFR) package from a Groundwater Flow (GWF) Model. While SFR calculates the *flow* of water in streams and the *rate* of exchange with the aquifer, SFT uses that flow information to calculate the *transport* of solutes.

Key functions of the SFT package include:
-   **Advection and Dispersion:** Simulating the movement and spreading of a solute plume along the stream network.
-   **Source/Sink Loading:** Adding solutes to the stream network from point sources (e.g., tributary inflows, wastewater discharge) and non-point sources (e.g., runoff).
-   **Stream-Aquifer Interaction:** Simulating the mass flux of solutes between the stream and the aquifer. When water leaks from the stream to the aquifer, it carries solutes at the stream's concentration. When groundwater discharges into the stream, it adds solutes at the aquifer's concentration.
-   **Evaporation:** Removing solute mass from the stream when water is lost to evaporation, thereby increasing the concentration of the remaining water.

In essence, SFT provides the transport physics for the surface water component of a coupled groundwater-surface water model."
mfgwtsrc.py,SRC,"SRC mf6 ModflowGwtsrc defines a SRC package.

Parameters
----------
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be provided on this line; however,
    lists of information provided in subsequent blocks must have a column of data
    for each auxiliary variable name defined here.   the number of auxiliary
    variables detected on this line determines the value for naux.  comments cannot
    be pro This module, `mfgwtsrc.py`, implements the `ModflowGwtsrc` class in FloPy, which corresponds to the **Source and Sink Mixing (SRC) Package** for the **MODFLOW 6 Groundwater Transport (GWT) Model**.

The primary purpose of the SRC package is **to specify the concentration of dissolved solutes for water entering the groundwater system**. It acts as a ""linker"" package that assigns water quality attributes to flows defined in other packages. It does *not* create flow itself; it simply tells the transport model the concentration of water coming from sources like:

*   Injection wells (WEL package)
*   Recharge from precipitation (RCH package)
*   Losing streams or rivers (RIV or STR packages)
*   Inflow from general-head boundaries (GHB package)
*   Inflow from constant-head boundaries (CHD package)

When water is removed from the system (e.g., by a pumping well or a draining boundary), the SRC package is not involved; the model simply removes water at the ambient concentration of the cell. Therefore, despite its name, the SRC package is functionally a **Source Concentration Package**. It is a mandatory component for any transport simulation where contaminated or tracer-marked water is introduced into the model domain. **Scenario 1: Modeling Saltwater Intrusion** **Scenario 2: Assessing Agricultural Contaminant Transport** **Scenario 3: Designing and Evaluating a Managed Aquifer Recharge (MAR) System** **Scenario 4: Simulating a Landfill Leachate Plume** **Groundwater Transport (GWT) Model (`flopy.mf6.ModflowGwt`)**: The SRC package cannot exist in isolation. It is a component package that must be added to a GWT Model instance. The GWT model is the primary container for all transport-related processes. **GWF Boundary Packages (e.g., `ModflowGwfwel`, `ModflowGwfrch`, `ModflowGwfghb`)**: The SRC package is fundamentally linked to flow packages. It assigns concentrations to flows defined by these other packages. To use SRC, you must have a corresponding flow package in your GWF model that creates an inflow boundary. The `packagedata` in SRC explicitly references boundaries defined in these flow packages by name (using `boundnames`). **Advection and Dispersion Packages (`ModflowGwtadv`, `ModflowGwtdsp`)**: Once a mass is introduced into the aquifer via the SRC package, its movement is governed by other GWT packages. The Advection (ADV) package handles transport along with the flowing groundwater, while the Dispersion (DSP) package simulates the spreading and mixing of the plume. A GWT model is incomplete without these crucial process packages.","This module, `mfgwtsrc.py`, implements the `ModflowGwtsrc` class in FloPy, which corresponds to the **Source and Sink Mixing (SRC) Package** for the **MODFLOW 6 Groundwater Transport (GWT) Model**.

The primary purpose of the SRC package is **to specify the concentration of dissolved solutes for water entering the groundwater system**. It acts as a ""linker"" package that assigns water quality attributes to flows defined in other packages. It does *not* create flow itself; it simply tells the transport model the concentration of water coming from sources like:

*   Injection wells (WEL package)
*   Recharge from precipitation (RCH package)
*   Losing streams or rivers (RIV or STR packages)
*   Inflow from general-head boundaries (GHB package)
*   Inflow from constant-head boundaries (CHD package)

When water is removed from the system (e.g., by a pumping well or a draining boundary), the SRC package is not involved; the model simply removes water at the ambient concentration of the cell. Therefore, despite its name, the SRC package is functionally a **Source Concentration Package**. It is a mandatory component for any transport simulation where contaminated or tracer-marked water is introduced into the model domain."
mfgwtssm.py,SSM,"SSM mf6 ModflowGwtssm defines a SSM package.

Parameters
----------
print_flows : keyword
    keyword to indicate that the list of ssm flow rates will be printed to the
    listing file for every stress period time step in which 'budget print' is
    specified in output control.  if there is no output control option and
    'print_flows' is specified, then flow rates are printed for the last time step
    of each stress period.
save_flows : keyword
    keyword to indicate that ssm flow terms will be wri The `flopy.mf6.modflow.mfgwtssm` module provides the Python interface for the **Source and Sink Mixing (SSM)** package in a MODFLOW 6 Groundwater Transport (GWT) model.

The primary purpose of the SSM package is to assign a solute concentration to water that enters the groundwater system from an internal source or sink. These sources and sinks are defined in a coupled Groundwater Flow (GWF) model using packages like Wells (`WEL`), Recharge (`RCH`), Rivers (`RIV`), or Drains (`DRN`).

In essence, SSM answers the critical question for any transport simulation: **""When water enters the aquifer from a well, river, or recharge event, what is its concentration?""**

It is important to distinguish the SSM package from other model components:
*   **It is not a solver:** A solver like the Implicit Metadirective Solver (`IMS`) or Sparse Matrix Solver (`SMS`) finds the numerical solution to the flow or transport equations. SSM simply provides the source/sink concentration data *to* the transport equation before the solver runs.
*   **It is not a standard boundary condition package:** While it defines concentration at a boundary, it's specifically for boundaries defined by *flow packages*. It differs from the Constant Concentration (`CNC`) package, which sets the concentration in a cell directly, regardless of flow conditions.
*   **It is a mixing package:** It handles the ""mixing"" of incoming water with the ambient groundwater. SSM only applies concentrations to flows *into* the aquifer. For flows *out of* the aquifer (e.g., pumping from a well), the concentration of the extracted water is simply the ambient concentration of the groundwater in the cell.

The SSM package links the GWF and GWT models, making it a cornerstone of coupled flow and transport simulations in MODFLOW 6. **Scenario 1: Modeling Contaminant Leaching from a Surface Source** **Scenario 2: Simulating River-Aquifer Interaction with a Contaminated River** **Scenario 3: Designing a Pump-and-Treat Remediation System** **GWF-GWT Exchange (`GWFGWT`)**: This is the most fundamental relationship. SSM belongs to a GWT model that is almost always coupled to a GWF model. The `GWFGWT` exchange is the mechanism that passes flow data (e.g., well pumping rates, river leakage rates) from the GWF model to the GWT model. The SSM package uses these flow rates to calculate the mass loading from sources. Without a `GWFGWT` exchange, the SSM package has no flow information and cannot function. **Flow Packages with Auxiliary Variables (`ModflowGwfwel`, `ModflowGwfriv`, `ModflowGwfrch`)**: The SSM package is entirely dependent on flow packages to define the location, timing, and rate of sources. The mechanism for passing concentration information from the flow package to SSM is the `AUXILIARY` keyword. A user must first declare an auxiliary variable (e.g., `auxiliary=['concentration']`) in the flow package's constructor, and then provide the corresponding concentration data in that package's stress period input. The SSM package is then told to look for this specific auxiliary variable. **Other GWT Packages (`ADV`, `DSP`, `MST`)**: SSM is just one component required for a complete transport simulation. It provides the source term (the ""S"" in the advection-dispersion equation). It must be used in conjunction with other GWT packages:","The `flopy.mf6.modflow.mfgwtssm` module provides the Python interface for the **Source and Sink Mixing (SSM)** package in a MODFLOW 6 Groundwater Transport (GWT) model.

The primary purpose of the SSM package is to assign a solute concentration to water that enters the groundwater system from an internal source or sink. These sources and sinks are defined in a coupled Groundwater Flow (GWF) model using packages like Wells (`WEL`), Recharge (`RCH`), Rivers (`RIV`), or Drains (`DRN`).

In essence, SSM answers the critical question for any transport simulation: **""When water enters the aquifer from a well, river, or recharge event, what is its concentration?""**

It is important to distinguish the SSM package from other model components:
*   **It is not a solver:** A solver like the Implicit Metadirective Solver (`IMS`) or Sparse Matrix Solver (`SMS`) finds the numerical solution to the flow or transport equations. SSM simply provides the source/sink concentration data *to* the transport equation before the solver runs.
*   **It is not a standard boundary condition package:** While it defines concentration at a boundary, it's specifically for boundaries defined by *flow packages*. It differs from the Constant Concentration (`CNC`) package, which sets the concentration in a cell directly, regardless of flow conditions.
*   **It is a mixing package:** It handles the ""mixing"" of incoming water with the ambient groundwater. SSM only applies concentrations to flows *into* the aquifer. For flows *out of* the aquifer (e.g., pumping from a well), the concentration of the extracted water is simply the ambient concentration of the groundwater in the cell.

The SSM package links the GWF and GWT models, making it a cornerstone of coupled flow and transport simulations in MODFLOW 6."
mfgwtuzt.py,UZT,"UZT mf6 ModflowGwtuzt defines a UZT package.

Parameters
----------
flow_package_name : string
    keyword to specify the name of the corresponding flow package.  if not
    specified, then the corresponding flow package must have the same name as this
    advanced transport package (the name associated with this package in the gwt
    name file).
auxiliary : [string]
    defines an array of one or more auxiliary variable names.  there is no limit on
    the number of auxiliary variables that can be pro The `mfgwtuzt.py` module implements the **Unsaturated Zone Transport (UZT)** package for the **MODFLOW 6 Groundwater Transport (GWT) Model**. Its primary purpose is to simulate one-dimensional, vertical solute transport through the unsaturated zone, from the land surface to the water table.

The UZT package is not a standalone model or a solver. It is a process-based package that works in direct conjunction with the **Unsaturated Zone Flow (UZF)** package from a corresponding Groundwater Flow (GWF) Model. The relationship is as follows:

1.  **GWF Model (with UZF):** Simulates the movement of *water* through the unsaturated zone. It calculates infiltration rates, water content (`theta`), and the amount of water that eventually recharges the saturated aquifer.
2.  **GWT Model (with UZT):** Uses the flow information from UZF to simulate the movement of *solutes* within that water. It accounts for processes like advection, dispersion, linear sorption (retardation), and first-order decay.

The key function of UZT is to calculate the mass loading and concentration of solutes arriving at the water table. This result then becomes a source/sink term for the main GWT model, which simulates solute transport within the saturated groundwater system. In essence, UZT acts as a critical link between surface contaminant sources and the underlying aquifer. **Scenario 1: Agricultural Nitrate Leaching** **Scenario 2: Landfill Leachate Migration** **Scenario 3: Managed Aquifer Recharge (MAR) System Design** **GWF - UZF Package (`ModflowGwfuzf`)** **GWT Model (`ModflowGwt`)** **Source/Sink Mixing Package (`ModflowGwtssm`)** **Dispersion Package (`ModflowGwtdsp`)**","The `mfgwtuzt.py` module implements the **Unsaturated Zone Transport (UZT)** package for the **MODFLOW 6 Groundwater Transport (GWT) Model**. Its primary purpose is to simulate one-dimensional, vertical solute transport through the unsaturated zone, from the land surface to the water table.

The UZT package is not a standalone model or a solver. It is a process-based package that works in direct conjunction with the **Unsaturated Zone Flow (UZF)** package from a corresponding Groundwater Flow (GWF) Model. The relationship is as follows:

1.  **GWF Model (with UZF):** Simulates the movement of *water* through the unsaturated zone. It calculates infiltration rates, water content (`theta`), and the amount of water that eventually recharges the saturated aquifer.
2.  **GWT Model (with UZT):** Uses the flow information from UZF to simulate the movement of *solutes* within that water. It accounts for processes like advection, dispersion, linear sorption (retardation), and first-order decay.

The key function of UZT is to calculate the mass loading and concentration of solutes arriving at the water table. This result then becomes a source/sink term for the main GWT model, which simulates solute transport within the saturated groundwater system. In essence, UZT acts as a critical link between surface contaminant sources and the underlying aquifer."
mfims.py,IMS,"IMS mf6 ModflowIms defines a IMS package.

Parameters
----------
print_option : string
    is a flag that controls printing of convergence information from the solver.
    none means print nothing. summary means print only the total number of
    iterations and nonlinear residual reduction summaries. all means print linear
    matrix solver convergence information to the solution listing file and model
    specific linear matrix solver convergence information to each model listing
    file in addition t The `flopy.mf6.modflow.mfims.py` module provides the Python interface for the **Iterative Model Solution (IMS)** package of MODFLOW 6. The IMS package is not a physical process package (like wells or recharge) but is a **numerical solver**. Its sole purpose is to solve the large system of linear equations that are generated by the groundwater flow (GWF) or transport (GWT) models at each time step or stress period.

In essence, the `ModflowIms` class acts as the numerical ""engine"" for a MODFLOW 6 simulation. When the GWF model assembles all the contributions from physical packages (e.g., Conductance from the NPF package, sources/sinks from the WEL/RCH packages, head-dependent fluxes from the GHB/DRN packages), it results in a matrix equation of the form **[A]{h} = {b}**. The IMS package's job is to find the vector of heads, **{h}**, that satisfies this equation to a specified tolerance.

Key functionalities controlled by this module include:

*   **Linear Solver Choice:** Selecting the underlying algorithm to solve the linear equations, such as Conjugate Gradient (`CG`) or Biconjugate Gradient Stabilized (`BICGSTAB`).
*   **Convergence Criteria:** Defining the stopping criteria for both the outer (nonlinear) and inner (linear) iterations (e.g., `outer_hclose`, `inner_hclose`). This determines how ""close"" the solution needs to be before it's considered acceptable.
*   **Iteration Control:** Setting the maximum number of iterations allowed, preventing the solver from running indefinitely if the model fails to converge.
*   **Preconditioning:** Applying numerical techniques (like Incomplete LU factorization, or `ILU`) to the matrix to make it easier and faster to solve. This is critical for model performance.

Crucially, IMS is distinct from packages like UZF (Unsaturated Zone Flow). UZF formulates equations based on the physics of flow in the unsaturated zone, contributing terms to the **[A]** matrix and **{b}** vector. IMS knows nothing about this physics; it simply receives the final matrix and solves it. **Scenario 1: Standard Model Setup** **Scenario 2: Troubleshooting a Non-Convergent Model** **Scenario 3: Optimizing a Computationally Expensive Model** **Scenario 4: Setting up a Coupled Flow and Transport Model** **`flopy.mf6.MFSimulation`:** The `ModflowIms` object is not attached to a specific model (like GWF). Instead, it is passed to the top-level `MFSimulation` object during its creation. The simulation object then manages which models use that solver solution. This is a key architectural difference in FloPy for MODFLOW 6 compared to older versions. **`flopy.mf6.modflow.ModflowGwf` and `ModflowGwt`:** These are the primary model objects that generate the matrices that `ModflowIms` is designed to solve. The complexity of these models (e.g., number of cells, presence of nonlinear packages like UZF or SFR) directly dictates how difficult the solution process will be for IMS. **SMS (Sparse Matrix Solver) and NWT (Newton-Raphson) Packages:** These are the solver equivalents from previous MODFLOW versions (MF-2005, MF-NWT). Users migrating models will find that `IMS` combines and modernizes the functionality of both. The linear acceleration options (`CG`, `BICGSTAB`) and preconditioning in IMS are analogous to the features in SMS. The handling of nonlinearities (outer iterations) in IMS replaces the specialized Newton-Raphson formulation of the NWT package, providing a more general framework.","The `flopy.mf6.modflow.mfims.py` module provides the Python interface for the **Iterative Model Solution (IMS)** package of MODFLOW 6. The IMS package is not a physical process package (like wells or recharge) but is a **numerical solver**. Its sole purpose is to solve the large system of linear equations that are generated by the groundwater flow (GWF) or transport (GWT) models at each time step or stress period.

In essence, the `ModflowIms` class acts as the numerical ""engine"" for a MODFLOW 6 simulation. When the GWF model assembles all the contributions from physical packages (e.g., Conductance from the NPF package, sources/sinks from the WEL/RCH packages, head-dependent fluxes from the GHB/DRN packages), it results in a matrix equation of the form **[A]{h} = {b}**. The IMS package's job is to find the vector of heads, **{h}**, that satisfies this equation to a specified tolerance.

Key functionalities controlled by this module include:

*   **Linear Solver Choice:** Selecting the underlying algorithm to solve the linear equations, such as Conjugate Gradient (`CG`) or Biconjugate Gradient Stabilized (`BICGSTAB`).
*   **Convergence Criteria:** Defining the stopping criteria for both the outer (nonlinear) and inner (linear) iterations (e.g., `outer_hclose`, `inner_hclose`). This determines how ""close"" the solution needs to be before it's considered acceptable.
*   **Iteration Control:** Setting the maximum number of iterations allowed, preventing the solver from running indefinitely if the model fails to converge.
*   **Preconditioning:** Applying numerical techniques (like Incomplete LU factorization, or `ILU`) to the matrix to make it easier and faster to solve. This is critical for model performance.

Crucially, IMS is distinct from packages like UZF (Unsaturated Zone Flow). UZF formulates equations based on the physics of flow in the unsaturated zone, contributing terms to the **[A]** matrix and **{b}** vector. IMS knows nothing about this physics; it simply receives the final matrix and solves it."
mfmvr.py,MVR,"MVR mf6 ModflowMvr defines a MVR package.

Parameters
----------
print_input : keyword
    keyword to indicate that the list of mvr information will be written to the
    listing file immediately after it is read.
print_flows : keyword
    keyword to indicate that the list of mvr flow rates will be printed to the
    listing file for every stress period time step in which 'budget print' is
    specified in output control.  if there is no output control option and
    'print_flows' is specified, then flo The `flopy.mf6.modflow.mfmvr` module provides the FloPy interface for the MODFLOW 6 **Mover (MVR) Package**. The MVR Package is not a solver (like SMS) or a standalone physical process (like UZF). Instead, it is a powerful utility package designed to simulate the **explicit movement of water between different stress packages** or between different features within the same stress package.

In essence, the MVR package acts as a ""connector"" or ""plumbing"" system within a MODFLOW 6 Groundwater Flow (GWF) model. Its primary purpose is to redirect water flows that are calculated by ""provider"" packages (e.g., Streamflow Routing, Lake) to ""receiver"" packages (e.g., Well, Recharge). It does not create or destroy water in the model but rather re-routes it, making it essential for simulating complex water management operations, conjunctive use, and infrastructure.

The MVR package connects any of the ""advanced"" stress packages that support it:
*   Streamflow Routing (SFR)
*   Lake (LAK)
*   Unsaturated Zone Flow (UZF)
*   Multi-Aquifer Well (MAW)
*   Well (WEL)

The key function is to take a calculated flow from a specific feature in a provider package (e.g., the flow out of reach 5 in a SFR package) and assign it as a source/sink term to a specific feature in a receiver package (e.g., an injection well in the WEL package). **Scenario 1: Canal Diversion for Irrigation** **Scenario 2: Managed Aquifer Recharge (MAR) System** **Scenario 3: Reservoir Release for Environmental Flows** **Advanced Stress Packages (SFR, LAK, UZF, MAW, WEL):** The MVR package is fundamentally linked to these packages. It cannot function on its own; its purpose is to connect them. A model using MVR will always have at least two of these advanced packages (or two separate instances of the same package, e.g., `sfr_1` and `sfr_2`). The design of these packages in MODFLOW 6, with individually numbered features (e.g., `reach 1`, `reach 2`, `well 1`, `well 2`), is what allows MVR to precisely target providers and receivers. **MODFLOW 6 Package Naming:** In MODFLOW 6, users can assign custom names to packages when they are added to a model (e.g., `gwf.name = 'sfr_upper'`). The MVR package requires these exact names (`pname_from`, `pname_to`) to identify the provider and receiver packages. This is a critical difference from older MODFLOW versions and a key concept for using MVR correctly. **MODFLOW 6 Time Series (`TS`) and Observations (`OBS`):** Mover operations are often complex and vary over time. The flow rates specified in the MVR `perioddata` can reference a Time Series file, allowing for detailed, non-periodic operational schedules. Furthermore, the flow moved by each MVR connection is a budget term that can be saved and analyzed using the Observation Utility (`OBS`), which is crucial for verifying that the model's water transfers are behaving as intended.","The `flopy.mf6.modflow.mfmvr` module provides the FloPy interface for the MODFLOW 6 **Mover (MVR) Package**. The MVR Package is not a solver (like SMS) or a standalone physical process (like UZF). Instead, it is a powerful utility package designed to simulate the **explicit movement of water between different stress packages** or between different features within the same stress package.

In essence, the MVR package acts as a ""connector"" or ""plumbing"" system within a MODFLOW 6 Groundwater Flow (GWF) model. Its primary purpose is to redirect water flows that are calculated by ""provider"" packages (e.g., Streamflow Routing, Lake) to ""receiver"" packages (e.g., Well, Recharge). It does not create or destroy water in the model but rather re-routes it, making it essential for simulating complex water management operations, conjunctive use, and infrastructure.

The MVR package connects any of the ""advanced"" stress packages that support it:
*   Streamflow Routing (SFR)
*   Lake (LAK)
*   Unsaturated Zone Flow (UZF)
*   Multi-Aquifer Well (MAW)
*   Well (WEL)

The key function is to take a calculated flow from a specific feature in a provider package (e.g., the flow out of reach 5 in a SFR package) and assign it as a source/sink term to a specific feature in a receiver package (e.g., an injection well in the WEL package)."
mfnam.py,NAM,"NAM mf6 ModflowNam defines a NAM package.

Parameters
----------
continue_ : keyword
    keyword flag to indicate that the simulation should continue even if one or
    more solutions do not converge.
nocheck : keyword
    keyword flag to indicate that the model input check routines should not be
    called prior to each time step. checks are performed by default.
memory_print_option : string
    is a flag that controls printing of detailed memory manager usage to the end of
    the simulation list file The `flopy.mf6.modflow.mfnam.py` module serves a single, critical, and foundational purpose: it creates and manages the **MODFLOW 6 Groundwater Flow (GWF) Model Name File**. This file, which conventionally has a `.nam` extension, acts as the central ""table of contents"" for a single groundwater flow model within a larger MODFLOW 6 simulation.

It is **not** a package that simulates a physical process (like `UZF` for unsaturated flow) nor is it a numerical solver (like `IMS` for solving the matrix equations). Instead, its function is purely structural. The GWF Name File lists all the other input files (packages) that define the groundwater flow model.

Specifically, the `ModflowNam` class is responsible for:
1.  **Listing Core Packages:** It records the file types and corresponding filenames for essential packages like:
    *   **Discretization:** `DIS`, `DISV`, or `DISU` (defines the model grid).
    *   **Initial Conditions:** `IC` (defines starting heads).
    *   **Node Properties:** `NPF` (defines hydraulic conductivity and cell properties).
    *   **Storage:** `STO` (defines aquifer storage properties).
    *   **Output Control:** `OC` (controls what, when, and how results are saved).
2.  **Listing Boundary Condition Packages:** It includes any active boundary condition packages, such as:
    *   `WEL` (Wells)
    *   `DRN` (Drains)
    *   `RCH` (Recharge)
    *   `EVT` (Evapotranspiration)
    *   `CHD` (Constant-Head)
    *   `SFR` (Streamflow Routing)
3.  **Managing Model-Level Options:** It handles optional settings for the GWF model, such as print flags for flow rates and budgets (`PRINT_FLOWS`, `SAVE_FLOWS`).

In the context of MODFLOW 6's hierarchical structure (Simulation -> Model -> Package), this module defines the ""Model"" level for a GWF model. A user typically does not interact with `ModflowNam` directly but rather through the `flopy.mf6.ModflowGwf` class, which uses `ModflowNam` internally to manage its list of associated packages. **Scenario 1: Setting up a Standard Regional Flow Model** **Scenario 2: Debugging a Model's Structure** **Scenario 3: Creating and Comparing Model Scenarios** **`flopy.mf6.MFSimulation` and `mfsim.nam`:** This is the parent concept. An `MFSimulation` object represents the entire simulation and can contain multiple models (e.g., one GWF model and one GWT transport model). Its corresponding `mfsim.nam` file lists the models and the numerical solver (`IMS`). The `ModflowNam` file is listed *inside* the `mfsim.nam` file and defines the contents of just *one* of those models. *Relationship:* `MFSimulation` contains `ModflowGwf`, which in turn contains `ModflowNam`. **`flopy.mf6.ModflowGwf`:** This is the high-level ""helper"" or ""wrapper"" class for a GWF Model. When a user types `gwf = flopy.mf6.ModflowGwf(sim, ...)`, this class is instantiated. One of the first things its `__init__` method does is create the `ModflowNam` object. Users add packages to the `gwf` object, and the `ModflowNam` instance keeps track of them. It is the primary user-facing interface for the GWF model. **Package Registration:** This is the mechanism by which the name file is built. When a user creates a package object, they pass the parent model object to its constructor, for example, `dis = flopy.mf6.ModflowGwfdis(gwf, ...)`. The package's constructor then calls a method on the `gwf` model to ""register"" itself. This action adds the package's type and filename to the internal list managed by the `gwf.name_file` (`ModflowNam`) object. This automated registration is central to FloPy's workflow.","The `flopy.mf6.modflow.mfnam.py` module serves a single, critical, and foundational purpose: it creates and manages the **MODFLOW 6 Groundwater Flow (GWF) Model Name File**. This file, which conventionally has a `.nam` extension, acts as the central ""table of contents"" for a single groundwater flow model within a larger MODFLOW 6 simulation.

It is **not** a package that simulates a physical process (like `UZF` for unsaturated flow) nor is it a numerical solver (like `IMS` for solving the matrix equations). Instead, its function is purely structural. The GWF Name File lists all the other input files (packages) that define the groundwater flow model.

Specifically, the `ModflowNam` class is responsible for:
1.  **Listing Core Packages:** It records the file types and corresponding filenames for essential packages like:
    *   **Discretization:** `DIS`, `DISV`, or `DISU` (defines the model grid).
    *   **Initial Conditions:** `IC` (defines starting heads).
    *   **Node Properties:** `NPF` (defines hydraulic conductivity and cell properties).
    *   **Storage:** `STO` (defines aquifer storage properties).
    *   **Output Control:** `OC` (controls what, when, and how results are saved).
2.  **Listing Boundary Condition Packages:** It includes any active boundary condition packages, such as:
    *   `WEL` (Wells)
    *   `DRN` (Drains)
    *   `RCH` (Recharge)
    *   `EVT` (Evapotranspiration)
    *   `CHD` (Constant-Head)
    *   `SFR` (Streamflow Routing)
3.  **Managing Model-Level Options:** It handles optional settings for the GWF model, such as print flags for flow rates and budgets (`PRINT_FLOWS`, `SAVE_FLOWS`).

In the context of MODFLOW 6's hierarchical structure (Simulation -> Model -> Package), this module defines the ""Model"" level for a GWF model. A user typically does not interact with `ModflowNam` directly but rather through the `flopy.mf6.ModflowGwf` class, which uses `ModflowNam` internally to manage its list of associated packages."
mfsimulation.py,SIM,"SIM mf6 MFSimulation is used to load, build, and/or save a MODFLOW 6 simulation. A MFSimulation object must be created before creating any of the MODFLOW 6 model objects.

Parameters
----------
continue_ : keyword
    keyword flag to indicate that the simulation should continue even if one or
    more solutions do not converge.
nocheck : keyword
    keyword flag to indicate that the model input check routines should not be
    called prior to each time step. checks are performed by default.
memory_print The `flopy/mf6/modflow/mfsimulation.py` module serves as the foundational entry point for any MODFLOW 6 simulation constructed using FloPy. It defines the `MFSimulation` class, which is the top-level container that orchestrates all components of a MODFLOW 6 run.

This module is **not** a package that represents a physical process (like `UZF` for unsaturated zone flow) nor is it a numerical solver (like `IMS`). Instead, it is the highest-level ""manager"" object in the FloPy MF6 hierarchy, directly corresponding to the MODFLOW 6 Simulation Name File (`.nam`).

The primary responsibilities of the `MFSimulation` class are to:
1.  **Aggregate Models:** A single simulation can contain multiple models. For example, it can hold one or more Groundwater Flow (`GWF`) models, Groundwater Transport (`GWT`) models, or others. The `MFSimulation` object keeps track of all models in the simulation.
2.  **Manage Global Packages:** It manages packages that are global to the entire simulation, not specific to any one model. These include:
    *   **TDIS (Temporal Discretization):** Defines the stress periods and time steps for all models.
    *   **IMS (Iterative Model Solution):** The solver that controls the numerical solution for the coupled system of models.
3.  **Define Exchanges:** It manages ""exchange"" packages that define the connections and transfer of information between models (e.g., a `GWF-GWT` exchange to pass flow fields for transport modeling, or a `GWF-GWF` exchange for connecting two separate flow models).
4.  **Control I/O:** It establishes the simulation name and the working directory (workspace) where all input files will be written and output files will be generated.

In short, every FloPy script that builds, loads, or runs a MODFLOW 6 model **must** begin by instantiating an `MFSimulation` object. It is the root of the entire model structure.","The `flopy/mf6/modflow/mfsimulation.py` module serves as the foundational entry point for any MODFLOW 6 simulation constructed using FloPy. It defines the `MFSimulation` class, which is the top-level container that orchestrates all components of a MODFLOW 6 run.

This module is **not** a package that represents a physical process (like `UZF` for unsaturated zone flow) nor is it a numerical solver (like `IMS`). Instead, it is the highest-level ""manager"" object in the FloPy MF6 hierarchy, directly corresponding to the MODFLOW 6 Simulation Name File (`.nam`).

The primary responsibilities of the `MFSimulation` class are to:
1.  **Aggregate Models:** A single simulation can contain multiple models. For example, it can hold one or more Groundwater Flow (`GWF`) models, Groundwater Transport (`GWT`) models, or others. The `MFSimulation` object keeps track of all models in the simulation.
2.  **Manage Global Packages:** It manages packages that are global to the entire simulation, not specific to any one model. These include:
    *   **TDIS (Temporal Discretization):** Defines the stress periods and time steps for all models.
    *   **IMS (Iterative Model Solution):** The solver that controls the numerical solution for the coupled system of models.
3.  **Define Exchanges:** It manages ""exchange"" packages that define the connections and transfer of information between models (e.g., a `GWF-GWT` exchange to pass flow fields for transport modeling, or a `GWF-GWF` exchange for connecting two separate flow models).
4.  **Control I/O:** It establishes the simulation name and the working directory (workspace) where all input files will be written and output files will be generated.

In short, every FloPy script that builds, loads, or runs a MODFLOW 6 model **must** begin by instantiating an `MFSimulation` object. It is the root of the entire model structure."
mftdis.py,TDIS,"TDIS mf6 ModflowTdis defines a TDIS package.

Parameters
----------
time_units : string
    is the time units of the simulation.  this is a text string that is used as a
    label within model output files.  values for time_units may be 'unknown',
    'seconds', 'minutes', 'hours', 'days', or 'years'.  the default time unit is
    'unknown'.
start_date_time : string
    is the starting date and time of the simulation.  this is a text string that is
    used as a label within the simulation list file.  th The `flopy.mf6.modflow.mftdis` module implements the **MODFLOW 6 Time Discretization (TDIS) Package**. This package is fundamental and **required** for every MODFLOW 6 simulation. Its primary purpose is to define the temporal framework of the model run.

Specifically, the TDIS package controls:
- **Simulation Time:** It defines the total number of stress periods and the length of each period.
- **Time Stepping:** It specifies how each stress period is divided into smaller time steps for the numerical solver. This includes setting the number of time steps and a multiplier to increase or decrease time step length within a stress period.
- **Steady-State vs. Transient:** The configuration of the TDIS package, in conjunction with the presence or absence of the Storage (STO) package, determines whether a simulation or a specific stress period is run as steady-state (representing long-term equilibrium) or transient (simulating changes over time).

This module is not a solver (like IMS), a physical process package (like NPF - Node Property Flow), or a boundary condition (like WEL - Well). It is a core structural component that governs the entire simulation's timeline, upon which all time-dependent processes and boundaries rely. **Scenario 1: Regional Aquifer System under Equilibrium** **Scenario 2: Simulating Seasonal Pumping Effects** **Scenario 3: Long-Term Mine Dewatering Simulation** **Boundary Condition Packages (WEL, RIV, GHB, etc.):** The number of stress periods (`nper`) defined in `ModflowTdis` dictates the structure of the input for all time-varying boundary conditions. If `nper=12` (e.g., for monthly stress periods over one year), the `stress_period_data` for the Well (WEL) Package must contain pumping rates for all 12 of those periods. The TDIS package sets the stage that all other packages must follow. **Storage Package (STO):** The TDIS and STO packages are intrinsically linked in any transient simulation. TDIS defines the time step duration (`Δt`), while STO defines the aquifer's storage properties (Specific Yield `Sy` and Specific Storage `Ss`). The change in groundwater storage calculated by the model is a function of both the storage coefficient and the change in head over the time step duration defined in TDIS. A transient model **must** have both a TDIS and an STO package. A steady-state model has a TDIS package but **no** STO package. **Solution Packages (IMS, SMS):** The time step length defined in TDIS can significantly impact the ability of the solver to converge on a solution. If time steps are too large, the numerical solution can become unstable, leading to convergence failure. The TDIS settings (`nstp`, `tsmult`) are often the first parameters a modeler adjusts when troubleshooting non-convergence in a transient simulation.","The `flopy.mf6.modflow.mftdis` module implements the **MODFLOW 6 Time Discretization (TDIS) Package**. This package is fundamental and **required** for every MODFLOW 6 simulation. Its primary purpose is to define the temporal framework of the model run.

Specifically, the TDIS package controls:
- **Simulation Time:** It defines the total number of stress periods and the length of each period.
- **Time Stepping:** It specifies how each stress period is divided into smaller time steps for the numerical solver. This includes setting the number of time steps and a multiplier to increase or decrease time step length within a stress period.
- **Steady-State vs. Transient:** The configuration of the TDIS package, in conjunction with the presence or absence of the Storage (STO) package, determines whether a simulation or a specific stress period is run as steady-state (representing long-term equilibrium) or transient (simulating changes over time).

This module is not a solver (like IMS), a physical process package (like NPF - Node Property Flow), or a boundary condition (like WEL - Well). It is a core structural component that governs the entire simulation's timeline, upon which all time-dependent processes and boundaries rely."
mfutlats.py,ATS,"ATS mf6 ModflowUtlats defines a ATS package.

Parameters
----------
maxats : integer
    is the number of records in the subsequent perioddata block that will be used
    for adaptive time stepping.
perioddata : list This module implements the `ModflowUtlats` class, which provides a Python interface for the **Advanced Time Step Control (ATS)** package in MODFLOW 6. The ATS package is not a physical process package (like Well or Recharge) nor is it a numerical solver (like IMS or SMS). Instead, it is a **utility for dynamically controlling the simulation time step size** to improve model stability and efficiency.

The core purpose of the ATS package is to automatically adjust the length of each time step (`dt`) *within* a stress period based on the convergence behavior of the numerical solver.

-   If the solver struggles to converge (e.g., requires many iterations), the ATS package will **reduce** the time step size to make the problem more linear and easier to solve.
-   If the solver converges easily and quickly, the ATS package will **increase** the time step size to speed up the simulation, preventing unnecessarily small steps.

This utility is defined as an optional block within the Time Discretization (TDIS) package input file. It works in tandem with the TDIS package and the selected solver (e.g., IMS) to manage the simulation's progress through time. **Scenario 1: Modeling Systems with High-Frequency Stress Changes** **Scenario 2: Simulating Complex Surface Water - Groundwater Interactions** **Scenario 3: Improving Robustness during Automated Calibration** **TDIS Package (`ModflowTdis`)**: The ATS settings are an optional block within the TDIS input file. The TDIS package defines the stress periods, their lengths, the number of time steps, and the time step multiplier (`TSMULT`). ATS works by overriding and dynamically adjusting the time step size *within* the framework established by TDIS. You cannot use ATS without a corresponding TDIS package. **Iterative Model Solution (IMS) Package (`ModflowIms`)**: ATS decisions are directly linked to the performance of the solver. A key ATS parameter, `DT_CHANGE_TARGET`, is often the target number of outer solver iterations. If the actual number of iterations in a time step exceeds this target, ATS reduces `dt`. If it's below the target, ATS increases `dt`. Therefore, the convergence criteria, relaxation parameters, and iteration limits set in the IMS package are tightly coupled with the behavior of the ATS package. **Non-linear Processes (UZF, SFR, LAK, Newton-Raphson)**: The primary need for ATS arises from non-linearities in the groundwater system. These can be caused by water table fluctuations (unconfined flow), drying and rewetting of cells, or complex boundary conditions like the Unsaturated Zone Flow (UZF), Streamflow Routing (SFR), or Lake (LAK) packages. When the Newton-Raphson formulation is used (via the `NEWTON` option in the GWF model), non-linearities are handled more robustly, but ATS remains a valuable tool for managing time steps when convergence is difficult.","This module implements the `ModflowUtlats` class, which provides a Python interface for the **Advanced Time Step Control (ATS)** package in MODFLOW 6. The ATS package is not a physical process package (like Well or Recharge) nor is it a numerical solver (like IMS or SMS). Instead, it is a **utility for dynamically controlling the simulation time step size** to improve model stability and efficiency.

The core purpose of the ATS package is to automatically adjust the length of each time step (`dt`) *within* a stress period based on the convergence behavior of the numerical solver.

-   If the solver struggles to converge (e.g., requires many iterations), the ATS package will **reduce** the time step size to make the problem more linear and easier to solve.
-   If the solver converges easily and quickly, the ATS package will **increase** the time step size to speed up the simulation, preventing unnecessarily small steps.

This utility is defined as an optional block within the Time Discretization (TDIS) package input file. It works in tandem with the TDIS package and the selected solver (e.g., IMS) to manage the simulation's progress through time."
mfutlhpc.py,HPC,"HPC mf6 ModflowUtlhpc defines a HPC package.

Parameters
----------
print_table : keyword
    keyword to indicate that the partition table will be printed to the listing
    file.
dev_log_mpi : keyword
    keyword to enable (extremely verbose) logging of mpi traffic to file.
partitions : list
    is the list of zero-based partition numbers. The `mfutlhpc.py` module provides the FloPy interface for the **MODFLOW 6 High-Performance Computing (HPC) package**. The purpose of this utility package is to enable **parallel processing** for a single MODFLOW 6 simulation, drastically reducing model run times.

It is crucial to understand that **HPC is not a solver** like the Iterative Model Solution (IMS) or the Sparse Matrix Solver (SMS). Instead, it's a utility that manages the parallel execution architecture. It works by using a **domain decomposition** approach. The modeler first uses an external MODFLOW 6 utility (like `GRIDGEN`) to split the main model grid into multiple, smaller, overlapping sub-domains (partitions). The HPC package then directs MODFLOW 6 to run each partition on a separate processor core. An external MPI (Message Passing Interface) library handles the communication of boundary conditions (head, flow) between these partitions at each time step.

In short, `mfutlhpc` is the FloPy tool for configuring a MODFLOW 6 model to run in parallel on multi-core computers or computing clusters, targeting large and computationally demanding models. **Scenario 1: Large-Scale Regional Aquifer Modeling** **Scenario 2: High-Resolution Density-Dependent Seawater Intrusion Analysis** **Scenario 3: Automated Calibration and Uncertainty Analysis** **GRIDGEN Utility:** This is a command-line program distributed with MODFLOW 6, not a part of FloPy. It is an essential prerequisite for using the HPC package. The user must first run `GRIDGEN` on their model's discretization file (`dis.grb`) to generate the set of partition files that the HPC package relies on. The HPC setup is incomplete and will not work without the output from `GRIDGEN`. **MPI (Message Passing Interface):** The HPC package tells MODFLOW *how* the model is partitioned, but MPI is the underlying technology that actually *manages* the parallel processes and their communication. The user must have an MPI implementation (e.g., MPICH, Open MPI) installed on their system. The model is then executed using a command like `mpiexec -n 16 mf6`, not just `mf6`. This is a system-level dependency, not a Python or FloPy one. **Iterative Model Solution (IMS):** The HPC package manages the overall parallel structure, but the `IMS` package is still responsible for solving the system of linear equations *within each partition*. A model using HPC will still have an `ims` file and its settings (e.g., outer/inner iterations, relaxation factors) remain critical for convergence and stability on each subdomain. The two packages work in tandem.","The `mfutlhpc.py` module provides the FloPy interface for the **MODFLOW 6 High-Performance Computing (HPC) package**. The purpose of this utility package is to enable **parallel processing** for a single MODFLOW 6 simulation, drastically reducing model run times.

It is crucial to understand that **HPC is not a solver** like the Iterative Model Solution (IMS) or the Sparse Matrix Solver (SMS). Instead, it's a utility that manages the parallel execution architecture. It works by using a **domain decomposition** approach. The modeler first uses an external MODFLOW 6 utility (like `GRIDGEN`) to split the main model grid into multiple, smaller, overlapping sub-domains (partitions). The HPC package then directs MODFLOW 6 to run each partition on a separate processor core. An external MPI (Message Passing Interface) library handles the communication of boundary conditions (head, flow) between these partitions at each time step.

In short, `mfutlhpc` is the FloPy tool for configuring a MODFLOW 6 model to run in parallel on multi-core computers or computing clusters, targeting large and computationally demanding models."
mfutllaktab.py,laktab,"mf6 ModflowUtllaktab defines a LAKTAB package.

Parameters
----------
nrow : integer
    integer value specifying the number of rows in the lake table. there must be
    nrow rows of data in the table block.
ncol : integer
    integer value specifying the number of columns in the lake table. there must be
    ncol columns of data in the table block. for lakes with horizontal and/or
    vertical ctype connections, ncol must be equal to 3. for lakes with embeddedh
    or embeddedv ctype connections, n The `mfutllaktab` module provides the `ModflowUtllaktab` class, a utility for creating the **LAKTAB file** required by the MODFLOW 6 Lake (LAK) Package. Its specific purpose is to define the geometric and physical properties of a lake as a table of values. This table typically contains the **stage-area-volume-conductance** relationship for a lake.

MODFLOW 6 uses this table to look up the lake's surface area, volume, and bed conductance based on the simulated lake stage at each time step. This is essential for accurately simulating the lake's water budget, including changes in storage, evaporation, and interaction with the underlying groundwater system.

This module does not represent a standalone package like LAK or a solver like IMS. Instead, it is a helper or ""utility"" class that constructs a specific, detailed input file used *by* the LAK package when the `TABLEINPUT` option is specified. This approach is used for lakes with complex bathymetry that cannot be represented by a simple geometric shape. **Scenario 1: Modeling a Lake with Complex Bathymetry** **Scenario 2: Calibrating Lake-Groundwater Interaction** **Scenario 3: Migrating a Model with Pre-existing Data** **MODFLOW 6 Lake Package (`ModflowGwfLak`)**: This is the primary related concept. The `ModflowUtllaktab` class is exclusively used to generate input for the `ModflowGwfLak` package. The resulting table file is linked to a specific lake defined in the LAK package's `packagedata` block via a lake number (`lakeno`). The `lak_tables` argument of the `ModflowGwfLak` constructor is where instances of `ModflowUtllaktab` are passed. **Time Series Data (`ModflowTdis`, `ModflowGwfLak`'s `ts_filerecord`)**: While `ModflowUtllaktab` defines the static geometry of the lake, the LAK package's water budget is driven by time-varying inputs like precipitation, evaporation, runoff, and withdrawal rates. These are specified using MODFLOW 6's Time Series functionality. A complete lake model requires both the static geometry from `laktab` and these dynamic time series inputs. **Advanced Stress Packages (`SFR`, `MVR`, `UZF`)**: Lakes are rarely isolated features. The LAK package is designed to interact with other parts of the hydrologic system. **Streamflow Routing (SFR)**: Streams can flow into or out of a lake. This connection is defined in the SFR package data and is critical for simulating integrated surface water/groundwater systems. **Mover (MVR)**: The Mover package can be used to explicitly transfer water between a lake and another feature (like another lake, an SFR reach, or a specific set of cells), which is useful for representing engineered diversions or complex connections. **Unsaturated Zone Flow (UZF)**: Runoff generated from the UZF package can be routed to a lake, providing another key inflow term.","The `mfutllaktab` module provides the `ModflowUtllaktab` class, a utility for creating the **LAKTAB file** required by the MODFLOW 6 Lake (LAK) Package. Its specific purpose is to define the geometric and physical properties of a lake as a table of values. This table typically contains the **stage-area-volume-conductance** relationship for a lake.

MODFLOW 6 uses this table to look up the lake's surface area, volume, and bed conductance based on the simulated lake stage at each time step. This is essential for accurately simulating the lake's water budget, including changes in storage, evaporation, and interaction with the underlying groundwater system.

This module does not represent a standalone package like LAK or a solver like IMS. Instead, it is a helper or ""utility"" class that constructs a specific, detailed input file used *by* the LAK package when the `TABLEINPUT` option is specified. This approach is used for lakes with complex bathymetry that cannot be represented by a simple geometric shape."
mfutlncf.py,NCF,"NCF mf6 ModflowUtlncf defines a NCF package.

Parameters
----------
wkt : [string]
    is the coordinate reference system (crs) well-known text (wkt) string. ignored
    if latitude and longitude griddata arrays have been provided for
    netcdf_structured export type.
deflate : integer
    is the variable deflate level (0=min, 9=max) in the netcdf file. defining this
    parameter activates per-variable compression at the level specified.
shuffle : keyword
    is the keyword used to turn on the netcdf  The `flopy/mf6/modflow/mfutlncf.py` module provides the Python interface for the **MODFLOW 6 NetCDF (NCF) Package**.

The primary purpose of the NCF package is to **control output**, specifically to export simulation results directly into the **NetCDF (Network Common Data Form) format**. NetCDF is a self-describing, machine-independent data format that is a standard for storing and sharing array-oriented scientific data.

This module is a **utility package**, not a core modeling package. It does not simulate any physical processes. Its sole function is to instruct MODFLOW 6 how to write output.

Key distinctions:
-   **Not a Solver:** It is entirely separate from solvers like the Iterative Matrix Solver (`IMS`) or the Sparse Matrix Solver (`SMS`), which are responsible for solving the system of linear equations.
-   **Not a Process Package:** It does not define physical properties of the aquifer like the Node Property Flow (`NPF`) package, nor does it represent hydrologic processes like the Unsaturated Zone Flow (`UZF`) package.
-   **Not a Boundary Condition:** It does not represent fluxes into or out of the model, such as the Well (`WEL`) or Recharge (`RCH`) packages.

In essence, a user configures the NCF package to ""listen"" for specific outputs that are being generated by MODFLOW (like heads or cell-by-cell budget flows) and re-routes them into a structured `.nc` file, often alongside valuable metadata like coordinate information and variable descriptions. **Scenario 1: Seamless Post-Processing and Visualization** **Scenario 2: Managing Large-Scale Transient Model Output** **Scenario 3: Creating Self-Describing Model Archives and Deliverables** **Related Concept 1: Output Control (OC) Package** **Related Concept 2: Binary Output Files (`.hds`, `.cbc`)** **Related Concept 3: Post-Processing Libraries (`xarray`, `netCDF4`)**","The `flopy/mf6/modflow/mfutlncf.py` module provides the Python interface for the **MODFLOW 6 NetCDF (NCF) Package**.

The primary purpose of the NCF package is to **control output**, specifically to export simulation results directly into the **NetCDF (Network Common Data Form) format**. NetCDF is a self-describing, machine-independent data format that is a standard for storing and sharing array-oriented scientific data.

This module is a **utility package**, not a core modeling package. It does not simulate any physical processes. Its sole function is to instruct MODFLOW 6 how to write output.

Key distinctions:
-   **Not a Solver:** It is entirely separate from solvers like the Iterative Matrix Solver (`IMS`) or the Sparse Matrix Solver (`SMS`), which are responsible for solving the system of linear equations.
-   **Not a Process Package:** It does not define physical properties of the aquifer like the Node Property Flow (`NPF`) package, nor does it represent hydrologic processes like the Unsaturated Zone Flow (`UZF`) package.
-   **Not a Boundary Condition:** It does not represent fluxes into or out of the model, such as the Well (`WEL`) or Recharge (`RCH`) packages.

In essence, a user configures the NCF package to ""listen"" for specific outputs that are being generated by MODFLOW (like heads or cell-by-cell budget flows) and re-routes them into a structured `.nc` file, often alongside valuable metadata like coordinate information and variable descriptions."
mfutlobs.py,OBS,"OBS mf6 ModflowUtlobs defines a OBS package.

Parameters
----------
digits : integer
    keyword and an integer digits specifier used for conversion of simulated values
    to text on output. if not specified, the default is the maximum number of
    digits stored in the program (as written with the g0 fortran specifier). when
    simulated values are written to a comma-separated value text file specified in
    a continuous block below, the digits specifier controls the number of
    significant digits The `mfutlobs.py` module implements the **MODFLOW 6 Observations Utility (OBS)**. This is not a solver or a package that simulates a physical process (like a river or well). Instead, its primary purpose is to **collect, process, and output data that compares model-simulated values to field-measured data.**

In MODFLOW 6, observations (like measured water levels in a well or streamflow at a gage) are defined within the packages that simulate the relevant process. For example:
-   Head observations are defined in the Storage Package (`STO`).
-   Streamflow observations are defined in the Streamflow Routing Package (`SFR`).
-   Lake stage observations are defined in the Lake Package (`LAK`).

The OBS utility, managed by this module, acts as a central hub. It gathers all these individual observation definitions from across the entire model and writes them into a single observation input file (`.obs`). It also controls how the corresponding simulated values are written to output files during the model run.

This functionality is absolutely critical for:
1.  **Model Calibration:** Systematically comparing model results against real-world measurements to evaluate model performance and adjust parameters.
2.  **Parameter Estimation:** Providing the necessary input and output files for automated parameter estimation software like PEST or PEST++.
3.  **Uncertainty Analysis:** Defining predictive ""observations"" at key locations to quantify the uncertainty of model predictions. **Scenario 1: Calibrating a Groundwater Flow Model to Piezometer Data** **Scenario 2: Assessing Surface Water - Groundwater Interaction with Streamgage Data** **Scenario 3: Setting Up a Model for Automated PEST Calibration** **Package-Level Observation Blocks (`-OBS`)**: This is the most important related concept. The `mfutlobs` module doesn't define the observations themselves; it processes observations defined elsewhere. Hydrologists must first add observation blocks (e.g., `head_obs`, `flow_obs`, `stage_obs`) to the data of other packages like `ModflowGwfsto`, `ModflowGwfsfr`, or `ModflowGwflak`. This OBS utility then collects them all. **Parameter Estimation Software (PEST, PEST++)**: The OBS utility is designed to work hand-in-hand with software like PEST. The output format of the observation files is tailored for easy parsing by these programs, making `mfutlobs` a cornerstone of any automated calibration or uncertainty analysis workflow. **Time Series Utility (`UTL-TS`)**: Many real-world observations are transient (e.g., daily head measurements). These are supplied to MODFLOW 6 using Time Series files. When defining a transient observation (e.g., a hydrograph), the user provides the observed values in a time series block and references it by name in the package-level observation block. The `mfutlobs` module ensures these time-varying observed values are correctly processed.","The `mfutlobs.py` module implements the **MODFLOW 6 Observations Utility (OBS)**. This is not a solver or a package that simulates a physical process (like a river or well). Instead, its primary purpose is to **collect, process, and output data that compares model-simulated values to field-measured data.**

In MODFLOW 6, observations (like measured water levels in a well or streamflow at a gage) are defined within the packages that simulate the relevant process. For example:
-   Head observations are defined in the Storage Package (`STO`).
-   Streamflow observations are defined in the Streamflow Routing Package (`SFR`).
-   Lake stage observations are defined in the Lake Package (`LAK`).

The OBS utility, managed by this module, acts as a central hub. It gathers all these individual observation definitions from across the entire model and writes them into a single observation input file (`.obs`). It also controls how the corresponding simulated values are written to output files during the model run.

This functionality is absolutely critical for:
1.  **Model Calibration:** Systematically comparing model results against real-world measurements to evaluate model performance and adjust parameters.
2.  **Parameter Estimation:** Providing the necessary input and output files for automated parameter estimation software like PEST or PEST++.
3.  **Uncertainty Analysis:** Defining predictive ""observations"" at key locations to quantify the uncertainty of model predictions."
mfutlsfrtab.py,sfrtab,"mf6 ModflowUtlsfrtab defines a SFRTAB package.

Parameters
----------
nrow : integer
    integer value specifying the number of rows in the reach cross-section table.
    there must be nrow rows of data in the table block.
ncol : integer
    integer value specifying the number of columns in the reach cross-section
    table. there must be ncol columns of data in the table block. ncol must be
    equal to 2 if manfraction is not specified or 3 otherwise.
table : [list] This module, `mfutlsfrtab.py`, implements the `ModflowUtlsfrtab` class, which is designed to create the **MODFLOW 6 Streamflow Routing (SFR) Tabular Data File**. This is a utility file, indicated by the `UTL` prefix in its MODFLOW 6 name (`UTL-SFRTAB`), that works as an optional companion to the main SFR package.

The specific purpose of this module is to allow a user to define key hydraulic properties of a stream reach not as a single constant value, but as a function of depth. This is specified in one or more tables. The properties that can be defined this way are:

1.  **Manning's Roughness Coefficient (n):** This allows for a more physically realistic representation of channels where roughness changes with flow depth, such as in compound channels with vegetated floodplains.
2.  **Streambed Hydraulic Conductivity (K):** This allows the vertical hydraulic conductivity of the streambed material to vary with depth below the channel bottom, which can be important for accurately simulating stream-aquifer seepage.

In essence, this module provides the tools to move beyond simplified channel representations and incorporate more detailed, depth-dependent hydraulic characteristics into an SFR simulation, leading to more accurate calculations of stage, flow velocity, and groundwater interaction. It is not a solver or a standalone boundary condition package but rather a support module that enhances the capability of the SFR package. **Scenario 1: Modeling Rivers with Floodplains** **Scenario 2: Detailed Stream-Aquifer Interaction Analysis** **Scenario 3: Calibrating to a Measured Rating Curve** **MODFLOW 6 Streamflow Routing (SFR) Package:** This is the primary related concept. `ModflowUtlsfrtab` is entirely dependent on and provides optional, advanced functionality for the SFR package. The SFR package simulates one-dimensional surface water flow in streams and canals and their hydraulic connection to the groundwater model grid. The tables created by `mfutlsfrtab` are referenced within the main SFR input data to define the properties of specific reaches. **Manning's Equation:** This fundamental hydraulic equation is used by SFR to calculate flow velocity and conveyance in open channels. The equation is: `Q = (1/n) * A * R^(2/3) * S^(1/2)`, where `n` is Manning's roughness coefficient. `ModflowUtlsfrtab` provides a mechanism to make the `n` term in this equation a variable that depends on flow depth, rather than a fixed constant, which is critical for modeling channels with complex cross-sections. **Unsaturated Zone Flow (UZF) Package:** In integrated surface-water/groundwater models, the UZF package is often used to simulate infiltration and runoff generation from precipitation. Runoff that cannot infiltrate is often routed to the nearest SFR reach. The accuracy of the SFR simulation—enhanced by using realistic, depth-dependent roughness from `ModflowUtlsfrtab`—directly impacts how this runoff is conveyed downstream, affecting flood peaks and the potential for re-infiltration.","This module, `mfutlsfrtab.py`, implements the `ModflowUtlsfrtab` class, which is designed to create the **MODFLOW 6 Streamflow Routing (SFR) Tabular Data File**. This is a utility file, indicated by the `UTL` prefix in its MODFLOW 6 name (`UTL-SFRTAB`), that works as an optional companion to the main SFR package.

The specific purpose of this module is to allow a user to define key hydraulic properties of a stream reach not as a single constant value, but as a function of depth. This is specified in one or more tables. The properties that can be defined this way are:

1.  **Manning's Roughness Coefficient (n):** This allows for a more physically realistic representation of channels where roughness changes with flow depth, such as in compound channels with vegetated floodplains.
2.  **Streambed Hydraulic Conductivity (K):** This allows the vertical hydraulic conductivity of the streambed material to vary with depth below the channel bottom, which can be important for accurately simulating stream-aquifer seepage.

In essence, this module provides the tools to move beyond simplified channel representations and incorporate more detailed, depth-dependent hydraulic characteristics into an SFR simulation, leading to more accurate calculations of stage, flow velocity, and groundwater interaction. It is not a solver or a standalone boundary condition package but rather a support module that enhances the capability of the SFR package."
mfutlspc.py,SPC,"SPC mf6 ModflowUtlspc defines a SPC package.

Parameters
----------
print_input : keyword
    keyword to indicate that the list of spc information will be written to the
    listing file immediately after it is read.
timeseries : record ts6 filein ts6_filename
    Contains data for the ts package. Data can be passed as a dictionary to the ts
    package with variable names as keys and package data as values. Data for the
    timeseries variable is also acceptable. See ts package documentation for more
  The `mfutlspc.py` module implements the **Specific Storage (SPC) Package** for a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to define the storage properties of the aquifer system, which govern how much water is released from or taken into storage as groundwater levels (heads) change over time.

This package is fundamental for **transient simulations**. It provides the coefficients for the storage term ($\frac{\partial h}{\partial t}$) in the groundwater flow equation.

Specifically, the SPC package defines two key physical properties on a cell-by-cell basis:

1.  **Specific Storage (`ss`)**: A property of confined aquifers, representing the volume of water released from storage per unit volume of aquifer per unit decline in hydraulic head. It has units of [L⁻¹]. This value is used for cells that are and remain confined.
2.  **Specific Yield (`sy`)**: A property of unconfined aquifers, representing the volume of water released from storage per unit surface area of the aquifer per unit decline in the water table. It is a dimensionless value. This value is used for cells that are unconfined or may become unconfined during the simulation.

**Crucially, this is a *package*, not a *solver*.** The SPC package provides physical parameters (storage coefficients) to the GWF model. The actual numerical solution of the resulting system of equations is handled by a separate solver package, such as the Iterative Model Solution (IMS) package, which is configured at the simulation level. **Scenario 1: Simulating Drawdown from a Pumping Well** **Scenario 2: Modeling Aquifer Storage and Recovery (ASR) System Performance** **Scenario 3: Evaluating Land Subsidence Risk or Managed Aquifer Recharge (MAR)** **`ModflowGwfsto` (Storage Package)**: This is the primary alternative to the SPC package in MODFLOW 6. The STO package is simpler, defining storage via a generic storage coefficient (`sc1`) which can represent either storativity (for confined layers) or specific yield (for unconfined layers). SPC is more physically-based and flexible because it explicitly separates `ss` and `sy`, and `ss` is defined per unit thickness, making it independent of the layer thickness which can vary across the model. **`ModflowGwfnpf` (Node Property Flow Package)**: NPF defines the transmissive properties of the aquifer (hydraulic conductivity: `k`, `k22`, `k33`). Storage (from SPC) and transmissivity (from NPF) are the two fundamental hydraulic properties that define the aquifer's response to stresses. They are the core components of the groundwater flow equation solved by the model. The `icelltype` parameter in NPF, which determines if a layer is confined, unconfined, or convertible, directly controls whether MODFLOW 6 uses the `ss` or `sy` value from the SPC package for a given cell. **`ModflowTdis` (Temporal Discretization Package)**: The SPC package is only meaningful in the context of a transient simulation. The TDIS package is where the user defines the timing of the simulation—stress period lengths, number of time steps, and whether a stress period is transient or steady-state. A model must have transient stress periods defined in TDIS for the data in the SPC package to be utilized. **Transient vs. Steady-State Simulation**: This is a fundamental modeling concept. In a steady-state simulation, storage terms are zero because heads are not changing over time. Therefore, the SPC package is not required and would be ignored if included. It is **required** only when one or more stress periods are defined as transient in the TDIS package.","The `mfutlspc.py` module implements the **Specific Storage (SPC) Package** for a MODFLOW 6 Groundwater Flow (GWF) Model. Its primary purpose is to define the storage properties of the aquifer system, which govern how much water is released from or taken into storage as groundwater levels (heads) change over time.

This package is fundamental for **transient simulations**. It provides the coefficients for the storage term ($\frac{\partial h}{\partial t}$) in the groundwater flow equation.

Specifically, the SPC package defines two key physical properties on a cell-by-cell basis:

1.  **Specific Storage (`ss`)**: A property of confined aquifers, representing the volume of water released from storage per unit volume of aquifer per unit decline in hydraulic head. It has units of [L⁻¹]. This value is used for cells that are and remain confined.
2.  **Specific Yield (`sy`)**: A property of unconfined aquifers, representing the volume of water released from storage per unit surface area of the aquifer per unit decline in the water table. It is a dimensionless value. This value is used for cells that are unconfined or may become unconfined during the simulation.

**Crucially, this is a *package*, not a *solver*.** The SPC package provides physical parameters (storage coefficients) to the GWF model. The actual numerical solution of the resulting system of equations is handled by a separate solver package, such as the Iterative Model Solution (IMS) package, which is configured at the simulation level."
mfutlspca.py,SPCA,"SPCA mf6 ModflowUtlspca defines a SPCA package.

Parameters
----------
readasarrays : keyword
    indicates that array-based input will be used for the spc package.  this
    keyword must be specified to use array-based input.  when readasarrays is
    specified, values must be provided for every cell within a model layer, even
    those cells that have an idomain value less than one.  values assigned to cells
    with idomain values less than one are not used and have no effect on simulation
    results The `flopy.mf6.modflow.mfutlspca` module provides the Python interface for the **Sparse Preconditioned Conjugate Gradient with ADI Preconditioner (SPCA)** package in MODFLOW 6.

This module **is a numerical solver component**, not a package that simulates a physical process. Its specific purpose is to solve the large, sparse, symmetric system of linear equations (`Ax = b`) that results from the finite-difference discretization of the groundwater flow equation.

Key characteristics:
- **Solver Type:** It is a **linear equation solver**. It uses the Preconditioned Conjugate Gradient (PCG) method.
- **Preconditioner:** The ""A"" in SPCA stands for its specific preconditioning method: **Alternating Direction Implicit (ADI)**. This preconditioner is particularly effective for certain types of grid structures and anisotropy.
- **Role in Simulation:** The `SPCA` package is not used on its own. It is a component that works under the umbrella of the main **Sparse Matrix Solver (SMS)** package. The user configures `SMS` to use `SPCA` as its ""linear accelerator"" to perform the core mathematical calculations for finding the head solution at each time step.
- **Distinction from Physical Packages:** Unlike packages such as Well (`WEL`), Recharge (`RCH`), or Unsaturated Zone Flow (`UZF`), `SPCA` does not represent a physical component of the aquifer system. Instead, it is part of the computational engine that makes the simulation run. **Scenario 1: Troubleshooting a Non-Converging Model** **Scenario 2: Optimizing Models with Strong Anisotropy or Grid Aspect Ratios** **Scenario 3: Fine-Tuning Performance for Computationally Intensive Models** **Sparse Matrix Solver (SMS) Package (`flopy.mf6.ModflowSms`)** **Other Linear Accelerators (BICGSTAB, PCG)** **The Groundwater Flow (GWF) Model (`flopy.mf6.ModflowGwf`)**","The `flopy.mf6.modflow.mfutlspca` module provides the Python interface for the **Sparse Preconditioned Conjugate Gradient with ADI Preconditioner (SPCA)** package in MODFLOW 6.

This module **is a numerical solver component**, not a package that simulates a physical process. Its specific purpose is to solve the large, sparse, symmetric system of linear equations (`Ax = b`) that results from the finite-difference discretization of the groundwater flow equation.

Key characteristics:
- **Solver Type:** It is a **linear equation solver**. It uses the Preconditioned Conjugate Gradient (PCG) method.
- **Preconditioner:** The ""A"" in SPCA stands for its specific preconditioning method: **Alternating Direction Implicit (ADI)**. This preconditioner is particularly effective for certain types of grid structures and anisotropy.
- **Role in Simulation:** The `SPCA` package is not used on its own. It is a component that works under the umbrella of the main **Sparse Matrix Solver (SMS)** package. The user configures `SMS` to use `SPCA` as its ""linear accelerator"" to perform the core mathematical calculations for finding the head solution at each time step.
- **Distinction from Physical Packages:** Unlike packages such as Well (`WEL`), Recharge (`RCH`), or Unsaturated Zone Flow (`UZF`), `SPCA` does not represent a physical component of the aquifer system. Instead, it is part of the computational engine that makes the simulation run."
mfutltas.py,TAS,"TAS mf6 ModflowUtltas defines a TAS package.

Parameters
----------
time_series_namerecord : (name, time_series_name)
    xxx
    * name : keyword
            xxx
    * time_series_name : [string]
            Name by which a package references a particular time-array series. The name
            must be unique among all time-array series used in a package.

interpolation_methodrecord : (method, interpolation_method)
    xxx
    * method : keyword
             xxx
    * interpolation_method : string
     The `mfutltas.py` module implements the **Time Array Series (TAS)** package for MODFLOW 6. This is a **utility package**, not a package that simulates a physical process (like groundwater flow) or a numerical solver. Its sole purpose is to define time-varying data in a structured, reusable format.

In MODFLOW 6, instead of specifying a different value for a boundary condition (like recharge rate or pumping rate) for every single stress period, you can define a single time series of values. Then, other packages can simply refer to that time series by name. The TAS package is the component that writes the `*.tas` input file containing these definitions.

Key functionalities provided by the TAS package include:

-   **Data Reusability:** A single time series (e.g., daily rainfall) can be defined once in the TAS file and then used by multiple packages, such as Recharge (RCH) and Unsaturated Zone Flow (UZF). This reduces data duplication and simplifies model updates.
-   **Model Clarity:** It separates the definition of time-dependent data from its application. The RCH package file becomes simpler, merely pointing to a named time series, while the complex temporal data resides in the dedicated TAS file.
-   **Interpolation Control:** It allows the user to specify how MODFLOW 6 should obtain values at times that fall between the points defined in the series. The two primary methods are:
    -   `STEPWISE`: Use the value from the most recent time point (constant until the next point). This is typical for pumping rates or recharge rates that are constant over a day or month.
    -   `LINEAR`: Linearly interpolate between the two nearest time points. This is useful for smoothly varying boundary conditions like river stages during a storm hydrograph.

In summary, `mfutltas` is a data management utility for creating efficient, readable, and maintainable MODFLOW 6 models with transient (time-varying) inputs. **Scenario 1: Applying Climate Data to Multiple Packages** **Scenario 2: Modeling Wells with Complex Pumping Schedules** **Scenario 3: Simulating a Dynamic River Stage Boundary** **MODFLOW 6 Stress Period Data:** The TAS package provides a modern alternative to the traditional method of specifying transient data. In older MODFLOW versions (and still as an option in MODFLOW 6), users had to provide a value for each boundary condition feature (e.g., each well) for every stress period. The TAS package allows you to replace that numeric value with a *string* (the time series name), letting MODFLOW 6 handle the value lookup. **The `timeseries` FloPy Argument:** In practice, users often don't instantiate the `ModflowUtltas` class directly. Instead, they provide the time series data to the `timeseries` argument of the package that will use it (e.g., `flopy.mf6.ModflowGwfWel(..., timeseries=ts_data)`). FloPy then automatically collects all such time series data from all packages, creates a single `ModflowUtltas` object, and writes the `my_model.tas` file. This convenient abstraction is the most common way to interact with the TAS functionality. The data is typically provided as a list of tuples: `[('ts_name', 'time', 'value', 'interpolation_method'), ...]`. **TDIS (Time Discretization) Package:** The TAS package is intrinsically linked to the TDIS package. The `time` values specified in the TAS file must be in the same time units (e.g., days, seconds) as defined in the `TDIS` options block (`time_units`). A mismatch in units is a common source of error where the model runs but produces incorrect results because the boundary conditions are applied on the wrong time scale.","The `mfutltas.py` module implements the **Time Array Series (TAS)** package for MODFLOW 6. This is a **utility package**, not a package that simulates a physical process (like groundwater flow) or a numerical solver. Its sole purpose is to define time-varying data in a structured, reusable format.

In MODFLOW 6, instead of specifying a different value for a boundary condition (like recharge rate or pumping rate) for every single stress period, you can define a single time series of values. Then, other packages can simply refer to that time series by name. The TAS package is the component that writes the `*.tas` input file containing these definitions.

Key functionalities provided by the TAS package include:

-   **Data Reusability:** A single time series (e.g., daily rainfall) can be defined once in the TAS file and then used by multiple packages, such as Recharge (RCH) and Unsaturated Zone Flow (UZF). This reduces data duplication and simplifies model updates.
-   **Model Clarity:** It separates the definition of time-dependent data from its application. The RCH package file becomes simpler, merely pointing to a named time series, while the complex temporal data resides in the dedicated TAS file.
-   **Interpolation Control:** It allows the user to specify how MODFLOW 6 should obtain values at times that fall between the points defined in the series. The two primary methods are:
    -   `STEPWISE`: Use the value from the most recent time point (constant until the next point). This is typical for pumping rates or recharge rates that are constant over a day or month.
    -   `LINEAR`: Linearly interpolate between the two nearest time points. This is useful for smoothly varying boundary conditions like river stages during a storm hydrograph.

In summary, `mfutltas` is a data management utility for creating efficient, readable, and maintainable MODFLOW 6 models with transient (time-varying) inputs."
mfutlts.py,ts,"mf6 ModflowUtlts defines a TS package.

Parameters
----------
time_series_namerecord : (names, time_series_names)
    xxx
    * names : keyword
            xxx
    * time_series_names : [string]
            Name by which a package references a particular time-array series. The name
            must be unique among all time-array series used in a package.

interpolation_methodrecord : (methods, interpolation_method)
    xxx
    * methods : keyword
             xxx
    * interpolation_method : [string The `mfutlts.py` module serves as the FloPy interface for the **MODFLOW 6 Time-Series (UTS) Utility**. This is not a package that simulates a physical process (like Recharge `RCH` or Wells `WEL`), nor is it a solver (like the Iterative Matrix Solver `IMS`). Instead, the UTS is a powerful utility designed to **efficiently manage and read time-varying data from external files**.

The primary purpose of the UTS utility is to centralize time-series information, preventing data duplication and simplifying model management. A user can define a time series (e.g., daily rainfall rates, monthly pumping rates, observed water levels) once in a simple text file. This text file is then ""registered"" with the model using the UTS package. Other packages, such as `RCH`, `WEL`, `EVT`, `RIV`, and `OBS`, can then reference this data by name rather than having the data embedded within their own input files.

Key features and purposes include:

- **Data Reusability:** A single time-series file (e.g., `pumping_schedule.ts`) can be referenced by multiple wells in the `WEL` package or even used in different models.
- **Simplified Input Files:** Stress packages like `RCH` and `WEL` become much cleaner and smaller, as they only contain a reference to a time series instead of potentially thousands of lines of transient data.
- **Centralized Data Management:** Updating a pumping schedule or a recharge sequence only requires editing one external file, ensuring consistency across all parts of the model that use it.
- **Interpolation Control:** The UTS utility allows the user to specify how MODFLOW should interpolate values between the time points given in the file. Common methods include `STEPWISE` (value is constant until the next time point) and `LINEAR` (value is linearly interpolated between time points).

In FloPy, the `ModflowUtlts` class represents the UTS package file itself. It manages a list of external time-series files that the simulation will use. **Scenario 1: Managing Transient Recharge for a Long-Term Simulation** **Scenario 2: Simulating a Complex Wellfield with Shared Pumping Schedules** **Scenario 3: Separating Calibration Data from Model Input** **Time Discretization (TDIS)**: The UTS package is intrinsically linked to the `TDIS` package. The time values specified in the external `.ts` files must be in the same units and relative to the same starting point as the simulation time defined in `TDIS`. The interpolation methods in UTS (`STEPWISE`, `LINEAR`) determine how values are applied across the stress periods and time steps defined in `TDIS`. **Boundary Condition & Stress Packages (WEL, RCH, RIV, etc.)**: The primary consumers of the UTS utility are the packages that apply time-varying stresses to the model. Packages like `WEL` (wells), `RCH` (recharge), `EVT` (evapotranspiration), `GHB` (general-head boundary), and `RIV` (river) can all use the `TIMESERIES` keyword in their period data block to reference data managed by `mfutlts`. This is the core mechanism that connects the utility to the physical simulation. **Observation Utility (OBS)**: As shown in Scenario 3, the `OBS` utility is another key related concept. It uses time series to define the observed values (e.g., head, flow) that the model's simulated results are compared against. This is fundamental for model calibration and validation.","The `mfutlts.py` module serves as the FloPy interface for the **MODFLOW 6 Time-Series (UTS) Utility**. This is not a package that simulates a physical process (like Recharge `RCH` or Wells `WEL`), nor is it a solver (like the Iterative Matrix Solver `IMS`). Instead, the UTS is a powerful utility designed to **efficiently manage and read time-varying data from external files**.

The primary purpose of the UTS utility is to centralize time-series information, preventing data duplication and simplifying model management. A user can define a time series (e.g., daily rainfall rates, monthly pumping rates, observed water levels) once in a simple text file. This text file is then ""registered"" with the model using the UTS package. Other packages, such as `RCH`, `WEL`, `EVT`, `RIV`, and `OBS`, can then reference this data by name rather than having the data embedded within their own input files.

Key features and purposes include:

- **Data Reusability:** A single time-series file (e.g., `pumping_schedule.ts`) can be referenced by multiple wells in the `WEL` package or even used in different models.
- **Simplified Input Files:** Stress packages like `RCH` and `WEL` become much cleaner and smaller, as they only contain a reference to a time series instead of potentially thousands of lines of transient data.
- **Centralized Data Management:** Updating a pumping schedule or a recharge sequence only requires editing one external file, ensuring consistency across all parts of the model that use it.
- **Interpolation Control:** The UTS utility allows the user to specify how MODFLOW should interpolate values between the time points given in the file. Common methods include `STEPWISE` (value is constant until the next time point) and `LINEAR` (value is linearly interpolated between time points).

In FloPy, the `ModflowUtlts` class represents the UTS package file itself. It manages a list of external time-series files that the simulation will use."
mfutltvk.py,TVK,"TVK mf6 ModflowUtltvk defines a TVK package.

Parameters
----------
print_input : keyword
    keyword to indicate that information for each change to the hydraulic
    conductivity in a cell will be written to the model listing file.
timeseries : record ts6 filein ts6_filename
    Contains data for the ts package. Data can be passed as a dictionary to the ts
    package with variable names as keys and package data as values. Data for the
    timeseries variable is also acceptable. See ts package documen The `mfutltvk.py` module implements the **Time-Variant Specified K (TVK)** package for MODFLOW 6. This is an auxiliary package whose sole purpose is to allow the user to specify changes in aquifer hydraulic conductivity (K) over time during a simulation.

Key characteristics of the TVK package:
- **It is not a standalone package:** It functions as a ""utility"" or a helper package that is explicitly linked to and used by the **Node Property Flow (NPF)** package. The NPF package defines the fundamental hydraulic properties of the grid cells, and the TVK package provides a mechanism to override these properties in specific cells during specific time periods.
- **It modifies a material property:** Unlike boundary condition packages (e.g., Well, River) that add or remove water, or solver packages (e.g., IMS) that solve the mathematical equations, TVK directly modifies a physical property of the aquifer matrix itself.
- **Functionality:** The user provides a list of cell identifiers (`cellid`) and their new hydraulic conductivity values for one or more stress periods. The TVK package can modify the horizontal hydraulic conductivity (`Kx`), the hydraulic conductivity along rows (`K22`), and the vertical hydraulic conductivity (`K33`). When a TVK value is specified for a cell, it supersedes the value provided in the NPF package for that stress period.

In essence, this module provides the FloPy framework to create, read, and write the input file for the MODFLOW 6 TVK package, enabling time-dependent hydraulic conductivity in a groundwater model. **Scenario 1: Modeling Land Subsidence and Aquifer Compaction** **Scenario 2: Simulating Freeze-Thaw Cycles in Permafrost Regions** **Scenario 3: Evaluating Geotechnical Grouting Impacts** **Node Property Flow (NPF) Package (`flopy.mf6.ModflowGwfnpf`)** **Time Discretization (TDIS) Package (`flopy.mf6.ModflowTdis`)** **Time Series Utility (`flopy.mf6.ModflowUtlts`)**","The `mfutltvk.py` module implements the **Time-Variant Specified K (TVK)** package for MODFLOW 6. This is an auxiliary package whose sole purpose is to allow the user to specify changes in aquifer hydraulic conductivity (K) over time during a simulation.

Key characteristics of the TVK package:
- **It is not a standalone package:** It functions as a ""utility"" or a helper package that is explicitly linked to and used by the **Node Property Flow (NPF)** package. The NPF package defines the fundamental hydraulic properties of the grid cells, and the TVK package provides a mechanism to override these properties in specific cells during specific time periods.
- **It modifies a material property:** Unlike boundary condition packages (e.g., Well, River) that add or remove water, or solver packages (e.g., IMS) that solve the mathematical equations, TVK directly modifies a physical property of the aquifer matrix itself.
- **Functionality:** The user provides a list of cell identifiers (`cellid`) and their new hydraulic conductivity values for one or more stress periods. The TVK package can modify the horizontal hydraulic conductivity (`Kx`), the hydraulic conductivity along rows (`K22`), and the vertical hydraulic conductivity (`K33`). When a TVK value is specified for a cell, it supersedes the value provided in the NPF package for that stress period.

In essence, this module provides the FloPy framework to create, read, and write the input file for the MODFLOW 6 TVK package, enabling time-dependent hydraulic conductivity in a groundwater model."
mfutltvs.py,TVS,"TVS mf6 ModflowUtltvs defines a TVS package.

Parameters
----------
disable_storage_change_integration : keyword
    keyword that deactivates inclusion of storage derivative terms in the sto
    package matrix formulation.  in the absence of this keyword (the default), the
    groundwater storage formulation will be modified to correctly adjust heads
    based on transient variations in stored water volumes arising from changes to
    ss and sy properties.
print_input : keyword
    keyword to indicate t The `mfutltvs.py` module serves as the FloPy interface for the **MODFLOW 6 Time-Variant Specified (TVS) Input** utility. The TVS package is not a standalone modeling package (like a boundary condition or a solver) but is a **data input utility** that provides a powerful and organized way to define time-varying multipliers.

Specifically, its purpose is to:
1.  **Define Time-Varying Multipliers:** Create a dataset where a multiplier value is specified for different points in simulation time.
2.  **Decouple Temporal Patterns from Spatial Locations:** The TVS file defines a temporal pattern (e.g., a seasonal pumping schedule) independently of where that pattern is applied.
3.  **Promote Reusability:** A single TVS file defining a common pattern can be referenced by many different features in other packages. For example, hundreds of irrigation wells can all reference the same TVS file that describes a monthly irrigation schedule.
4.  **Simplify Input for Stress Packages:** Instead of listing new rates for every well, drain, or river reach in every stress period, a user can specify a base rate in the stress package (e.g., `flopy.mf6.ModflowGwfwell`) and use the TVS multiplier to scale that rate through time.

The TVS package works in conjunction with stress packages like the Well (WEL), Recharge (RCH), Evapotranspiration (EVT), General-Head Boundary (GHB), and Drain (DRN) packages. It is an alternative to embedding all transient data within the stress package's `PERIOD` block or using the Time Series (TS) utility. Unlike Time Series which provides the *actual value* (e.g., rate or head), TVS provides a *multiplier* that scales a base value. **Scenario 1: Modeling Agricultural Irrigation Pumping** **Scenario 2: Simulating Municipal Well Field Operations with Daily Cycles** **Scenario 3: Evaluating Climate Change Impacts on Recharge** **Time Series (TS) Utility:** The TVS package is a direct alternative to the Time Series utility. The key difference is that **TVS provides a multiplier**, while **TS provides an absolute value**. A user would choose TVS when a common *pattern* of scaling is applied to many features with different base values. They would choose TS when the exact time-varying values (e.g., a specific river stage hydrograph) are known and need to be read directly. **Stress Packages (WEL, RCH, GHB, DRN, EVT):** The TVS module is functionally useless on its own. It exists solely to serve these ""parent"" packages. A user interacting with `mfutltvs.py` will always be working with at least one other stress package module (e.g., `mfwel.py`) and will link the two by specifying a `multiplier` in the stress package's input. **TDIS - Time Discretization Package:** The time values specified within the TVS file are interpreted relative to the simulation's overall time definition. The correctness of the TVS input is therefore critically dependent on the `time_units` and stress period setup defined in the Time Discretization (`TDIS`) package. A mismatch in time units between TDIS and the TVS file is a common source of error.","The `mfutltvs.py` module serves as the FloPy interface for the **MODFLOW 6 Time-Variant Specified (TVS) Input** utility. The TVS package is not a standalone modeling package (like a boundary condition or a solver) but is a **data input utility** that provides a powerful and organized way to define time-varying multipliers.

Specifically, its purpose is to:
1.  **Define Time-Varying Multipliers:** Create a dataset where a multiplier value is specified for different points in simulation time.
2.  **Decouple Temporal Patterns from Spatial Locations:** The TVS file defines a temporal pattern (e.g., a seasonal pumping schedule) independently of where that pattern is applied.
3.  **Promote Reusability:** A single TVS file defining a common pattern can be referenced by many different features in other packages. For example, hundreds of irrigation wells can all reference the same TVS file that describes a monthly irrigation schedule.
4.  **Simplify Input for Stress Packages:** Instead of listing new rates for every well, drain, or river reach in every stress period, a user can specify a base rate in the stress package (e.g., `flopy.mf6.ModflowGwfwell`) and use the TVS multiplier to scale that rate through time.

The TVS package works in conjunction with stress packages like the Well (WEL), Recharge (RCH), Evapotranspiration (EVT), General-Head Boundary (GHB), and Drain (DRN) packages. It is an alternative to embedding all transient data within the stress package's `PERIOD` block or using the Time Series (TS) utility. Unlike Time Series which provides the *actual value* (e.g., rate or head), TVS provides a *multiplier* that scales a base value."
binaryfile_utils.py,,"mf6 Wrapper class for Binary Arrays. This class enables directly getting slices
from the binary output. It is intended to be called from the __getitem__
method of the  SimulationDict() class.  Implemented to conserve memory.

Parameters
----------
path: binary file path location
mfdict: SimulationDict() object
key: dict key ex. ('flow15','CBC','FLOW RIGHT FACE')

Returns
-------
Xarray of [n,n,n,n] dimension

Usage:
-----
>>> val = MFOutput(mfdict, path, key)
>>> return val.data

User interaction:
- This module is a critical utility for **post-processing MODFLOW 6 simulation results**. Its primary purpose is to read and parse the structured binary output files generated by a MODFLOW 6 run, making the data accessible within a Python environment.

Specifically, it handles:
*   **Head Files (`.hds`):** Reading simulated head, drawdown, or other user-specified head-based outputs.
*   **Cell-by-Cell Budget Files (`.cbc`):** Reading volumetric flow rates between cells (`FLOW-JA-FACE`) and flows associated with specific boundary packages (e.g., recharge, wells, rivers).

This module is **not** a MODFLOW package (like `NPM` or `STO`) nor is it a solver (like `IMS`). It does not define any part of the groundwater model's structure or physics. Instead, it acts as a data connector or bridge, translating the compact, machine-readable binary output from MODFLOW 6 into user-friendly, multi-dimensional NumPy arrays. This allows hydrologists to perform analysis, visualization, and validation of their model results using Python's scientific computing stack (NumPy, Matplotlib, etc.). The classes `MFOutput` and `MFOutputRequester` provide a ""Pythonic"" interface, allowing users to access complex datasets with simple dictionary-like key lookups (e.g., `cbc_file['RCH']`). **Scenario 1: Visualizing Piezometric Surfaces and Drawdown** **Scenario 2: Generating Hydrographs for Observation Wells** **Scenario ాయ: Analyzing the Model-Wide Water Budget** **MODFLOW 6 Output Control (OC) Package:** This is the most critical related concept. The `binaryfile_utils.py` module can only read data that MODFLOW 6 has been instructed to write. The OC package is where the user specifies which results to save (e.g., `HEAD`, `DRAWDOWN`, `BUDGET`), how frequently to save them, and in what format (`BINARY`). If `HEAD FILEOUT` or `BUDGET FILEOUT` are not properly defined in the OC package, this utility module will have no files to read. **`flopy.mf6.MFSimulation.get_output()`:** This is the standard user-facing method for accessing the functionality of `binaryfile_utils.py`. Users typically do not instantiate `MFOutput` or `MFOutputRequester` directly. Instead, they call `sim.get_output(fpath='my_model.hds')` on their loaded simulation object. This method handles the file path resolution and returns a fully initialized `MFOutputRequester` object, ready for data requests. **NumPy Arrays:** This module's primary output format is the NumPy array. A deep understanding of NumPy is essential for effectively using the data retrieved by this module. Users must be comfortable with array shapes, indexing, slicing, and mathematical operations (e.g., `array.sum()`, `array.mean()`) to perform any meaningful analysis on the extracted model results.","This module is a critical utility for **post-processing MODFLOW 6 simulation results**. Its primary purpose is to read and parse the structured binary output files generated by a MODFLOW 6 run, making the data accessible within a Python environment.

Specifically, it handles:
*   **Head Files (`.hds`):** Reading simulated head, drawdown, or other user-specified head-based outputs.
*   **Cell-by-Cell Budget Files (`.cbc`):** Reading volumetric flow rates between cells (`FLOW-JA-FACE`) and flows associated with specific boundary packages (e.g., recharge, wells, rivers).

This module is **not** a MODFLOW package (like `NPM` or `STO`) nor is it a solver (like `IMS`). It does not define any part of the groundwater model's structure or physics. Instead, it acts as a data connector or bridge, translating the compact, machine-readable binary output from MODFLOW 6 into user-friendly, multi-dimensional NumPy arrays. This allows hydrologists to perform analysis, visualization, and validation of their model results using Python's scientific computing stack (NumPy, Matplotlib, etc.). The classes `MFOutput` and `MFOutputRequester` provide a ""Pythonic"" interface, allowing users to access complex datasets with simple dictionary-like key lookups (e.g., `cbc_file['RCH']`)."
binarygrid_util.py,,"mf6 The MfGrdFile class.

Parameters
----------
filename : str
    Name of the MODFLOW 6 binary grid file
precision : string
    'single' or 'double'.  Default is 'double'.
verbose : bool
    Write information to standard output.  Default is False.

Attributes
----------

Methods
-------

See Also
--------

Notes
-----
The MfGrdFile class provides simple ways to retrieve data from binary
MODFLOW 6 binary grid files (.grb). The binary grid file contains data
that can be used for post processing MODFL The `flopy.mf6.utils.binarygrid_util` module is a specialized utility designed for **post-processing and data visualization**. Its sole purpose is to read and parse the **MODFLOW 6 binary grid file (`.grb`)**. This file contains a complete, self-contained description of the model grid's geometry, regardless of its type.

This module is **not** a MODFLOW package and is not involved in the simulation's forward run. It does not represent a physical process (like the Unsaturated Zone Flow package, `UZF`) or a numerical solver (like the Iterative Matrix Solver, `IMS`). Instead, it's a crucial tool for interpreting model results after a simulation is complete.

The `MfGrdFile` class within this module reads the binary `.grb` file to reconstruct the model's spatial framework. This includes:

*   **Grid Type:** Identifies whether the grid is structured (`DIS`), unstructured with vertices (`DISV`), or unstructured with connections (`DISU`).
*   **Cell Geometry:** For structured grids, it provides cell dimensions. For unstructured grids, it reads the explicit coordinates of all vertices (`verts`) and the list of vertices that define each cell (`iverts`).
*   **Connectivity:** For unstructured grids, it reads the `IA` and `JA` arrays, which define the cell-to-cell connection graph (which cells are adjacent to which).
*   **Cell Properties:** It reads cell-center coordinates (`xcellcenters`, `ycellcenters`) and layer elevations (`top`, `botm`).

In essence, this module acts as the bridge between the raw binary grid output from a MODFLOW 6 simulation and a usable Python object that FloPy's plotting and analysis tools can understand. It is particularly vital for working with complex unstructured grids, whose geometry cannot be easily inferred from simple parameters like `delr` and `delc`.","The `flopy.mf6.utils.binarygrid_util` module is a specialized utility designed for **post-processing and data visualization**. Its sole purpose is to read and parse the **MODFLOW 6 binary grid file (`.grb`)**. This file contains a complete, self-contained description of the model grid's geometry, regardless of its type.

This module is **not** a MODFLOW package and is not involved in the simulation's forward run. It does not represent a physical process (like the Unsaturated Zone Flow package, `UZF`) or a numerical solver (like the Iterative Matrix Solver, `IMS`). Instead, it's a crucial tool for interpreting model results after a simulation is complete.

The `MfGrdFile` class within this module reads the binary `.grb` file to reconstruct the model's spatial framework. This includes:

*   **Grid Type:** Identifies whether the grid is structured (`DIS`), unstructured with vertices (`DISV`), or unstructured with connections (`DISU`).
*   **Cell Geometry:** For structured grids, it provides cell dimensions. For unstructured grids, it reads the explicit coordinates of all vertices (`verts`) and the list of vertices that define each cell (`iverts`).
*   **Connectivity:** For unstructured grids, it reads the `IA` and `JA` arrays, which define the cell-to-cell connection graph (which cells are adjacent to which).
*   **Cell Properties:** It reads cell-center coordinates (`xcellcenters`, `ycellcenters`) and layer elevations (`top`, `botm`).

In essence, this module acts as the bridge between the raw binary grid output from a MODFLOW 6 simulation and a usable Python object that FloPy's plotting and analysis tools can understand. It is particularly vital for working with complex unstructured grids, whose geometry cannot be easily inferred from simple parameters like `delr` and `delc`."
generate_classes.py,,"mf6 This module is **not** a tool for groundwater modelers; it is a **code generation utility for FloPy developers**. Its primary purpose is to automatically create the Python class files that represent the various MODFLOW 6 input packages within the FloPy library.

MODFLOW 6 defines the structure of its input files (e.g., for the Node Property Flow (NPF) package, the Streamflow Routing (SFR) package, etc.) using special definition files with a `.dfn` extension. These `.dfn` files are machine-readable and contain all the information about the package's data blocks, variable names, data types, and dimensions.

The `generate_classes.py` script reads these official `.dfn` files from a MODFLOW 6 distribution and translates them into fully-formed Python files. These generated files contain the `MFPackage`-derived classes that hydrologists interact with when building a model (e.g., `flopy.mf6.ModflowGwfnpf`, `flopy.mf6.ModflowGwfrch`).

In essence, this module automates the maintenance of FloPy's MODFLOW 6 interface. When USGS releases a new version of MODFLOW 6 with updated packages, FloPy developers do not need to manually write or edit the corresponding Python classes. Instead, they run this script to regenerate them, ensuring accuracy and saving significant development time. This is why the ""Package Code"" is ""Unknown""—this module doesn't represent a single MODFLOW package but is the factory that builds the Python representations for *all* of them. **Scenario 1: Updating FloPy for a new MODFLOW 6 release.** **Scenario 2: Adding support for a new, unofficial MODFLOW 6 package.** **Scenario 3: Initial development of FloPy's MF6 support.** **MODFLOW 6 Definition Files (`.dfn`)**: This is the most critical related concept. The `.dfn` files are the direct input to `generate_classes.py`. They are the specification or ""blueprint"" published by the USGS that describes the exact structure, keywords, variables, and data types for each MODFLOW 6 input file. This script is fundamentally a `.dfn` file parser and a Python code writer. **Code Generation (Metaprogramming)**: This module is a prime example of metaprogramming—writing code that writes other code. By automating class creation, it reduces human error, ensures consistency with the official MODFLOW 6 standard, and drastically simplifies library maintenance. **FloPy's Internal MF6 Class Structure (`MFPackage`, `MFBlock`, `MFData`)**: The Python code generated by this script creates classes that inherit from FloPy's internal base classes. `MFPackage` is the base class for an entire package (like NPF or RCH). `MFBlock` represents a specific data block within a package file (like the `OPTIONS` block or `GRIDDATA` block). `MFData` objects handle the actual numerical data. The `generate_classes.py` script understands this internal architecture and produces code that fits seamlessly into it. **Command-Line Interface (CLI)**: The `cli_main` function indicates this script is designed to be run from the command line, not typically imported into an interactive session. A developer would run a command like `python generate_classes.py --mf6-dev-path /path/to/mf6/dfn --flopy-path /path/to/flopy/repo` to perform the code generation.","This module is **not** a tool for groundwater modelers; it is a **code generation utility for FloPy developers**. Its primary purpose is to automatically create the Python class files that represent the various MODFLOW 6 input packages within the FloPy library.

MODFLOW 6 defines the structure of its input files (e.g., for the Node Property Flow (NPF) package, the Streamflow Routing (SFR) package, etc.) using special definition files with a `.dfn` extension. These `.dfn` files are machine-readable and contain all the information about the package's data blocks, variable names, data types, and dimensions.

The `generate_classes.py` script reads these official `.dfn` files from a MODFLOW 6 distribution and translates them into fully-formed Python files. These generated files contain the `MFPackage`-derived classes that hydrologists interact with when building a model (e.g., `flopy.mf6.ModflowGwfnpf`, `flopy.mf6.ModflowGwfrch`).

In essence, this module automates the maintenance of FloPy's MODFLOW 6 interface. When USGS releases a new version of MODFLOW 6 with updated packages, FloPy developers do not need to manually write or edit the corresponding Python classes. Instead, they run this script to regenerate them, ensuring accuracy and saving significant development time. This is why the ""Package Code"" is ""Unknown""—this module doesn't represent a single MODFLOW package but is the factory that builds the Python representations for *all* of them."
lakpak_utils.py,,"mf6 This module serves as a **utility helper** specifically for the **MODFLOW 6 Lake (LAK) Package**. It is not a simulation package or a solver itself, but rather a tool for processing and interpreting the data within a pre-existing LAK package object in a FloPy model.

The primary function of this module is to **translate the lake-aquifer connection data into a simple, standardized list**. The LAK package can define connections differently depending on the grid type:
*   For **structured grids** (DIS package), lake locations are often defined implicitly using an `idomain` array, where a cell's integer value corresponds to a lake number.
*   For **unstructured grids** (DISV, DISU packages), connections are defined explicitly by listing the model cell number (`cellid`) for each connection.

This module abstracts away that complexity. Its main function, `get_lak_connections`, inspects the model grid and the LAK package data, and returns a consistent list of `(lake_number, cell_id)` tuples. This provides a clear and direct mapping between each lake and the specific groundwater model cells it is connected to, regardless of the underlying grid structure. This is crucial for post-processing, visualization, and model verification tasks.

*   **Model Family:** mf6
*   **Package Code:** LAK **Scenario 1: Visualizing Lake Extent and Connections** **Scenario 2: Analyzing Lake-Aquifer Exchange Fluxes** **Scenario 3: Debugging Incorrect Lake Behavior** **Scenario 4: Building Interactive Model Dashboards** **MODFLOW 6 Lake (LAK) Package:** This is the primary related concept. The `lakpak_utils.py` module is entirely dependent on and designed to serve the `flopy.mf6.ModflowGwflak` object. It reads data directly from this object's attributes (`connectiondata`, `idomain`, etc.). **FloPy Grid Objects (`StructuredGrid`, `VertexGrid`):** The module's internal logic is fundamentally dependent on the model's grid type, which is stored in the `model.modelgrid` object. The utility's ability to differentiate between structured `(k, i, j)` and unstructured `node` cell identifiers is key to its function. An understanding of how FloPy handles different grid types is essential for using the output correctly. **FloPy Plotting Utilities (`flopy.plot`):** A major application of this utility is to support visualization. The list of cell IDs generated by `get_lak_connections` is a perfect input for the `plot_array()` or `plot_ibound()` methods in FloPy's plotting classes. Users can pass this list to selectively color cells and visually represent lake boundaries, connections, or related data.","This module serves as a **utility helper** specifically for the **MODFLOW 6 Lake (LAK) Package**. It is not a simulation package or a solver itself, but rather a tool for processing and interpreting the data within a pre-existing LAK package object in a FloPy model.

The primary function of this module is to **translate the lake-aquifer connection data into a simple, standardized list**. The LAK package can define connections differently depending on the grid type:
*   For **structured grids** (DIS package), lake locations are often defined implicitly using an `idomain` array, where a cell's integer value corresponds to a lake number.
*   For **unstructured grids** (DISV, DISU packages), connections are defined explicitly by listing the model cell number (`cellid`) for each connection.

This module abstracts away that complexity. Its main function, `get_lak_connections`, inspects the model grid and the LAK package data, and returns a consistent list of `(lake_number, cell_id)` tuples. This provides a clear and direct mapping between each lake and the specific groundwater model cells it is connected to, regardless of the underlying grid structure. This is crucial for post-processing, visualization, and model verification tasks.

*   **Model Family:** mf6
*   **Package Code:** LAK"
mfobservation.py,,"mf6 Wrapper class to request the MFObservation object:
Class is called by the MFSimulation.SimulationDict() class and is not
called by the user

Inputs:
-------
mfdict: (dict) the sim.simulation_dict.mfdict object for the flopy project
path: (object) the path object detailing model names and paths
key: (tuple, strings) user supplied dictionary key to request observation
utility data

Returns:
--------    self.data: (xarray) array of observations This module provides the framework and utility classes for creating and managing **MODFLOW 6 Observations**. It is not a package itself (like `DIS` or `NFP`), but rather a helper utility that is used by other FloPy packages to construct the input for the MODFLOW 6 Observation (OBS) Utility.

The primary purpose of this module is to give users a Pythonic way to define specific model outputs they want to save during a simulation run. Instead of manually formatting the text-based OBS input file, users can define observations as Python objects. These objects are then processed by other FloPy package classes (e.g., `ModflowGwfsfr`, `ModflowGwfmaw`) to write the correctly formatted `BEGIN/END OBSERVATIONS` blocks within their respective input files.

In MODFLOW 6, observations are highly flexible and can be associated with many different packages. For example, you can observe:
- **Head** at a specific cell location (related to the GWF model).
- **Flow** across a specific cell face (related to the GWF model).
- **Stage, depth, or flow** in a specific stream reach (related to the Streamflow Routing, SFR, package).
- **Water level or flow** associated with a specific well (related to the Multi-Aquifer Well, MAW, package).
- **Concentration** of a species at a specific cell (related to the GWT model).

The classes in this module, particularly `MFObservation` and `Observations`, manage the data structures needed to define these requests, which FloPy then translates into the required MODFLOW 6 input format. The `MFObservationRequester` class serves as a base class for other FloPy packages, giving them the built-in capability to handle an `observations` argument. **Scenario 1: Model Calibration against Head Data** **Scenario 2: Monitoring Stream-Aquifer Interaction** **Scenario 3: Tracking Contaminant Plume Movement** **MODFLOW 6 Observation Utility (OBS)** **Advanced Stress Packages (SFR, LAK, MAW, UZF, MVR)** **Model Calibration and Uncertainty Analysis (PEST, PEST++)**","This module provides the framework and utility classes for creating and managing **MODFLOW 6 Observations**. It is not a package itself (like `DIS` or `NFP`), but rather a helper utility that is used by other FloPy packages to construct the input for the MODFLOW 6 Observation (OBS) Utility.

The primary purpose of this module is to give users a Pythonic way to define specific model outputs they want to save during a simulation run. Instead of manually formatting the text-based OBS input file, users can define observations as Python objects. These objects are then processed by other FloPy package classes (e.g., `ModflowGwfsfr`, `ModflowGwfmaw`) to write the correctly formatted `BEGIN/END OBSERVATIONS` blocks within their respective input files.

In MODFLOW 6, observations are highly flexible and can be associated with many different packages. For example, you can observe:
- **Head** at a specific cell location (related to the GWF model).
- **Flow** across a specific cell face (related to the GWF model).
- **Stage, depth, or flow** in a specific stream reach (related to the Streamflow Routing, SFR, package).
- **Water level or flow** associated with a specific well (related to the Multi-Aquifer Well, MAW, package).
- **Concentration** of a species at a specific cell (related to the GWT model).

The classes in this module, particularly `MFObservation` and `Observations`, manage the data structures needed to define these requests, which FloPy then translates into the required MODFLOW 6 input format. The `MFObservationRequester` class serves as a base class for other FloPy packages, giving them the built-in capability to handle an `observations` argument."
model_splitter.py,,"mf6 A class for splitting a single model into a multi-model simulation

Parameters
----------
sim : flopy.mf6.MFSimulation
modelname : str, None
    name of model to split The `flopy.mf6.utils.model_splitter` module is a specialized pre-processing utility designed to automatically divide a single, large MODFLOW 6 Groundwater Flow (GWF) model into two smaller, hydraulically connected sub-models.

The primary purpose is to facilitate **local grid refinement** (LGR) or **sub-regional modeling** workflows within the MODFLOW 6 framework. Instead of a modeler manually creating two separate models and defining the complex connections between them, the `Mf6Splitter` automates this entire process.

Its key functions are:
1.  **Model Disaggregation:** It takes a single `flopy.mf6.MFModel` object and a user-defined set of cell locations that define the split boundary. It then creates two new `MFModel` objects, partitioning all the grid data (e.g., `DIS`, `DISV`) and package data between them.
2.  **Package Data Partitioning:** It intelligently iterates through the packages of the original model (e.g., `NPF`, `STO`, `IC`, `OC`) and boundary condition packages (`WEL`, `RIV`, `DRN`, `GHB`, `CHD`, etc.), assigning the data to the correct new sub-model based on cell location.
3.  **Automatic Exchange Creation:** This is the most critical function. The splitter automatically creates and parameterizes the **MODFLOW 6 GWF-GWF Exchange (`GWFGWF`) package**. This package defines the hydraulic connections between adjacent cells across the newly created model boundary, allowing water to flow seamlessly between the two sub-models.

This module is not a solver (like `IMS`) nor a standard MODFLOW package itself. It is a high-level FloPy utility that manipulates FloPy objects to generate the necessary input files for a multi-model MODFLOW 6 simulation. **Scenario 1: High-Resolution Contaminant Transport Sub-Model** **Scenario 2: Detailed Wellfield Drawdown Analysis** **Scenario 3: Sub-regional Model Handoff** **MODFLOW 6 GWF-GWF Exchange (GWFGWF Package):** This is the core MODFLOW 6 feature that the `Mf6Splitter` leverages. The `GWFGWF` package explicitly defines cell-to-cell connections between two different GWF models. The splitter's main value is in automating the creation of the `GWFGWF` connection data, which includes cell IDs from both models, connection area, and conductance terms. **Parent/Child Models and Local Grid Refinement (LGR):** This is the modeling paradigm that the `Mf6Splitter` is built to support. The concept involves a coarse-grid ""parent"" model that provides flow boundary conditions to a finer-grid ""child"" model that covers a smaller, more detailed area of interest. This is the modern MODFLOW 6 approach to LGR, replacing the dedicated LGR package of older MODFLOW versions. **MODFLOW 6 Simulation Structure (`MFSimulation`):** The splitter works by creating a new `MFSimulation` object that contains multiple `MFModel` objects. This reflects a fundamental design principle of MODFLOW 6, where a single simulation can encompass multiple interacting models (e.g., two GWF models, or a GWF and a GWT model). Understanding this hierarchical structure (`Simulation` -> `Model` -> `Package`) is essential for working with the splitter's output.","The `flopy.mf6.utils.model_splitter` module is a specialized pre-processing utility designed to automatically divide a single, large MODFLOW 6 Groundwater Flow (GWF) model into two smaller, hydraulically connected sub-models.

The primary purpose is to facilitate **local grid refinement** (LGR) or **sub-regional modeling** workflows within the MODFLOW 6 framework. Instead of a modeler manually creating two separate models and defining the complex connections between them, the `Mf6Splitter` automates this entire process.

Its key functions are:
1.  **Model Disaggregation:** It takes a single `flopy.mf6.MFModel` object and a user-defined set of cell locations that define the split boundary. It then creates two new `MFModel` objects, partitioning all the grid data (e.g., `DIS`, `DISV`) and package data between them.
2.  **Package Data Partitioning:** It intelligently iterates through the packages of the original model (e.g., `NPF`, `STO`, `IC`, `OC`) and boundary condition packages (`WEL`, `RIV`, `DRN`, `GHB`, `CHD`, etc.), assigning the data to the correct new sub-model based on cell location.
3.  **Automatic Exchange Creation:** This is the most critical function. The splitter automatically creates and parameterizes the **MODFLOW 6 GWF-GWF Exchange (`GWFGWF`) package**. This package defines the hydraulic connections between adjacent cells across the newly created model boundary, allowing water to flow seamlessly between the two sub-models.

This module is not a solver (like `IMS`) nor a standard MODFLOW package itself. It is a high-level FloPy utility that manipulates FloPy objects to generate the necessary input files for a multi-model MODFLOW 6 simulation."
output_util.py,,"mf6 A class that uses meta programming to get output

Parameters
----------
obj : PackageInterface object The `flopy.mf6.utils.output_util` module provides the `MF6Output` class, which serves as a high-level, unified interface for accessing and analyzing output data from a completed MODFLOW 6 simulation. It is a **post-processing utility**, not a package that defines model physics (like `NPF` for properties or `WEL` for wells) or a solver (like `IMS`).

Its primary function is to simplify the user's workflow after a model run. Instead of manually locating and loading various output files (heads, budgets, concentrations, etc.) with different FloPy utility classes, the user can instantiate a single `MF6Output` object. This object automatically discovers all available standard output files associated with the simulation and provides convenient methods to access their data.

Key functionalities include:
- **Automatic Discovery:** Finds binary and text-based output files (`.hds`, `.cbc`, `.grb`, `.csv`, etc.) in the simulation workspace.
- **Unified Access:** Provides intuitive methods like `.head()`, `.budget()`, `.obs()`, and `.concentration()` to load specific data types.
- **Introspection:** Offers helper methods like `.methods` and `.obs_names` that allow the user to query what output data is available for analysis, preventing guesswork and errors.

In essence, this module acts as a ""gateway"" to a model's results, streamlining data extraction, plotting, and analysis for all types of MODFLOW 6 models (Groundwater Flow, Transport, etc.). **Scenario 1: Quick Post-Run Head and Drawdown Visualization** **Scenario 2: Validating a Model with Observation Data** **Scenario 3: Analyzing a Subregional Water Budget** **`flopy.mf6.MF6Simulation`:** This is the top-level FloPy object for a MODFLOW 6 simulation. The `MF6Output` class is most commonly accessed via the helper method `MF6Simulation.get_mf6_output()`, which makes it the standard entry point for post-processing an entire simulation. **MODFLOW 6 Output Control (OC) Package:** This is the crucial input package that tells MODFLOW 6 *what* results to save, *when* to save them, and in what format. The `MF6Output` utility can only read files that the OC package has instructed MODFLOW 6 to create. If a user wants to analyze heads, they must have a `'HEAD FILE'` entry in their OC package. **`flopy.utils` File Readers (`HeadFile`, `CellBudgetFile`, `MfGrdFile`):** `MF6Output` is a wrapper that uses these lower-level file-reading classes behind the scenes. For example, when you call `mfo.head()`, the `MF6Output` class finds the head file path and instantiates a `flopy.utils.HeadFile` object for you. While an advanced user could use these classes directly, `MF6Output` provides a more convenient and integrated experience for MODFLOW 6.","The `flopy.mf6.utils.output_util` module provides the `MF6Output` class, which serves as a high-level, unified interface for accessing and analyzing output data from a completed MODFLOW 6 simulation. It is a **post-processing utility**, not a package that defines model physics (like `NPF` for properties or `WEL` for wells) or a solver (like `IMS`).

Its primary function is to simplify the user's workflow after a model run. Instead of manually locating and loading various output files (heads, budgets, concentrations, etc.) with different FloPy utility classes, the user can instantiate a single `MF6Output` object. This object automatically discovers all available standard output files associated with the simulation and provides convenient methods to access their data.

Key functionalities include:
- **Automatic Discovery:** Finds binary and text-based output files (`.hds`, `.cbc`, `.grb`, `.csv`, etc.) in the simulation workspace.
- **Unified Access:** Provides intuitive methods like `.head()`, `.budget()`, `.obs()`, and `.concentration()` to load specific data types.
- **Introspection:** Offers helper methods like `.methods` and `.obs_names` that allow the user to query what output data is available for analysis, preventing guesswork and errors.

In essence, this module acts as a ""gateway"" to a model's results, streamlining data extraction, plotting, and analysis for all types of MODFLOW 6 models (Groundwater Flow, Transport, etc.)."
postprocessing.py,,"mf6 This module serves as a utility library for **post-processing raw output files** from a MODFLOW 6 (MF6) simulation. It is not a model package (like `NPF` or `WEL`) nor a solver (like `IMS`). Its primary function is to translate low-level, machine-readable model outputs into formats that are more intuitive and useful for analysis, visualization, and debugging by a hydrologist.

Specifically, it focuses on two key post-processing tasks:

1.  **Calculating Inter-Cell Flows:** The `get_structured_faceflows` function reads the `FLOW-JA-FACE` array from a MODFLOW 6 Cell-by-Cell Budget (CBC) file. This array is a 1D list of flows between connected cells. The function intelligently uses the model's grid information to restructure this data into three separate 3D arrays representing flows across the **right**, **front**, and **lower** faces of each cell in a structured grid. This is invaluable for detailed water budget analysis and creating flow vector visualizations.

2.  **Extracting Solver Convergence Information:** The `get_residuals` function parses the text-based MODFLOW 6 Listing File (`.lst`). It extracts the head-change and flow residuals for each outer and inner iteration of the solver for every time step. This provides a detailed history of the model's convergence performance, which is essential for diagnosing numerical instability or model failure.

In summary, this module acts as a bridge, converting raw MF6 output data into actionable, human-interpretable arrays and data structures. **Scenario 1: Visualizing Drawdown and Capture Zones** **Scenario 2: Debugging a Non-Convergent Model** **Scenario 3: Performing a Detailed Sub-Regional Water Budget** **Scenario 4: Validating Automated Calibration Results** **Cell-by-Cell Budget (CBC) Files:** This is the primary data source for `get_structured_faceflows`. The function specifically requires the `'FLOW-JA-FACE'` budget term, which must be requested in the Output Control (`OC`) package of the model. `FLOW-JA-FACE` contains the flow across each connection in the model's connectivity graph (`IA`, `JA` arrays). **MODFLOW 6 Listing (LST) Files:** This is the text file that `get_residuals` parses. Its verbosity and content are controlled by the `PRINT_OPTION` in the Simulation's `TDIS` package and the `IMS` package. For `get_residuals` to work effectively, these print options should be set to `ALL` or `SUMMARY`. **Grid Objects (`StructuredGrid`, `VertexGrid`):** The `get_structured_faceflows` function is critically dependent on a FloPy grid object (e.g., `model.modelgrid`). It uses the grid's dimensions (`nlay`, `nrow`, `ncol`) and connectivity information to correctly map the 1D `FLOW-JA-FACE` data into the 3D space of the model grid. The module is primarily designed for structured grids but has logic to handle different grid types. **Iterative Model Solution (IMS) Package:** The solver performance metrics extracted by `get_residuals` are generated by the IMS solver. Understanding the relationship between IMS settings (e.g., `HCLOSE`, `RCLOSE`, `MAXIMUM_ITERATIONS`) and the resulting residuals is key to using this module for debugging.","This module serves as a utility library for **post-processing raw output files** from a MODFLOW 6 (MF6) simulation. It is not a model package (like `NPF` or `WEL`) nor a solver (like `IMS`). Its primary function is to translate low-level, machine-readable model outputs into formats that are more intuitive and useful for analysis, visualization, and debugging by a hydrologist.

Specifically, it focuses on two key post-processing tasks:

1.  **Calculating Inter-Cell Flows:** The `get_structured_faceflows` function reads the `FLOW-JA-FACE` array from a MODFLOW 6 Cell-by-Cell Budget (CBC) file. This array is a 1D list of flows between connected cells. The function intelligently uses the model's grid information to restructure this data into three separate 3D arrays representing flows across the **right**, **front**, and **lower** faces of each cell in a structured grid. This is invaluable for detailed water budget analysis and creating flow vector visualizations.

2.  **Extracting Solver Convergence Information:** The `get_residuals` function parses the text-based MODFLOW 6 Listing File (`.lst`). It extracts the head-change and flow residuals for each outer and inner iteration of the solver for every time step. This provides a detailed history of the model's convergence performance, which is essential for diagnosing numerical instability or model failure.

In summary, this module acts as a bridge, converting raw MF6 output data into actionable, human-interpretable arrays and data structures."
reference.py,,"mf6 a simple class to locate the model grid in x-y space

.. deprecated:: 3.9
    This class will be removed in FloPy 3.10+. Use
    :class:`~flopy.discretization.structuredgrid.StructuredGrid`
    instead.

Parameters
----------

delr : numpy ndarray
    the model discretization delr vector

delc : numpy ndarray
    the model discretization delc vector

lenuni : int
    the length units flag from the discretization package

xul : float
    the x coordinate of the upper left corner of the grid

yul  This module's primary purpose is to establish and manage the **spatial reference** for a MODFLOW 6 model grid. It acts as a bridge between the model's internal, abstract grid indices (layer, row, column) and a real-world geographic coordinate system (e.g., UTM, State Plane).

It is not a MODFLOW package itself (like `WEL` or `RIV`) nor a solver (like `IMS` or `NWT`). Instead, it's a critical **utility** that stores georeferencing metadata. This metadata includes:

*   **Origin Point:** The real-world coordinates of the model grid's upper-left corner (`xul`, `yul`).
*   **Grid Orientation:** The rotation angle of the grid relative to the coordinate system (`rotation`).
*   **Grid Cell Dimensions:** The column and row spacings (`delr`, `delc`), which it typically gets from a discretization package.
*   **Coordinate Reference System (CRS):** The projection definition, specified using an EPSG code or a Proj4 string.

By holding this information, the module enables FloPy to perform essential georeferencing tasks, such as converting between cell indices and real-world coordinates, creating accurately placed plots, and exporting model data to GIS formats like shapefiles. The classes `StructuredSpatialReference` and `VertexSpatialReference` were tailored to handle structured (DIS) and vertex-based (DISV) grids, respectively. **Scenario 1: Building a Georeferenced Model from Scratch** **Scenario 2: Visualizing and Validating an Existing Model** **Scenario 3: Exporting Model Results to GIS for Analysis** **`flopy.discretization` Module:** This is the modern replacement for `reference.py`. Classes like `StructuredGrid`, `VertexGrid`, and `UnstructuredGrid` in this new module now handle both the grid's geometry (cell shapes, connectivity) and its spatial reference. The logic has been unified and extended, making it more powerful and intuitive. All new FloPy development should use this module. **Discretization Packages (DIS, DISV, DISU):** These are the core MODFLOW 6 packages that define the grid's structure. The `reference.py` module is fundamentally linked to them. The DIS package defines the number of rows/columns and the `delr`/`delc` arrays (cell dimensions), which the `StructuredSpatialReference` class uses, along with the origin and rotation, to calculate the coordinates of each cell. **`flopy.plot` and `flopy.export` Modules:** These are the primary consumers of the spatial reference information. Plotting functions like `PlotMapView` rely on the georeferencing data to create maps with correct scales, coordinates, and orientations. Similarly, export functions that generate GIS files (`.shp`, `.vtu`) require the CRS information from the spatial reference object to produce valid, usable outputs. Without a properly configured spatial reference, plots would be in abstract ""model units,"" and exported files would lack projection, making them difficult to use.","This module's primary purpose is to establish and manage the **spatial reference** for a MODFLOW 6 model grid. It acts as a bridge between the model's internal, abstract grid indices (layer, row, column) and a real-world geographic coordinate system (e.g., UTM, State Plane).

It is not a MODFLOW package itself (like `WEL` or `RIV`) nor a solver (like `IMS` or `NWT`). Instead, it's a critical **utility** that stores georeferencing metadata. This metadata includes:

*   **Origin Point:** The real-world coordinates of the model grid's upper-left corner (`xul`, `yul`).
*   **Grid Orientation:** The rotation angle of the grid relative to the coordinate system (`rotation`).
*   **Grid Cell Dimensions:** The column and row spacings (`delr`, `delc`), which it typically gets from a discretization package.
*   **Coordinate Reference System (CRS):** The projection definition, specified using an EPSG code or a Proj4 string.

By holding this information, the module enables FloPy to perform essential georeferencing tasks, such as converting between cell indices and real-world coordinates, creating accurately placed plots, and exporting model data to GIS formats like shapefiles. The classes `StructuredSpatialReference` and `VertexSpatialReference` were tailored to handle structured (DIS) and vertex-based (DISV) grids, respectively."
