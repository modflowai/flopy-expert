{
  "metadata": {
    "purpose": "Demonstrates grid utility functions for converting structured grids to unstructured DISU and DISV grids, and retrieving layer/node indices from node numbers",
    "primary_phase": 1,
    "modflow_version": "mf6",
    "packages_used": [
      "gridutil",
      "get_disu_kwargs",
      "get_disv_kwargs",
      "get_lni"
    ],
    "keywords": [
      "disu",
      "disv",
      "unstructured",
      "grid",
      "conversion",
      "discretization",
      "vertices",
      "connectivity",
      "layer",
      "node"
    ]
  },
  "models": [
    {
      "name": "disu_grid_conversion",
      "description": "Converts a structured grid to DISU unstructured discretization",
      "code": "import numpy as np\nimport flopy\nfrom flopy.utils.gridutil import get_disu_kwargs\n\n# Phase 1: Discretization - Create DISU from structured grid\nprint('Creating DISU grid from structured grid parameters...')\n\n# Define structured grid parameters\nnlay = 2\nnrow = 10\nncol = 15\ndelr = np.array(ncol * [100.0])  # 100m cells in x-direction\ndelc = np.array(nrow * [100.0])  # 100m cells in y-direction\ntop = 0.0\nbotm = np.array([-10.0, -30.0])  # 2 layers\n\n# Convert to DISU kwargs\ndisu_kwargs = get_disu_kwargs(\n    nlay=nlay,\n    nrow=nrow,\n    ncol=ncol,\n    delr=delr,\n    delc=delc,\n    tp=top,\n    botm=botm,\n    return_vertices=True\n)\n\n# Create simulation and model\nsim = flopy.mf6.MFSimulation(\n    sim_name='disu_example',\n    exe_name='mf6',\n    version='mf6',\n    sim_ws='./model_disu'\n)\n\n# Create temporal discretization\ntdis = flopy.mf6.ModflowTdis(\n    sim,\n    time_units='DAYS',\n    perioddata=[[1.0, 1, 1.0]]\n)\n\n# Create groundwater flow model\ngwf = flopy.mf6.ModflowGwf(\n    sim,\n    modelname='gwf',\n    save_flows=True\n)\n\n# Create DISU package\ndisu = flopy.mf6.ModflowGwfdisu(\n    gwf,\n    nodes=disu_kwargs['nodes'],\n    nvert=disu_kwargs['nvert'],\n    top=disu_kwargs['top'],\n    bot=disu_kwargs['bot'],\n    area=disu_kwargs['area'],\n    iac=disu_kwargs['iac'],\n    ja=disu_kwargs['ja'],\n    ihc=disu_kwargs['ihc'],\n    cl12=disu_kwargs['cl12'],\n    hwva=disu_kwargs['hwva'],\n    vertices=disu_kwargs['vertices'],\n    cell2d=disu_kwargs['cell2d']\n)\n\n# Phase 2: Flow Properties\nnpf = flopy.mf6.ModflowGwfnpf(\n    gwf,\n    k=10.0,  # Hydraulic conductivity\n    save_specific_discharge=True\n)\n\n# Phase 3: Initial Conditions\nic = flopy.mf6.ModflowGwfic(gwf, strt=0.0)\n\n# Phase 4: Boundary Conditions\n# Add constant head on left side (first column equivalent)\nchd_cells = []\nfor lay in range(nlay):\n    for row in range(nrow):\n        node = lay * nrow * ncol + row * ncol  # First column nodes\n        chd_cells.append((node, 1.0))\n\nchd = flopy.mf6.ModflowGwfchd(\n    gwf,\n    stress_period_data=chd_cells\n)\n\n# Add wells in middle of domain\nwel_cells = [\n    (nrow * ncol // 2 + ncol // 2, -500.0),  # Layer 1 center\n    (nlay * nrow * ncol - nrow * ncol // 2 - ncol // 2, -300.0)  # Layer 2 center\n]\n\nwel = flopy.mf6.ModflowGwfwel(\n    gwf,\n    stress_period_data=wel_cells\n)\n\n# Phase 5: Solver Configuration\nims = flopy.mf6.ModflowIms(\n    sim,\n    complexity='SIMPLE',\n    print_option='SUMMARY',\n    outer_maximum=100,\n    inner_maximum=50,\n    outer_dvclose=1e-6,\n    inner_dvclose=1e-6\n)\n\n# Register solver\nsim.register_ims_package(ims, [gwf.name])\n\n# Phase 6: Output Control\noc = flopy.mf6.ModflowGwfoc(\n    gwf,\n    head_filerecord='gwf.hds',\n    budget_filerecord='gwf.cbc',\n    saverecord=[('HEAD', 'ALL'), ('BUDGET', 'ALL')]\n)\n\n# Write and run (optional)\nprint(f'\\nDISU grid created with {disu_kwargs[\"nodes\"]} nodes')\nprint(f'Number of vertices: {disu_kwargs[\"nvert\"]}')\nprint(f'Number of connections: {len(disu_kwargs[\"ja\"])}')\nprint(f'\\nGrid conversion complete!')\n\n# Phase 7: Verification\nprint(f'\\nVerifying DISU properties:')\nprint(f'  Total nodes: {disu.nodes.get_data()}')\nprint(f'  Total vertices: {disu.nvert.get_data()}')\nprint(f'  First 5 areas: {disu.area.array[:5]}')\nprint(f'  First 5 connections (iac): {disu.iac.array[:5]}')"
    },
    {
      "name": "disv_grid_conversion",
      "description": "Converts a structured grid to DISV vertex discretization",
      "code": "import numpy as np\nimport flopy\nfrom flopy.utils.gridutil import get_disv_kwargs\n\n# Phase 1: Discretization - Create DISV from structured grid\nprint('Creating DISV grid from structured grid parameters...')\n\n# Define structured grid parameters\nnlay = 2\nnrow = 8\nncol = 12\ndelr = np.array(ncol * [50.0])  # 50m cells in x-direction\ndelc = np.array(nrow * [50.0])  # 50m cells in y-direction\ntop = 10.0\nbotm = np.array([0.0, -20.0])  # 2 layers\n\n# Convert to DISV kwargs\ndisv_kwargs = get_disv_kwargs(\n    nlay=nlay,\n    nrow=nrow,\n    ncol=ncol,\n    delr=delr,\n    delc=delc,\n    tp=top,\n    botm=botm,\n    xorigin=0.0,\n    yorigin=0.0\n)\n\n# Create simulation and model\nsim = flopy.mf6.MFSimulation(\n    sim_name='disv_example',\n    exe_name='mf6',\n    version='mf6',\n    sim_ws='./model_disv'\n)\n\n# Create temporal discretization\ntdis = flopy.mf6.ModflowTdis(\n    sim,\n    time_units='DAYS',\n    perioddata=[[1.0, 1, 1.0]]\n)\n\n# Create groundwater flow model\ngwf = flopy.mf6.ModflowGwf(\n    sim,\n    modelname='gwf',\n    save_flows=True\n)\n\n# Create DISV package\ndisv = flopy.mf6.ModflowGwfdisv(\n    gwf,\n    nlay=disv_kwargs['nlay'],\n    ncpl=disv_kwargs['ncpl'],\n    nvert=disv_kwargs['nvert'],\n    top=disv_kwargs['top'],\n    botm=disv_kwargs['botm'],\n    vertices=disv_kwargs['vertices'],\n    cell2d=disv_kwargs['cell2d']\n)\n\n# Phase 2: Flow Properties\nnpf = flopy.mf6.ModflowGwfnpf(\n    gwf,\n    k=5.0,  # Hydraulic conductivity\n    save_specific_discharge=True\n)\n\n# Phase 3: Initial Conditions\nic = flopy.mf6.ModflowGwfic(gwf, strt=5.0)\n\n# Phase 4: Boundary Conditions\n# Add constant head boundary on one side\nncpl = disv_kwargs['ncpl']\nchd_cells = []\nfor lay in range(nlay):\n    for i in range(nrow):\n        cell_id = lay * ncpl + i * ncol  # First column cells\n        chd_cells.append((cell_id, 10.0))\n\nchd = flopy.mf6.ModflowGwfchd(\n    gwf,\n    stress_period_data=chd_cells\n)\n\n# Add recharge\nrch = flopy.mf6.ModflowGwfrcha(\n    gwf,\n    recharge=0.001  # 1 mm/day\n)\n\n# Phase 5: Solver Configuration\nims = flopy.mf6.ModflowIms(\n    sim,\n    complexity='SIMPLE',\n    print_option='SUMMARY',\n    outer_maximum=100,\n    inner_maximum=50,\n    outer_dvclose=1e-6,\n    inner_dvclose=1e-6\n)\n\n# Register solver\nsim.register_ims_package(ims, [gwf.name])\n\n# Phase 6: Output Control\noc = flopy.mf6.ModflowGwfoc(\n    gwf,\n    head_filerecord='gwf.hds',\n    budget_filerecord='gwf.cbc',\n    saverecord=[('HEAD', 'ALL'), ('BUDGET', 'ALL')]\n)\n\n# Write and run (optional)\nprint(f'\\nDISV grid created:')\nprint(f'  Layers: {disv_kwargs[\"nlay\"]}')\nprint(f'  Cells per layer: {disv_kwargs[\"ncpl\"]}')\nprint(f'  Number of vertices: {disv_kwargs[\"nvert\"]}')\nprint(f'\\nGrid conversion complete!')\n\n# Phase 7: Verification\nprint(f'\\nVerifying DISV properties:')\nprint(f'  Total layers: {disv.nlay.get_data()}')\nprint(f'  Cells per layer: {disv.ncpl.get_data()}')\nprint(f'  Total vertices: {disv.nvert.get_data()}')\nprint(f'  Top elevation: {disv.top.array[0]}')\nprint(f'  Bottom elevations: {disv.botm.array[:, 0]}')"
    },
    {
      "name": "layer_node_index_utility",
      "description": "Demonstrates get_lni utility for converting node numbers to layer/node indices",
      "code": "import numpy as np\nfrom flopy.utils.gridutil import get_lni\n\n# Demonstrate get_lni utility function\nprint('Layer-Node Index (LNI) Utility Demonstration')\nprint('=' * 50)\n\n# Example 1: Single layer model\nprint('\\nExample 1: Single Layer Model')\nncpl = 10  # 10 cells per layer\nnodes = [0, 5, 9]  # First, middle, and last cells\nlni = get_lni(ncpl, nodes)\nprint(f'  Cells per layer: {ncpl}')\nprint(f'  Node numbers: {nodes}')\nprint(f'  Layer-Node indices:')\nfor node, (layer, idx) in zip(nodes, lni):\n    print(f'    Node {node} -> Layer {layer}, Index {idx}')\n\n# Example 2: Multi-layer model with list ncpl\nprint('\\nExample 2: Two Layer Model (equal cells per layer)')\nncpl = [10, 10]  # 10 cells in each layer\nnodes = [0, 9, 10, 15, 19]  # Various nodes\nlni = get_lni(ncpl, nodes)\nprint(f'  Cells per layer: {ncpl}')\nprint(f'  Node numbers: {nodes}')\nprint(f'  Layer-Node indices:')\nfor node, (layer, idx) in zip(nodes, lni):\n    print(f'    Node {node} -> Layer {layer}, Index {idx}')\n\n# Example 3: Variable cells per layer\nprint('\\nExample 3: Two Layer Model (variable cells per layer)')\nncpl = [10, 20]  # 10 cells in layer 1, 20 in layer 2\nnodes = [5, 9, 10, 25, 29]  # Various nodes\nlni = get_lni(ncpl, nodes)\nprint(f'  Cells per layer: {ncpl}')\nprint(f'  Node numbers: {nodes}')\nprint(f'  Layer-Node indices:')\nfor node, (layer, idx) in zip(nodes, lni):\n    print(f'    Node {node} -> Layer {layer}, Index {idx}')\n\n# Example 4: Practical use case - finding neighbors\nprint('\\nExample 4: Finding Cell Neighbors')\nncpl = [15, 15, 15]  # 3 layers, 15 cells each\nnode = 20  # Cell in layer 2\n\n# Find layer and index\nlni = get_lni(ncpl, [node])\nlayer, idx = lni[0]\nprint(f'  Node {node} is in Layer {layer}, Cell index {idx}')\n\n# Calculate potential neighbors\nneighbors = []\n# Same layer neighbors\nif idx > 0:\n    neighbors.append(node - 1)  # Previous cell\nif idx < ncpl[layer] - 1:\n    neighbors.append(node + 1)  # Next cell\n# Vertical neighbors\nif layer > 0:\n    neighbors.append(node - ncpl[layer-1])  # Cell above\nif layer < len(ncpl) - 1:\n    neighbors.append(node + ncpl[layer])  # Cell below\n\nprint(f'  Potential neighbor nodes: {neighbors}')\nneighbor_lni = get_lni(ncpl, neighbors)\nprint(f'  Neighbor layer-indices:')\nfor n, (l, i) in zip(neighbors, neighbor_lni):\n    print(f'    Node {n} -> Layer {l}, Index {i}')\n\n# Example 5: Automatic layer inference\nprint('\\nExample 5: Automatic Layer Inference')\nncpl = 5  # When int, infers layers from node numbers\nnodes = [4, 9, 14, 19]  # Nodes spanning multiple layers\nlni = get_lni(ncpl, nodes)\nprint(f'  Cells per layer: {ncpl} (integer - will infer layers)')\nprint(f'  Node numbers: {nodes}')\nprint(f'  Layer-Node indices (inferred):')\nfor node, (layer, idx) in zip(nodes, lni):\n    print(f'    Node {node} -> Layer {layer}, Index {idx}')\n\nprint('\\n' + '=' * 50)\nprint('LNI utility demonstration complete!')"
    }
  ]
}