{
  "metadata": {
    "purpose": "Tests execution of FloPy tutorial and example notebooks by converting Python scripts to Jupyter notebooks and running them",
    "primary_phase": 7,
    "modflow_version": "mf6",
    "packages_used": [
      "jupytext",
      "pytest",
      "flaky"
    ],
    "keywords": [
      "notebook",
      "tutorial",
      "example",
      "testing",
      "jupyter",
      "documentation",
      "validation"
    ]
  },
  "models": [
    {
      "name": "simple_mf6_flow_model",
      "description": "Basic MODFLOW 6 groundwater flow model demonstrating all 7 phases of model development",
      "code": "#!/usr/bin/env python\n\"\"\"\nSimple MODFLOW 6 groundwater flow model demonstrating the 7 phases of model development.\nThis represents the type of model that would be tested in notebook examples.\n\"\"\"\n\nimport os\nimport numpy as np\nimport flopy\n\n# Model configuration\nname = 'tutorial_model'\nws = './temp'\nsim_name = 'sim'\n\n# Create workspace\nif not os.path.exists(ws):\n    os.makedirs(ws)\n\n# ==============================================================================\n# Phase 1: DISCRETIZATION - Define the grid and time\n# ==============================================================================\nprint('Phase 1: Setting up discretization...')\n\n# Spatial discretization\nnlay = 3  # Number of layers\nnrow = 10  # Number of rows\nncol = 10  # Number of columns\ndelr = 100.0  # Column width (m)\ndelc = 100.0  # Row width (m)\ntop = 0.0  # Top of model (m)\nbotm = [-10.0, -20.0, -30.0]  # Bottom elevations for each layer\n\n# Temporal discretization\nnper = 3  # Number of stress periods\nperlen = [1.0, 100.0, 100.0]  # Length of each stress period (days)\nnstp = [1, 10, 10]  # Number of time steps in each period\ntsmult = [1.0, 1.0, 1.0]  # Time step multiplier\n\n# ==============================================================================\n# Phase 2: PROPERTIES - Define aquifer properties\n# ==============================================================================\nprint('Phase 2: Setting up aquifer properties...')\n\n# Hydraulic conductivity (m/day)\nhk = 10.0  # Horizontal hydraulic conductivity\nvk = 1.0   # Vertical hydraulic conductivity\n\n# Storage properties\nsy = 0.15  # Specific yield (dimensionless)\nss = 1e-5  # Specific storage (1/m)\niconvert = 1  # Flag for convertible layers\n\n# ==============================================================================\n# Phase 3: INITIAL CONDITIONS - Set starting heads\n# ==============================================================================\nprint('Phase 3: Setting up initial conditions...')\n\n# Initial heads\nstrt = -5.0  # Starting head (m)\n\n# ==============================================================================\n# Phase 4: BOUNDARY CONDITIONS - Define sources/sinks\n# ==============================================================================\nprint('Phase 4: Setting up boundary conditions...')\n\n# Constant head boundary (left side of model)\nchd_rec = []\nfor k in range(nlay):\n    for i in range(nrow):\n        # Left boundary (column 0)\n        chd_rec.append([(k, i, 0), 0.0])  # Layer, row, col, head\n\n# Well package (pumping well)\nwel_rec = [\n    # Layer, row, col, pumping rate (negative for extraction)\n    [(1, 4, 4), -500.0],  # Pumping well in layer 2, center of model\n]\n\n# Recharge package\nrech = 0.001  # Recharge rate (m/day)\n\n# ==============================================================================\n# Phase 5: SOLVER CONFIGURATION - Set up numerical solver\n# ==============================================================================\nprint('Phase 5: Setting up solver...')\n\n# IMS solver parameters\ninner_maximum = 100\nouter_maximum = 50\ninner_dvclose = 1e-6\nouter_dvclose = 1e-6\n\n# ==============================================================================\n# CREATE AND BUILD MODEL\n# ==============================================================================\nprint('\\nBuilding MODFLOW 6 model...')\n\n# Create simulation\nsim = flopy.mf6.MFSimulation(\n    sim_name=sim_name,\n    version='mf6',\n    exe_name='/home/danilopezmella/flopy_expert/bin/mf6',\n    sim_ws=ws,\n    memory_print_option='all'\n)\n\n# Create temporal discretization\ntdis = flopy.mf6.ModflowTdis(\n    sim,\n    time_units='DAYS',\n    nper=nper,\n    perioddata=[(perlen[i], nstp[i], tsmult[i]) for i in range(nper)]\n)\n\n# Create groundwater flow model\ngwf = flopy.mf6.ModflowGwf(\n    sim,\n    modelname=name,\n    save_flows=True,\n    newtonoptions='NEWTON',\n    print_input=True,\n    print_flows=True\n)\n\n# Create iterative model solution\nims = flopy.mf6.ModflowIms(\n    sim,\n    print_option='SUMMARY',\n    complexity='SIMPLE',\n    outer_dvclose=outer_dvclose,\n    outer_maximum=outer_maximum,\n    under_relaxation='NONE',\n    inner_maximum=inner_maximum,\n    inner_dvclose=inner_dvclose,\n    rcloserecord=0.001,\n    linear_acceleration='CG',\n    scaling_method='NONE',\n    reordering_method='NONE',\n    relaxation_factor=0.97\n)\n\n# Register solver\nsim.register_ims_package(ims, [gwf.name])\n\n# Discretization package\ndis = flopy.mf6.ModflowGwfdis(\n    gwf,\n    nlay=nlay,\n    nrow=nrow,\n    ncol=ncol,\n    delr=delr,\n    delc=delc,\n    top=top,\n    botm=botm\n)\n\n# Node property flow package\nnpf = flopy.mf6.ModflowGwfnpf(\n    gwf,\n    save_specific_discharge=True,\n    icelltype=iconvert,\n    k=hk,\n    k33=vk\n)\n\n# Storage package\nsto = flopy.mf6.ModflowGwfsto(\n    gwf,\n    save_flows=True,\n    iconvert=iconvert,\n    ss=ss,\n    sy=sy,\n    steady_state={0: True, 1: False, 2: False},\n    transient={0: False, 1: True, 2: True}\n)\n\n# Initial conditions package\nic = flopy.mf6.ModflowGwfic(gwf, strt=strt)\n\n# Constant head package\nchd = flopy.mf6.ModflowGwfchd(\n    gwf,\n    stress_period_data=chd_rec,\n    save_flows=True\n)\n\n# Well package\nwel = flopy.mf6.ModflowGwfwel(\n    gwf,\n    stress_period_data=wel_rec,\n    save_flows=True\n)\n\n# Recharge package\nrch = flopy.mf6.ModflowGwfrcha(\n    gwf,\n    recharge=rech,\n    save_flows=True\n)\n\n# Output control\noc = flopy.mf6.ModflowGwfoc(\n    gwf,\n    head_filerecord=f'{name}.hds',\n    budget_filerecord=f'{name}.cbc',\n    headprintrecord=[('COLUMNS', 10, 'WIDTH', 15, 'DIGITS', 6, 'GENERAL')],\n    saverecord=[('HEAD', 'ALL'), ('BUDGET', 'ALL')],\n    printrecord=[('HEAD', 'LAST'), ('BUDGET', 'LAST')]\n)\n\n# ==============================================================================\n# Phase 6: OBSERVATIONS (Optional) - Monitor specific locations\n# ==============================================================================\nprint('Phase 6: Setting up observations...')\n\n# Observation package\nobs_data = [\n    ('obs1', 'HEAD', (1, 4, 4)),  # Observe head at pumping well location\n    ('obs2', 'HEAD', (1, 0, 0)),  # Observe head at corner\n]\n\nobs = flopy.mf6.ModflowUtlobs(\n    gwf,\n    filename=f'{name}.obs',\n    print_input=True,\n    continuous={'obs.csv': obs_data}\n)\n\n# ==============================================================================\n# RUN MODEL\n# ==============================================================================\nprint('\\nWriting input files...')\nsim.write_simulation()\n\nprint('Running model...')\nsuccess, buff = sim.run_simulation(silent=False)\n\nif success:\n    print('\\nModel ran successfully!')\nelse:\n    print('\\nModel failed to run')\n    for line in buff:\n        print(line)\n\n# ==============================================================================\n# Phase 7: POST-PROCESSING - Analyze results\n# ==============================================================================\nif success:\n    print('\\nPhase 7: Post-processing results...')\n    \n    # Read head results\n    head_file = os.path.join(ws, f'{name}.hds')\n    hds = flopy.utils.HeadFile(head_file)\n    \n    # Get heads for last time step\n    heads = hds.get_data()\n    \n    # Print summary statistics\n    print(f'\\nHead Statistics (final time step):')\n    print(f'  Minimum head: {heads.min():.2f} m')\n    print(f'  Maximum head: {heads.max():.2f} m')\n    print(f'  Mean head: {heads.mean():.2f} m')\n    \n    # Read budget file\n    budget_file = os.path.join(ws, f'{name}.cbc')\n    cbc = flopy.utils.CellBudgetFile(budget_file)\n    \n    # Get budget terms\n    budget_terms = cbc.get_unique_record_names()\n    print(f'\\nAvailable budget terms: {budget_terms}')\n    \n    # Read observations\n    obs_file = os.path.join(ws, 'obs.csv')\n    if os.path.exists(obs_file):\n        print('\\nObservation results saved to obs.csv')\n    \n    print('\\nModel completed successfully!')\n    print(f'Results saved in: {ws}')"
    }
  ]
}